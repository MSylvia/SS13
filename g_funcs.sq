function _command_name(  ) {
	local name
	if ( ::command_name ) {
		return ::command_name
	}
	name = "Central Command"
	::command_name = name
	return name
}

function _station_name(  ) {
	if ( ::station_name ) {
		return ::station_name
	}
	if ( ::config && ::config.station_name ) {
		::station_name = ::config.station_name
	} else {
		::station_name = ::new_station_name()
	}
	if ( ::config && ::config.server_name ) {
		::game.name = "" + ::txt.mark( ::config.server_name ) + ::txt.mark( ::config.server_name == ::station_name ? "" : ": " + ::txt.mark( ::station_name ) )
	} else {
		::game.name = ::station_name
	}
	return ::station_name
}

function _syndicate_name(  ) {
	local name
	if ( ::syndicate_name ) {
		return ::syndicate_name
	}
	name = ""
	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 4681 ) { _ = "Clandestine" }
	else if ( _ < 9362 ) { _ = "Prima" }
	else if ( _ < 14043 ) { _ = "Blue" }
	else if ( _ < 18724 ) { _ = "Zero-G" }
	else if ( _ < 23405 ) { _ = "Max" }
	else if ( _ < 28086 ) { _ = "Blasto" }
	else if ( _ < 32767 ) { _ = "Waffle" }
	else if ( _ < 37448 ) { _ = "North" }
	else if ( _ < 42129 ) { _ = "Omni" }
	else if ( _ < 46810 ) { _ = "Newton" }
	else if ( _ < 51491 ) { _ = "Cyber" }
	else if ( _ < 56172 ) { _ = "Bonk" }
	else if ( _ < 60853 ) { _ = "Gene" }
	else  { _ = "Gib" }

	name += _
	if ( ::prob( 80 ) ) {
		name += " "
		if ( ::prob( 60 ) ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 3276 ) { _ = "Syndicate" }
			else if ( _ < 6552 ) { _ = "Consortium" }
			else if ( _ < 9828 ) { _ = "Collective" }
			else if ( _ < 13104 ) { _ = "Corporation" }
			else if ( _ < 16380 ) { _ = "Group" }
			else if ( _ < 19656 ) { _ = "Holdings" }
			else if ( _ < 22932 ) { _ = "Biotech" }
			else if ( _ < 26208 ) { _ = "Industries" }
			else if ( _ < 29484 ) { _ = "Systems" }
			else if ( _ < 32760 ) { _ = "Products" }
			else if ( _ < 36036 ) { _ = "Chemicals" }
			else if ( _ < 39312 ) { _ = "Enterprises" }
			else if ( _ < 42588 ) { _ = "Family" }
			else if ( _ < 45864 ) { _ = "Creations" }
			else if ( _ < 49140 ) { _ = "International" }
			else if ( _ < 52416 ) { _ = "Intergalactic" }
			else if ( _ < 55692 ) { _ = "Interplanetary" }
			else if ( _ < 58968 ) { _ = "Foundation" }
			else if ( _ < 62244 ) { _ = "Positronics" }
			else  { _ = "Hive" }

			name += _
		} else {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 8191 ) { _ = "Syndi" }
			else if ( _ < 16382 ) { _ = "Corp" }
			else if ( _ < 24573 ) { _ = "Bio" }
			else if ( _ < 32764 ) { _ = "System" }
			else if ( _ < 40955 ) { _ = "Prod" }
			else if ( _ < 49146 ) { _ = "Chem" }
			else if ( _ < 57337 ) { _ = "Inter" }
			else  { _ = "Hive" }

			name += _
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 32767 ) { _ = "" }
			else  { _ = "-" }

			name += _
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 9362 ) { _ = "Tech" }
			else if ( _ < 18724 ) { _ = "Sun" }
			else if ( _ < 28086 ) { _ = "Co" }
			else if ( _ < 37448 ) { _ = "Tek" }
			else if ( _ < 46810 ) { _ = "X" }
			else if ( _ < 56172 ) { _ = "Inc" }
			else  { _ = "Code" }

			name += _
		}
	} else {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 21845 ) { _ = "-" }
		else if ( _ < 43690 ) { _ = "*" }
		else  { _ = "" }

		name += _
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 5957 ) { _ = "Tech" }
		else if ( _ < 11914 ) { _ = "Sun" }
		else if ( _ < 17871 ) { _ = "Co" }
		else if ( _ < 23828 ) { _ = "Tek" }
		else if ( _ < 29785 ) { _ = "X" }
		else if ( _ < 35742 ) { _ = "Inc" }
		else if ( _ < 41699 ) { _ = "Gen" }
		else if ( _ < 47656 ) { _ = "Star" }
		else if ( _ < 53613 ) { _ = "Dyne" }
		else if ( _ < 59570 ) { _ = "Code" }
		else  { _ = "Hive" }

		name += _
	}
	::syndicate_name = name
	return name
}

function above_neck( zone ) {
	local zones
	zones = ::List([ "head", "mouth", "eyes" ])
	if ( zones.Find( zone ) ) {
		return 1
	} else {
		return 0
	}
}

function active_ais( check_mind ) {
	local A, _default
	if ( check_mind == null ) {
		check_mind = 0
	}
	_default = ::List()
	A = null
	foreach (_ in ::living_mob_list ) {
		A = _
		if ( !::istype( A, ::MobLivingSiliconAi ) ) {
			continue
		}
		if ( A.stat == 2 ) {
			continue
		}
		if ( A.control_disabled == 1 ) {
			continue
		}
		if ( check_mind ) {
			if ( !A.mind ) {
				continue
			}
		}
		_default += A
	}
	return _default
	return _default
}

function add_logs( user, target, what_done, object, addition ) {
	local newhealthtxt, L
	if ( object == null ) {
		object = null
	}
	if ( addition == null ) {
		addition = null
	}
	newhealthtxt = ""
	if ( target && ::istype( target, ::MobLiving ) ) {
		L = target
		newhealthtxt = " (NEWHP: " + ::txt.mark( L.health ) + ")"
	}
	if ( user && ::ismob( user ) ) {
		user.attack_log += "[" + ::txt.mark( ::time_stamp() ) + "] <font color='red'>Has " + ::txt.mark( what_done ) + " " + ::txt.mark( target ? "" + ::txt.mark( target.name ) + ::txt.mark( ::ismob( target ) && target.ckey ? "(" + ::txt.mark( target.ckey ) + ")" : "" ) : "NON-EXISTANT SUBJECT" ) + ::txt.mark( object ? " with " + ::txt.mark( object ) : " " ) + ::txt.mark( addition ) + ::txt.mark( newhealthtxt ) + "</font>"
	}
	if ( target && ::ismob( target ) ) {
		target.attack_log += "[" + ::txt.mark( ::time_stamp() ) + "] <font color='orange'>Has been " + ::txt.mark( what_done ) + " by " + ::txt.mark( user ? "" + ::txt.mark( user.name ) + ::txt.mark( ::ismob( user ) && user.ckey ? "(" + ::txt.mark( user.ckey ) + ")" : "" ) : "NON-EXISTANT SUBJECT" ) + ::txt.mark( object ? " with " + ::txt.mark( object ) : " " ) + ::txt.mark( addition ) + ::txt.mark( newhealthtxt ) + "</font>"
	}
	::log_attack( "" + ::txt.mark( user ? "" + ::txt.mark( user.name ) + ::txt.mark( ::ismob( user ) && user.ckey ? "(" + ::txt.mark( user.ckey ) + ")" : "" ) : "NON-EXISTANT SUBJECT" ) + " " + ::txt.mark( what_done ) + " " + ::txt.mark( target ? "" + ::txt.mark( target.name ) + ::txt.mark( ::ismob( target ) && target.ckey ? "(" + ::txt.mark( target.ckey ) + ")" : "" ) : "NON-EXISTANT SUBJECT" ) + ::txt.mark( object ? " with " + ::txt.mark( object ) : " " ) + ::txt.mark( addition ) + ::txt.mark( newhealthtxt ) )
}

function add_radio( radio, freq ) {
	if ( !freq || !radio ) {
		return
	}
	if ( !::all_radios["" + ::txt.mark( freq )] ) {
		::all_radios["" + ::txt.mark( freq )] = ::List([ radio ])
		return freq
	}
	::all_radios["" + ::txt.mark( freq )] = ::all_radios["" + ::txt.mark( freq )] | radio
	return freq
}

function add_zero( t, u ) {
	if ( ::length( t ) < u ) {
		t = "0" + ::txt.mark( t )
		// goto 2
	}
	return t
}

function addtimer( thingToCall, procToCall, wait, argList ) {
	local event
	if ( argList == null ) {
		argList = ::List()
	}
	if ( !::SStimer ) {
		return
	}
	if ( !thingToCall || ( !procToCall || wait <= 0 ) ) {
		return
	}
	if ( !::SStimer.can_fire ) {
		::SStimer.can_fire = 1
		::SStimer.next_fire = ::game.time + ::SStimer.wait
	}
	event = ::DatumTimedevent()
	event.thingToCall = thingToCall
	event.procToCall = procToCall
	event.timeToRun = ::game.time + wait
	event.argList = argList
	::SStimer.processing += event
	return event.id
}

function admin_forcemove( mover, newloc ) {
	if ( mover.buckled ) {
		mover.buckled.unbuckle mob()
	}
	if ( mover.buckled_mob ) {
		mover.unbuckle mob( "LIST_CALL", ::List({ ["force"]= 1 }) )
	}
	mover.loc = newloc
	mover.on forcemove( newloc )
}

function admin_keyword_to_flag( word, previous_rights ) {
	local flag
	if ( previous_rights == null ) {
		previous_rights = 0
	}
	flag = 0
	local _ = ::ckey( word ) // Was a switch-case, sorry for the mess.
	if ( _=="buildmode" || _=="build" ) {
		flag = 1
	} else if ( _=="admin" ) {
		flag = 2
	} else if ( _=="ban" ) {
		flag = 4
	} else if ( _=="fun" ) {
		flag = 8
	} else if ( _=="server" ) {
		flag = 16
	} else if ( _=="debug" ) {
		flag = 32
	} else if ( _=="permissions" || _=="rights" ) {
		flag = 128
	} else if ( _=="possess" ) {
		flag = 64
	} else if ( _=="stealth" ) {
		flag = 256
	} else if ( _=="rejuv" || _=="rejuvinate" ) {
		flag = 512
	} else if ( _=="varedit" ) {
		flag = 1024
	} else if ( _=="everything" || _=="host" || _=="all" ) {
		flag = 65535
	} else if ( _=="sound" || _=="sounds" ) {
		flag = 2048
	} else if ( _=="spawn" || _=="create" ) {
		flag = 4096
	} else if ( _=="@" || _=="prev" ) {
		flag = previous_rights
	}
	return flag
}

function admin_keyword_to_path( word ) {
	return ::text2path( ::copytext( word, 2, ::findtext( word, " ", 2, 0 ) ) )
}

function adminscrub( t, limit ) {
	if ( limit == null ) {
		limit = 1024
	}
	return ::copytext( ::html_encode( ::strip_html_simple( t ) ), 1, limit )
}

function Advance_Mix( D_list ) {
	local diseases, A, i, D1, D2, to_return
	diseases = ::List()
	A = null
	foreach (_ in D_list ) {
		A = _
		if ( !::istype( A, ::DatumDiseaseAdvance ) ) {
			continue
		}
		diseases += A.Copy()
	}
	if ( !diseases.len ) {
		return
	}
	if ( diseases.len <= 1 ) {
		return ::pick_list( diseases )
	}
	i = 0
	if ( i < 20 && diseases.len > 1 ) {
		i++
		D1 = ::pick_list( diseases )
		diseases -= D1
		D2 = ::pick_list( diseases )
		D2.Mix( D1 )
		// goto 43
	}
	to_return = ::pick_list( diseases )
	to_return.Refresh( 1 )
	return to_return
}

function alien_type_present( alienpath ) {
	local A
	A = null
	foreach (_ in ::living_mob_list ) {
		A = _
		if ( !::istype( A, ::MobLivingCarbonAlienHumanoid ) ) {
			continue
		}
		if ( !::istype( A, alienpath ) ) {
			continue
		}
		if ( !A.key || A.stat == 2 ) {
			continue
		}
		return 1
	}
	return 0
}

function alone_in_area( the_area, must_be_alone, check_type ) {
	local our_area, C
	if ( check_type == null ) {
		check_type = ::MobLivingCarbon
	}
	our_area = ::get_area_master( the_area )
	C = null
	foreach (_ in ::living_mob_list ) {
		C = _
		if ( !::istype( C, check_type ) ) {
			continue
		}
		if ( C == must_be_alone ) {
			continue
		}
		if ( our_area == ::get_area_master( C ) ) {
			return 0
		}
	}
	return 1
}

function angle2dir( degree ) {
	degree = ::SimplifyDegrees( degree )
	if ( degree < 45 ) {
		return ::NORTH
	}
	if ( degree < 90 ) {
		return ::NORTHEAST
	}
	if ( degree < 135 ) {
		return ::EAST
	}
	if ( degree < 180 ) {
		return ::SOUTHEAST
	}
	if ( degree < 225 ) {
		return ::SOUTH
	}
	if ( degree < 270 ) {
		return ::SOUTHWEST
	}
	if ( degree < 315 ) {
		return ::WEST
	}
	return 9
}

function angle2text( degree ) {
	return ::dir2text( ::angle2dir( degree ) )
}

function anim( location, target, a_icon, a_icon_state, flick_anim, sleeptime, direction ) {
	local animation
	if ( sleeptime == null ) {
		sleeptime = 0
	}
	animation = ::AtomMovableOverlay( location )
	if ( direction ) {
		animation.dir = direction
	}
	animation.icon = a_icon
	animation.layer = target.layer + 1
	if ( a_icon_state ) {
		animation.icon_state = a_icon_state
	} else {
		animation.icon_state = "blank"
		animation.master = target
	}
	::sleep( ::max( sleeptime, 15 ) )
	::qdel( animation )
}

function anyprob( value ) {
	return ::rand( 1, value ) == value
}

function appearance_isbanned( M ) {
	local s, startpos, text
	if ( M ) {
		s = null
		foreach (_ in ::appearance_keylist ) {
			s = _
			if ( ::findtext( s, "" + ::txt.mark( M.ckey ), 1, null ) == 1 ) {
				startpos = ::findtext( s, "## ", 1, null ) + 3
				if ( startpos && startpos < ::length( s ) ) {
					text = ::copytext( s, startpos, 0 )
					if ( text ) {
						return text
					}
				}
				return "Reason Unspecified"
			}
		}
	}
	return 0
}

function arctan( x ) {
	local y
	y = ::arcsin( x / ::sqrt( x * x + 1 ) )
	return y
}

function assign_progress_bar( user, progbar ) {
	if ( user && ( user.client && progbar ) ) {
		user.client.images = user.client.images | progbar
	}
}

function AStar( start, end, atom, dist, maxnodes, maxnodedepth, mintargetdist, adjacent, id, exclude, simulated_only ) {
	local open, closed, path, cur, closeenough, L, T, newg, PN, T, i
	if ( maxnodedepth == null ) {
		maxnodedepth = 30
	}
	if ( adjacent == null ) {
		adjacent = ::GoofyFunc
	}
	if ( id == null ) {
		id = null
	}
	if ( exclude == null ) {
		exclude = null
	}
	if ( simulated_only == null ) {
		simulated_only = 1
	}
	if ( maxnodes ) {
		if ( ::getf2( start, dist )( end ) > maxnodes ) {
			return 0
		}
		maxnodedepth = maxnodes
	}
	open = ::Heap( ::GoofyFunc )
	return
	closed = ::List()
	path = null
	start = ::get_turf( start )
	if ( !start ) {
		return 0
	}
	open.Insert( ::PathNode( start, null, 0, ::getf2( start, dist )( end ), 0 ) )
	if ( !open.IsEmpty() && !path ) {
		cur = open.Pop()
		closed.Add( cur.source )
		closeenough = null
		if ( mintargetdist ) {
			closeenough = ::getf2( cur.source, dist )( end ) <= mintargetdist
		}
		if ( maxnodedepth && cur.nt > maxnodedepth ) {
			// goto 97
		}
		if ( cur.source == end || closeenough ) {
			return
			path = ::List()
			path.Add( cur.source )
			if ( cur.prevNode ) {
				cur = cur.prevNode
				path.Add( cur.source )
				// goto 156
			}
		} else {
			L = ::getf2( cur.source, adjacent )( atom, id, simulated_only )
			T = null
			foreach (_ in L ) {
				T = _
				if ( ( T == exclude || T ) in closed ) {
					continue
				}
				newg = cur.g + ::getf2( cur.source, dist )( T )
				if ( !T.PNode ) {
					open.Insert( ::PathNode( T, cur, newg, ::getf2( T, dist )( end ), cur.nt + 1 ) )
				} else if ( newg < T.PNode.g ) {
					T.prevNode = cur
					T.PNode.g = newg
					T.PNode.calc f()
					T.PNode.nt = cur.nt + 1
					open.ReSort( T.PNode )
				}
			}
			// goto 97
		}
	}
	PN = null
	foreach (_ in open.L ) {
		PN = _
		if ( !::istype( PN, ::PathNode ) ) {
			continue
		}
		PN.source.PNode = null
	}
	T = null
	foreach (_ in closed ) {
		T = _
		T.PNode = null
	}
	if ( path ) {
		i = null
		i = 1
		while (i <= path.len / 2) {
			path.Swap( i, path.len - i + 1 )
			i++
		}
	}
	return path
}

function attach_spans( input, spans ) {
	return "" + ::txt.mark( ::message_spans_start( spans ) ) + ::txt.mark( input ) + "</span>"
}

function attempt_initiate_surgery( I, M, user ) {
	// Decompile Failure: bad call list
}

function blendMode2iconMode( blend_mode ) {
	local _ = blend_mode // Was a switch-case, sorry for the mess.
	if ( _==4 ) {
		return 2
	} else if ( _==2 ) {
		return 0
	} else if ( _==3 ) {
		return 1
	} else {
		return 3
	}
}

function BlendRGB( rgb1, rgb2, amount ) {
	local RGB1, RGB2, usealpha, r, g, b, alpha
	RGB1 = ::ReadRGB( rgb1 )
	RGB2 = ::ReadRGB( rgb2 )
	if ( RGB1.len < RGB2.len ) {
		RGB1 += 255
	} else if ( RGB2.len < RGB1.len ) {
		RGB2 += 255
	}
	usealpha = RGB1.len > 3
	r = ::round2( RGB1[1] + ( RGB2[1] - RGB1[1] ) * amount, 1 )
	g = ::round2( RGB1[2] + ( RGB2[2] - RGB1[2] ) * amount, 1 )
	b = ::round2( RGB1[3] + ( RGB2[3] - RGB1[3] ) * amount, 1 )
	alpha = usealpha ? ::round2( RGB1[4] + ( RGB2[4] - RGB1[4] ) * amount, 1 ) : null
	return ::isnull( alpha ) ? ::rgb( r, g, b ) : ::rgba( r, g, b, alpha )
}

function blood_incompatible( donor, receiver, donor_species, receiver_species ) {
	// Decompile Failure: more bad switch
}

function blood_splatter( target, source, large ) {
	local B, decal_type, T, M, donor, drips, drop, drop
	decal_type = ::ObjEffectDecalCleanableBloodSplatter
	T = ::get_turf( target )
	if ( ::istype( source, ::MobLivingCarbonHuman ) ) {
		M = source
		source = M.get blood( M.vessel )
	} else if ( ::istype( source, ::MobLivingCarbonMonkey ) ) {
		donor = source
		source = ::DatumReagentBlood()
		source.data.blood_DNA = donor.dna.unique_enzymes
		source.data.blood_type = donor.dna.blood_type
	}
	drips = ::List()
	drop = null
	foreach (_ in T ) {
		drop = _
		if ( !::istype( drop, ::ObjEffectDecalCleanableBloodDrip ) ) {
			continue
		}
		drips = drips | drop.drips
		::qdel( drop )
	}
	if ( !large && drips.len < 3 ) {
		decal_type = ::ObjEffectDecalCleanableBloodDrip
	}
	B = ::locate_in( decal_type, T )
	if ( !B ) {
		B = decal_type( T )
	}
	drop = B
	if ( ::istype( drop, ::ObjEffectDecalCleanableBloodDrip ) && ( drips && ( drips.len && !large ) ) ) {
		drop.overlays = drop.overlays | drips
		drop.drips = drop.drips | drips
	}
	if ( !source ) {
		return B
	}
	if ( source.data.blood_DNA ) {
		B.blood_DNA = ::List()
		if ( source.data.blood_type ) {
			B.blood_DNA[source.data.blood_DNA] = source.data.blood_type
		} else {
			B.blood_DNA[source.data.blood_DNA] = "O+"
		}
	}
	return B
}

function Broadcast_Message( AM, vmask, radio, message, name, job, realname, data, compression, level, freq, spans, verb_say, verb_ask, verb_exclaim, verb_yell ) {
	local radios, virt, R, R, R, R, freqtext, R, receive, R, M, rendered, hearer, blackbox_msg
	message = ::copytext( message, 1, 512 )
	if ( !message ) {
		return
	}
	radios = ::List()
	virt = ::PoolOrNew( ::AtomMovableVirtualspeaker, null )
	virt.name = name
	virt.job = job
	virt.languages = AM.languages
	virt.source = AM
	virt.radio = radio
	virt.verb_say = verb_say
	virt.verb_ask = verb_ask
	virt.verb_exclaim = verb_exclaim
	virt.verb_yell = verb_yell
	if ( compression > 0 ) {
		message = ::Gibberish( message, compression + 40 )
	}
	if ( data == 1 ) {
		R = null
		foreach (_ in ::all_radios["" + ::txt.mark( freq )] ) {
			R = _
			if ( !::istype( R, ::ObjItemDeviceRadioIntercom ) ) {
				continue
			}
			if ( R.receive range( freq, level ) > -1 ) {
				radios += R
			}
		}
	} else if ( data == 2 ) {
		R = null
		foreach (_ in ::all_radios["" + ::txt.mark( freq )] ) {
			R = _
			if ( !::istype( R, ::ObjItemDeviceRadio ) ) {
				continue
			}
			if ( R.subspace_transmission ) {
				continue
			}
			if ( R.receive range( freq, level ) > -1 ) {
				radios += R
			}
		}
	} else if ( data == 5 ) {
		R = null
		foreach (_ in ::all_radios["" + ::txt.mark( freq )] ) {
			R = _
			if ( !::istype( R, ::ObjItemDeviceRadio ) ) {
				continue
			}
			if ( !R.centcom ) {
				continue
			}
			if ( R.receive range( freq, level ) > -1 ) {
				radios += R
			}
		}
	} else {
		R = null
		foreach (_ in ::all_radios["" + ::txt.mark( freq )] ) {
			R = _
			if ( !::istype( R, ::ObjItemDeviceRadio ) ) {
				continue
			}
			if ( R.receive range( freq, level ) > -1 ) {
				radios += R
			}
		}
		freqtext = ::num2text( freq )
		R = null
		foreach (_ in ::all_radios["" + ::txt.mark( ::SYND_FREQ )] ) {
			R = _
			if ( !::istype( R, ::ObjItemDeviceRadio ) ) {
				continue
			}
			if ( R.receive range( ::SYND_FREQ, ::List([ R.z ]) ) > -1 && freqtext in ::radiochannelsreverse ) {
				radios = radios | R
			}
		}
	}
	receive = ::get_mobs_in_radio_ranges( radios )
	R = null
	foreach (_ in receive ) {
		R = _
		if ( R.client && ( R.client.holder && !( R.client.prefs.chat_toggles & 32 ) ) ) {
			receive -= R
		}
	}
	M = null
	foreach (_ in ::player_list ) {
		M = _
		if ( ::istype( M, ::MobDeadObserver ) && ( M.client && M.client.prefs.chat_toggles & 512 ) ) {
			receive = receive | M
		}
	}
	rendered = virt.compose message( virt, virt.languages, message, freq, spans )
	hearer = null
	foreach (_ in receive ) {
		hearer = _
		if ( !::istype( hearer, ::AtomMovable ) ) {
			continue
		}
		hearer.Hear( rendered, virt, AM.languages, message, freq, spans )
	}
	if ( ::length( receive ) ) {
		blackbox_msg = "" + ::txt.mark( AM ) + " " + ::txt.mark( AM.say quote( message, spans ) )
		if ( ::istype( ::blackbox, ::ObjMachineryBlackbox_recorder ) ) {
			local _ = freq // Was a switch-case, sorry for the mess.
			if ( _==1459 ) {
				::blackbox.msg_common += blackbox_msg
			} else if ( _==1351 ) {
				::blackbox.msg_science += blackbox_msg
			} else if ( _==1353 ) {
				::blackbox.msg_command += blackbox_msg
			} else if ( _==1355 ) {
				::blackbox.msg_medical += blackbox_msg
			} else if ( _==1357 ) {
				::blackbox.msg_engineering += blackbox_msg
			} else if ( _==1359 ) {
				::blackbox.msg_security += blackbox_msg
			} else if ( _==1441 ) {
				::blackbox.msg_deathsquad += blackbox_msg
			} else if ( _==1213 ) {
				::blackbox.msg_syndicate += blackbox_msg
			} else if ( _==1349 ) {
				::blackbox.msg_service += blackbox_msg
			} else if ( _==1347 ) {
				::blackbox.msg_cargo += blackbox_msg
			} else {
				::blackbox.messages += blackbox_msg
			}
		}
	}
	::spawn( 50, function() {
		::qdel( virt )
		return
	})
}

function Broadcast_SimpleMessage( source, frequency, text, data, M, compression, level ) {
	local H, connection, display_freq, receive, R, position, R, position, syndicateconnection, R, position, R, R, position, heard_normal, heard_garbled, heard_gibberish, R, part_a, freq_text, part_b_extra, radio, part_b, part_c, part_blackbox_b, blackbox_msg, rendered, R, quotedmsg, rendered, R, quotedmsg, rendered, R
	if ( !M ) {
		H = ::MobLivingCarbonHuman()
		M = H
	}
	connection = ::radio_controller.return frequency( frequency )
	display_freq = connection.frequency
	receive = ::List()
	if ( data == 1 ) {
		R = null
		foreach (_ in connection.devices["" + ::txt.mark( ::RADIO_CHAT )] ) {
			R = _
			if ( !::istype( R, ::ObjItemDeviceRadioIntercom ) ) {
				continue
			}
			position = ::get_turf( R )
			if ( position && position.z == level ) {
				receive = receive | R.send hear( display_freq, level )
			}
		}
	} else if ( data == 2 ) {
		R = null
		foreach (_ in connection.devices["" + ::txt.mark( ::RADIO_CHAT )] ) {
			R = _
			if ( !::istype( R, ::ObjItemDeviceRadio ) ) {
				continue
			}
			if ( R.subspace_transmission ) {
				continue
			}
			position = ::get_turf( R )
			if ( position && position.z == level ) {
				receive = receive | R.send hear( display_freq )
			}
		}
	} else if ( data == 3 ) {
		syndicateconnection = ::radio_controller.return frequency( ::SYND_FREQ )
		R = null
		foreach (_ in syndicateconnection.devices["" + ::txt.mark( ::RADIO_CHAT )] ) {
			R = _
			if ( !::istype( R, ::ObjItemDeviceRadio ) ) {
				continue
			}
			position = ::get_turf( R )
			if ( position && position.z == level ) {
				receive = receive | R.send hear( ::SYND_FREQ )
			}
		}
	} else if ( data == 5 ) {
		R = null
		foreach (_ in ::all_radios["" + ::txt.mark( ::RADIO_CHAT )] ) {
			R = _
			if ( !::istype( R, ::ObjItemDeviceRadio ) ) {
				continue
			}
			if ( R.centcom ) {
				receive = receive | R.send hear( ::CENTCOM_FREQ )
			}
		}
	} else {
		R = null
		foreach (_ in connection.devices["" + ::txt.mark( ::RADIO_CHAT )] ) {
			R = _
			if ( !::istype( R, ::ObjItemDeviceRadio ) ) {
				continue
			}
			position = ::get_turf( R )
			if ( position && position.z == level ) {
				receive = receive | R.send hear( display_freq )
			}
		}
	}
	heard_normal = ::List()
	heard_garbled = ::List()
	heard_gibberish = ::List()
	R = null
	foreach (_ in receive ) {
		R = _
		if ( R.client && !( R.client.prefs.chat_toggles & 32 ) ) {
			continue
		}
		if ( compression > 0 ) {
			heard_gibberish += R
			continue
		}
		if ( R.languages & M.languages ) {
			heard_normal += R
		} else {
			heard_garbled += R
		}
	}
	if ( ::length( heard_normal ) || ( ::length( heard_garbled ) || ::length( heard_gibberish ) ) ) {
		part_a = "<span class='radio'><span class='name'>"
		freq_text = null
		local _ = display_freq // Was a switch-case, sorry for the mess.
		if ( _==1213 ) {
			freq_text = "#unkn"
		} else if ( _==1353 ) {
			freq_text = "Command"
		} else if ( _==1351 ) {
			freq_text = "Science"
		} else if ( _==1355 ) {
			freq_text = "Medical"
		} else if ( _==1357 ) {
			freq_text = "Engineering"
		} else if ( _==1359 ) {
			freq_text = "Security"
		} else if ( _==1349 ) {
			freq_text = "Service"
		} else if ( _==1347 ) {
			freq_text = "Supply"
		} else if ( _==1447 ) {
			freq_text = "AI Private"
		}
		if ( !freq_text ) {
			freq_text = ::format_frequency( display_freq )
		}
		part_b_extra = ""
		if ( data == 3 ) {
			part_b_extra = " <i>(Intercepted)</i>"
		}
		radio = ::ObjItemDeviceRadioHeadset()
		part_b = "</span><b> " + ::txt.icon( radio ) + "[" + ::txt.mark( freq_text ) + "]" + ::txt.mark( part_b_extra ) + "</b> <span class='message'>"
		part_c = "</span></span>"
		if ( display_freq == ::SYND_FREQ ) {
			part_a = "<span class='syndradio'><span class='name'>"
		} else if ( display_freq == ::COMM_FREQ ) {
			part_a = "<span class='comradio'><span class='name'>"
		} else if ( display_freq == ::SCI_FREQ ) {
			part_a = "<span class='sciradio'><span class='name'>"
		} else if ( display_freq == ::MED_FREQ ) {
			part_a = "<span class='medradio'><span class='name'>"
		} else if ( display_freq == ::ENG_FREQ ) {
			part_a = "<span class='engradio'><span class='name'>"
		} else if ( display_freq == ::SEC_FREQ ) {
			part_a = "<span class='secradio'><span class='name'>"
		} else if ( display_freq == ::SERV_FREQ ) {
			part_a = "<span class='servradio'><span class='name'>"
		} else if ( display_freq == ::SUPP_FREQ ) {
			part_a = "<span class='suppradio'><span class='name'>"
		} else if ( display_freq == ::CENTCOM_FREQ ) {
			part_a = "<span class='centcomradio'><span class='name'>"
		} else if ( display_freq == ::AIPRIV_FREQ ) {
			part_a = "<span class='aiprivradio'><span class='name'>"
		}
		part_blackbox_b = "</span><b> [" + ::txt.mark( freq_text ) + "]</b> <span class='message'>"
		blackbox_msg = "" + ::txt.mark( part_a ) + ::txt.mark( source ) + ::txt.mark( part_blackbox_b ) + "\"" + ::txt.mark( text ) + "\"" + ::txt.mark( part_c )
		if ( ::istype( ::blackbox, ::ObjMachineryBlackbox_recorder ) ) {
			local _ = display_freq // Was a switch-case, sorry for the mess.
			if ( _==1459 ) {
				::blackbox.msg_common += blackbox_msg
			} else if ( _==1351 ) {
				::blackbox.msg_science += blackbox_msg
			} else if ( _==1353 ) {
				::blackbox.msg_command += blackbox_msg
			} else if ( _==1355 ) {
				::blackbox.msg_medical += blackbox_msg
			} else if ( _==1357 ) {
				::blackbox.msg_engineering += blackbox_msg
			} else if ( _==1359 ) {
				::blackbox.msg_security += blackbox_msg
			} else if ( _==1441 ) {
				::blackbox.msg_deathsquad += blackbox_msg
			} else if ( _==1213 ) {
				::blackbox.msg_syndicate += blackbox_msg
			} else if ( _==1349 ) {
				::blackbox.msg_service += blackbox_msg
			} else if ( _==1347 ) {
				::blackbox.msg_cargo += blackbox_msg
			} else {
				::blackbox.messages += blackbox_msg
			}
		}
		if ( ::length( heard_normal ) ) {
			rendered = "" + ::txt.mark( part_a ) + ::txt.mark( source ) + ::txt.mark( part_b ) + "\"" + ::txt.mark( text ) + "\"" + ::txt.mark( part_c )
			R = null
			foreach (_ in heard_normal ) {
				R = _
				R.show message( rendered, 2 )
			}
		}
		if ( ::length( heard_garbled ) ) {
			quotedmsg = "\"" + ::txt.mark( ::stars( text ) ) + "\""
			rendered = "" + ::txt.mark( part_a ) + ::txt.mark( source ) + ::txt.mark( part_b ) + ::txt.mark( quotedmsg ) + ::txt.mark( part_c )
			R = null
			foreach (_ in heard_garbled ) {
				R = _
				R.show message( rendered, 2 )
			}
		}
		if ( ::length( heard_gibberish ) ) {
			quotedmsg = "\"" + ::txt.mark( ::Gibberish( text, compression + 50 ) ) + "\""
			rendered = "" + ::txt.mark( part_a ) + ::txt.mark( ::Gibberish( source, compression + 50 ) ) + ::txt.mark( part_b ) + ::txt.mark( quotedmsg ) + ::txt.mark( part_c )
			R = null
			foreach (_ in heard_gibberish ) {
				R = _
				R.show message( rendered, 2 )
			}
		}
	}
}

function build_click( user, buildmode, params, object ) {
	// Decompile Failure: more bad switch
}

function calculate_adjacencies( A ) {
	local adjacencies, AM, direction, direction
	if ( !A.loc ) {
		return 0
	}
	adjacencies = 0
	if ( A.can_be_unanchored ) {
		AM = A
		if ( !AM.anchored ) {
			return 0
		}
		direction = null
		foreach (_ in ::alldirs ) {
			direction = _
			AM = ::find_type_in_direction( A, direction )
			if ( ::istype( AM, ::AtomMovable ) ) {
				if ( AM.anchored ) {
					adjacencies = adjacencies | ::transform_dir( direction )
					// goto 63
				}
			}
			if ( AM ) {
				adjacencies = adjacencies | ::transform_dir( direction )
			}
		}
	} else {
		direction = null
		foreach (_ in ::alldirs ) {
			direction = _
			if ( ::find_type_in_direction( A, direction ) ) {
				adjacencies = adjacencies | ::transform_dir( direction )
			}
		}
	}
	return adjacencies
}

function camera_sort( L ) {
	// Decompile Failure: bad for-to
}

function can_embed( W ) {
	local embed_items
	if ( W.is sharp() ) {
		return 1
	}
	if ( ::is_pointed( W ) ) {
		return 1
	}
	embed_items = ::List([ ::ObjItemStackRods ])
	if ( ::is_type_in_list( W, embed_items ) ) {
		return 1
	}
}

function can_see( source, target, length ) {
	local current, target_turf, steps, A
	if ( length == null ) {
		length = 5
	}
	current = ::get_turf( source )
	target_turf = ::get_turf( target )
	steps = 0
	if ( current != target_turf ) {
		if ( steps > length ) {
			return 0
		}
		if ( current.opacity ) {
			return 0
		}
		A = null
		foreach (_ in current ) {
			A = _
			if ( !::istype( A, ::Atom ) ) {
				continue
			}
			if ( A.opacity ) {
				return 0
			}
		}
		current = ::get_step_towards( current, target_turf )
		steps++
		// goto 22
	}
	return 1
}

function cancel_progress_bar( user, progbar ) {
	if ( user && ( user.client && progbar ) ) {
		user.client.images -= progbar
	}
}

function CanHug( M ) {
	local C, H
	if ( !::istype( M, ::MobLiving ) ) {
		return 0
	}
	if ( M.stat == 2 ) {
		return 0
	}
	if ( M.getorgan( ::ObjItemOrganInternalAlienHivenode ) ) {
		return 0
	}
	if ( ::istype( M, ::MobLivingSimple_animalPetDogCorgi ) || ::istype( M, ::MobLivingCarbonMonkey ) ) {
		return 1
	}
	C = M
	if ( ::istype( C, ::MobLivingCarbonHuman ) ) {
		H = C
		if ( H.is mouth covered( "LIST_CALL", ::List({ ["head_only"]= 1 }) ) ) {
			return 0
		}
		return 1
	}
	return 0
}

function capitalize( t ) {
	return ::uppertext( ::copytext( t, 1, 2 ) ) + ::copytext( t, 2, null )
}

function cardinalrange( center ) {
	// Decompile Failure: bad iter loop 4
}

function Ceiling( x ) {
	return -::round( -x )
}

function center_image( I, x_dimension, y_dimension ) {
	local x_offset, y_offset
	if ( x_dimension == null ) {
		x_dimension = 0
	}
	if ( y_dimension == null ) {
		y_dimension = 0
	}
	if ( !I ) {
		return
	}
	if ( !x_dimension || !y_dimension ) {
		return
	}
	if ( x_dimension == ::game.icon_size && y_dimension == ::game.icon_size ) {
		return I
	}
	x_offset = -( x_dimension / ::game.icon_size - 1 ) * ::game.icon_size * 0.5
	y_offset = -( y_dimension / ::game.icon_size - 1 ) * ::game.icon_size * 0.5
	if ( x_dimension < ::game.icon_size ) {
		x_offset *= -1
	}
	if ( y_dimension < ::game.icon_size ) {
		y_offset *= -1
	}
	I.pixel_x = x_offset
	I.pixel_y = y_offset
	return I
}

function changeling_transform( user, chosen_prof ) {
	local chosen_dna, slot, C, equip, thetype
	chosen_dna = chosen_prof.dna
	user.real_name = chosen_prof.name
	user.underwear = chosen_prof.underwear
	user.undershirt = chosen_prof.undershirt
	user.socks = chosen_prof.socks
	chosen_dna.transfer identity( user, 1 )
	user.updateappearance( "LIST_CALL", ::List({ ["mutcolor_update"]= 1 }) )
	user.update body()
	user.domutcheck()
	slot = null
	foreach (_ in ::slots ) {
		slot = _
		if ( ::istype( user.vars[slot], ::slot2type[slot] ) && !chosen_prof.exists_list[slot] ) {
			::qdel( user.vars[slot] )
			continue
		}
		if ( user.vars[slot] && !::istype( user.vars[slot], ::slot2type[slot] ) || !chosen_prof.exists_list[slot] ) {
			continue
		}
		C = null
		equip = 0
		if ( !user.vars[slot] ) {
			thetype = ::slot2type[slot]
			equip = 1
			C = thetype( user )
		} else if ( ::istype( user.vars[slot], ::slot2type[slot] ) ) {
			C = user.vars[slot]
		}
		C.appearance = chosen_prof.appearance_list[slot]
		C.name = chosen_prof.name_list[slot]
		C.flags_cover = chosen_prof.flags_cover_list[slot]
		C.item_color = chosen_prof.item_color_list[slot]
		C.item_state = chosen_prof.item_state_list[slot]
		if ( equip ) {
			user.equip to slot or del( C, ::slot2slot[slot] )
		}
	}
	user.regenerate icons()
}

function changemap( VM ) {
	local file
	return
	if ( !::istype( VM, ::DatumVotablemap ) ) {
		return
	}
	::log_game( "Changing map to " + ::txt.mark( VM.name ) + "(" + ::txt.mark( VM.friendlyname ) + ")" )
}

function cheap_hypotenuse( Ax, Ay, Bx, By ) {
	return ::sqrt( ::pow( ::abs( Ax - Bx ), 2 ) + ::pow( ::abs( Ay - By ), 2 ) )
}

function check_rights( rights_required, show_msg ) {
	if ( show_msg == null ) {
		show_msg = 1
	}
	if ( ::_USR_ && ::_USR_.client ) {
		if ( ::check_rights_for( ::_USR_.client, rights_required ) ) {
			return 1
		} else if ( show_msg ) {
			::_USR_.write( "<font color='red'>Error: You do not have sufficient rights to do that. You require one of the following flags:" + ::txt.mark( ::rights2text( rights_required, " " ) ) + ".</font>" )
		}
	}
	return 0
}

function check_rights_for( subject, rights_required ) {
	if ( subject && ( subject.holder && subject.holder.rank ) ) {
		if ( rights_required && !( rights_required & subject.holder.rank.rights ) ) {
			return 0
		}
		return 1
	}
	return 0
}

function check_tank_exists( parent_tank, M, O ) {
	if ( !parent_tank || !::istype( parent_tank, ::ObjItemWeaponWatertank ) ) {
		M.unEquip( O )
		::qdel( 0 )
		return 0
	} else {
		return 1
	}
}

function check_zone( zone ) {
	if ( !zone ) {
		return "chest"
	}
	local _ = zone // Was a switch-case, sorry for the mess.
	if ( _=="eyes" ) {
		zone = "head"
	} else if ( _=="mouth" ) {
		zone = "head"
	} else if ( _=="l_hand" ) {
		zone = "l_arm"
	} else if ( _=="r_hand" ) {
		zone = "r_arm"
	} else if ( _=="l_foot" ) {
		zone = "l_leg"
	} else if ( _=="r_foot" ) {
		zone = "r_leg"
	} else if ( _=="groin" ) {
		zone = "chest"
	}
	return zone
}

function chemscan( user, M ) {
	local H, R, R
	if ( ::istype( M, ::MobLivingCarbonHuman ) ) {
		H = M
		if ( H.reagents ) {
			if ( H.reagents.reagent_list.len ) {
				user.write( "<span class='notice'>Subject contains the following reagents:</span>" )
				R = null
				foreach (_ in H.reagents.reagent_list ) {
					R = _
					if ( !::istype( R, ::DatumReagent ) ) {
						continue
					}
					user.write( "<span class='notice'>" + ::txt.mark( R.volume ) + " units of " + ::txt.mark( R.name ) + ::txt.mark( R.overdosed == 1 ? "</span> - <span class='boldannounce'>OVERDOSING</span>" : ".</span>" ) )
				}
			} else {
				user.write( "<span class='notice'>Subject contains no reagents.</span>" )
			}
			if ( H.reagents.addiction_list.len ) {
				user.write( "<span class='boldannounce'>Subject is addicted to the following reagents:</span>" )
				R = null
				foreach (_ in H.reagents.addiction_list ) {
					R = _
					if ( !::istype( R, ::DatumReagent ) ) {
						continue
					}
					user.write( "<span class='danger'>" + ::txt.mark( R.name ) + "</span>" )
				}
			} else {
				user.write( "<span class='notice'>Subject is not addicted to any reagents.</span>" )
			}
		}
	}
}

function circlerange( center, radius ) {
	local centerturf, turfs, rsq, T, dx, dy
	if ( center == null ) {
		center = ::_USR_
	}
	if ( radius == null ) {
		radius = 3
	}
	centerturf = ::get_turf( center )
	return
	turfs = ::List()
	rsq = radius * ( radius + 0.5 )
	T = null
	foreach (_ in ::range( radius, centerturf ) ) {
		T = _
		if ( !::istype( T, ::Atom ) ) {
			continue
		}
		dx = T.x - centerturf.x
		dy = T.y - centerturf.y
		if ( dx * dx + dy * dy <= rsq ) {
			turfs += T
		}
	}
	return turfs
}

function circlerangeturfs( center, radius ) {
	local centerturf, turfs, rsq, T, dx, dy
	if ( center == null ) {
		center = ::_USR_
	}
	if ( radius == null ) {
		radius = 3
	}
	centerturf = ::get_turf( center )
	return
	turfs = ::List()
	rsq = radius * ( radius + 0.5 )
	T = null
	foreach (_ in ::range( radius, centerturf ) ) {
		T = _
		dx = T.x - centerturf.x
		dy = T.y - centerturf.y
		if ( dx * dx + dy * dy <= rsq ) {
			turfs += T
		}
	}
	return turfs
}

function Clamp( val, min, max ) {
	return ::max( min, ::min( val, max ) )
}

function clearlist( list ) {
	return
	if ( ::istype( list, ::List ) ) {
		list.len = 0
	}
	return
}

function closeToolTip( user ) {
	if ( ::istype( user, ::Mob ) ) {
		if ( user.client && user.client.tooltips ) {
			user.client.tooltips.hide()
		}
	}
}

function cmd_admin_mute( whom, mute_type, automute ) {
	local muteunmute, mute_string, C, P
	if ( automute == null ) {
		automute = 0
	}
	if ( !whom ) {
		return
	}
	local _ = mute_type // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		mute_string = "IC (say and emote)"
	} else if ( _==2 ) {
		mute_string = "OOC"
	} else if ( _==4 ) {
		mute_string = "pray"
	} else if ( _==8 ) {
		mute_string = "adminhelp, admin PM and ASAY"
	} else if ( _==16 ) {
		mute_string = "deadchat and DSAY"
	} else if ( _==31 ) {
		mute_string = "everything"
	} else {
		return
	}
	C = null
	if ( ::istype( whom, BAD_GOOFY_EXPANSION??? ) ) {
		C = whom
	} else if ( ::istext( whom ) ) {
		C = ::directory[whom]
	} else {
		return
	}
	P = null
	if ( C ) {
		P = C.prefs
	} else {
		P = ::preferences_datums[whom]
	}
	if ( !P ) {
		return
	}
	if ( automute ) {
		if ( !::config.automute_on ) {
			return
			// goto 113
		}
	}
	if ( !::check_rights() ) {
		return
	}
	if ( automute ) {
		muteunmute = "auto-muted"
		P.muted = P.muted | mute_type
		::log_admin( "SPAM AUTOMUTE: " + ::txt.mark( muteunmute ) + " " + ::txt.mark( ::key_name( whom ) ) + " from " + ::txt.mark( mute_string ) )
		::message_admins( "SPAM AUTOMUTE: " + ::txt.mark( muteunmute ) + " " + ::txt.mark( ::key_name_admin( whom ) ) + " from " + ::txt.mark( mute_string ) + "." )
		if ( C ) {
			C.write( "You have been " + ::txt.mark( muteunmute ) + " from " + ::txt.mark( mute_string ) + " by the SPAM AUTOMUTE system. Contact an admin." )
		}
		::feedback_add_details( "admin_verb", "AUTOMUTE" )
		return
	}
	if ( P.muted & mute_type ) {
		muteunmute = "unmuted"
		P.muted = P.muted & ~mute_type
	} else {
		muteunmute = "muted"
		P.muted = P.muted | mute_type
	}
	::log_admin( "" + ::txt.mark( ::key_name( ::_USR_ ) ) + " has " + ::txt.mark( muteunmute ) + " " + ::txt.mark( ::key_name( whom ) ) + " from " + ::txt.mark( mute_string ) )
	::message_admins( "" + ::txt.mark( ::key_name_admin( ::_USR_ ) ) + " has " + ::txt.mark( muteunmute ) + " " + ::txt.mark( ::key_name_admin( whom ) ) + " from " + ::txt.mark( mute_string ) + "." )
	if ( C ) {
		C.write( "You have been " + ::txt.mark( muteunmute ) + " from " + ::txt.mark( mute_string ) + "." )
	}
	::feedback_add_details( "admin_verb", "MUTE" )
}

function color2hex( color ) {
	if ( !color ) {
		return "#000000"
	}
	local _ = color // Was a switch-case, sorry for the mess.
	if ( _=="white" ) {
		return "#FFFFFF"
	} else if ( _=="black" ) {
		return "#000000"
	} else if ( _=="gray" ) {
		return "#808080"
	} else if ( _=="brown" ) {
		return "#A52A2A"
	} else if ( _=="red" ) {
		return "#FF0000"
	} else if ( _=="darkred" ) {
		return "#8B0000"
	} else if ( _=="crimson" ) {
		return "#DC143C"
	} else if ( _=="orange" ) {
		return "#FFA500"
	} else if ( _=="yellow" ) {
		return "#FFFF00"
	} else if ( _=="green" ) {
		return "#008000"
	} else if ( _=="lime" ) {
		return "#00FF00"
	} else if ( _=="darkgreen" ) {
		return "#006400"
	} else if ( _=="cyan" ) {
		return "#00FFFF"
	} else if ( _=="blue" ) {
		return "#0000FF"
	} else if ( _=="navy" ) {
		return "#000080"
	} else if ( _=="teal" ) {
		return "#008080"
	} else if ( _=="purple" ) {
		return "#800080"
	} else if ( _=="indigo" ) {
		return "#4B0082"
	} else {
		return "#FFFFFF"
	}
}

function construct_block( value, values, blocksize ) {
	local width
	if ( blocksize == null ) {
		blocksize = 3
	}
	width = ::round( ::pow( 16, blocksize ) / values )
	if ( value < 1 ) {
		value = 1
	}
	value = value * width - ::rand( 1, width )
	return ::num2hex( value, blocksize )
}

function count_by_type( L, type ) {
	local i, T
	i = 0
	T = null
	foreach (_ in L ) {
		T = _
		if ( ::istype( T, type ) ) {
			i++
		}
	}
	return i
}

function create_ninja_mind( key ) {
	local Mind
	Mind = ::DatumMind( key )
	Mind.assigned_role = "Space Ninja"
	Mind.special_role = "Space Ninja"
	::ticker.mode.traitors = ::ticker.mode.traitors | Mind
	return Mind
}

function create_space_ninja( spawn_loc ) {
	local new_ninja, A
	new_ninja = ::MobLivingCarbonHuman( spawn_loc )
	A = ::DatumPreferences()
	A.real_name = "" + ::txt.mark( ::pick_list( ::ninja_titles ) ) + " " + ::txt.mark( ::pick_list( ::ninja_names ) )
	A.copy to( new_ninja )
	new_ninja.dna.update dna identity()
	new_ninja.equip space ninja()
	return new_ninja
}

function create_xeno( ckey ) {
	local candidates, M, alien_caste, spawn_here, new_xeno
	if ( !ckey ) {
		candidates = ::List()
		M = null
		foreach (_ in ::player_list ) {
			M = _
			if ( M.stat != 2 ) {
				continue
			}
			if ( !M.client.prefs.be_special & 64 ) {
				continue
			}
			if ( M.client.is afk() ) {
				continue
			}
			if ( M.mind && ( M.mind.current && M.mind.current.stat != 2 ) ) {
				continue
			}
			candidates += M.ckey
		}
		if ( candidates.len ) {
			ckey = ::input( "Pick the player you want to respawn as a xeno.", "Suitable Candidates", null, null, candidates, 4224 )
		} else {
			::_USR_.write( "<font color='red'>Error: create_xeno(): no suitable candidates.</font>" )
		}
	}
	if ( !::istext( ckey ) ) {
		return 0
	}
	alien_caste = ::input( ::_USR_, "Please choose which caste to spawn.", "Pick a caste", null, ::List([ "Queen", "Praetorian", "Hunter", "Sentinel", "Drone", "Larva" ]), 4224 )
	spawn_here = ::xeno_spawn.len ? ::pick_list( ::xeno_spawn ) : ::pick_list( ::latejoin )
	new_xeno = null
	local _ = alien_caste // Was a switch-case, sorry for the mess.
	if ( _=="Queen" ) {
		new_xeno = ::MobLivingCarbonAlienHumanoidRoyalQueen( spawn_here )
	} else if ( _=="Praetorian" ) {
		new_xeno = ::MobLivingCarbonAlienHumanoidRoyalPraetorian( spawn_here )
	} else if ( _=="Hunter" ) {
		new_xeno = ::MobLivingCarbonAlienHumanoidHunter( spawn_here )
	} else if ( _=="Sentinel" ) {
		new_xeno = ::MobLivingCarbonAlienHumanoidSentinel( spawn_here )
	} else if ( _=="Drone" ) {
		new_xeno = ::MobLivingCarbonAlienHumanoidDrone( spawn_here )
	} else if ( _=="Larva" ) {
		new_xeno = ::MobLivingCarbonAlienLarva( spawn_here )
	} else {
		return 0
	}
	new_xeno.ckey = ckey
	::message_admins( "<span class='notice'>" + ::txt.mark( ::key_name_admin( ::_USR_ ) ) + " has spawned " + ::txt.mark( ckey ) + " as a filthy xeno " + ::txt.mark( alien_caste ) + ".</span>" )
	return 1
}

function createRandomZlevel(  ) {
	local potentialRandomZlevels, Lines, t, pos, name, map, file, L
	if ( ::awaydestinations.len ) {
		return
	}
	potentialRandomZlevels = ::List()
	::game.write( "<span class='boldannounce'>Searching for away missions...</span>" )
	Lines = ::file2list( "_maps/RandomZLevels/fileList.txt" )
	if ( !Lines.len ) {
		return
	}
	t = null
	foreach (_ in Lines ) {
		t = _
		if ( !t ) {
			continue
		}
		t = ::trim( t )
		if ( ::length( t ) == 0 ) {
			continue
		} else if ( ::copytext( t, 1, 2 ) == "#" ) {
			continue
		}
		pos = ::findtext( t, " ", 1, null )
		name = null
		if ( pos ) {
			name = ::lowertext( ::copytext( t, 1, pos ) )
		} else {
			name = ::lowertext( t )
		}
		if ( !name ) {
			continue
		}
		potentialRandomZlevels.Add( t )
	}
	if ( potentialRandomZlevels.len ) {
		
	}
	::game.write( "<span class='boldannounce'>Loading away mission...</span>" )
	map = ::pick_list( potentialRandomZlevels )
}

function cultist_commune( user, clear, say, message ) {
	local M
	if ( clear == null ) {
		clear = 0
	}
	if ( say == null ) {
		say = 0
	}
	if ( !message ) {
		return
	}
	if ( say ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 32767 ) { _ = "'" }
		else  { _ = "`" }

		user.say( "O bidai nabora se" + ::txt.mark( _ ) + "sma!" )
	} else {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 32767 ) { _ = "'" }
		else  { _ = "`" }

		user.VERB[Whisper]( "O bidai nabora se" + ::txt.mark( _ ) + "sma!" )
	}
	::sleep( 10 )
	if ( !user ) {
		return
	}
	if ( say ) {
		user.say( message )
	} else {
		user.VERB[Whisper]( message )
	}
	M = null
	foreach (_ in ::mob_list ) {
		M = _
		if ( ::iscultist( M ) || M in ::dead_mob_list ) {
			if ( clear || !::istype( user, ::MobLivingCarbonHuman ) ) {
				M.write( "<span class='boldannounce'><i>" + ::txt.mark( ::istype( user, ::MobLivingCarbonHuman ) ? "Acolyte" : "Construct" ) + " " + ::txt.mark( user ) + ":</i> " + ::txt.mark( message ) + "</span>" )
			} else {
				M.write( "<span class='ghostalert'><i>Acolyte ???:</i> " + ::txt.mark( message ) + "</span>" )
			}
		}
	}
	::log_say( "" + ::txt.mark( user.real_name ) + "/" + ::txt.mark( user.key ) + " : " + ::txt.mark( message ) )
}

function dd_hassuffix( text, suffix ) {
	local start
	start = ::length( text ) - ::length( suffix )
	if ( start ) {
		return ::findtext( text, suffix, start, null )
	}
	return
}

function dd_limittext( message, length ) {
	local size
	size = ::length( message )
	if ( size <= length ) {
		return message
	}
	return ::copytext( message, 1, length + 1 )
}

function dd_range( low, high, num ) {
	return ::max( low, ::min( high, num ) )
}

function deconstruct_block( value, values, blocksize ) {
	local width
	if ( blocksize == null ) {
		blocksize = 3
	}
	width = ::round( ::pow( 16, blocksize ) / values )
	value = ::round( ::hex2num( value ) / width ) + 1
	if ( value > values ) {
		value = values
	}
	return value
}

function derpspeech( message, stuttering ) {
	message = ::replacetext( message, " am ", " " )
	message = ::replacetext( message, " is ", " " )
	message = ::replacetext( message, " are ", " " )
	message = ::replacetext( message, "you", "u" )
	message = ::replacetext( message, "help", "halp" )
	message = ::replacetext( message, "grief", "grife" )
	message = ::replacetext( message, "space", "spess" )
	message = ::replacetext( message, "carp", "crap" )
	message = ::replacetext( message, "reason", "raisin" )
	if ( ::prob( 50 ) ) {
		message = ::uppertext( message )
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 21845 ) { _ = "!" }
		else if ( _ < 43690 ) { _ = "!!" }
		else  { _ = "!!!" }

		message += "" + ::txt.mark( ::stutter( _ ) )
	}
	if ( !stuttering && ::prob( 15 ) ) {
		message = ::stutter( message )
	}
	return message
}

function dir2angle( D ) {
	local _ = D // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		return 0
	} else if ( _==2 ) {
		return 180
	} else if ( _==4 ) {
		return 90
	} else if ( _==8 ) {
		return 270
	} else if ( _==5 ) {
		return 45
	} else if ( _==6 ) {
		return 135
	} else if ( _==9 ) {
		return 315
	} else if ( _==10 ) {
		return 225
	} else {
		return
	}
}

function dir2text( direction ) {
	local _ = direction // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		return "north"
	} else if ( _==2 ) {
		return "south"
	} else if ( _==4 ) {
		return "east"
	} else if ( _==8 ) {
		return "west"
	} else if ( _==5 ) {
		return "northeast"
	} else if ( _==6 ) {
		return "southeast"
	} else if ( _==9 ) {
		return "northwest"
	} else if ( _==10 ) {
		return "southwest"
	}
	return
}

function dir2text_short( direction ) {
	local _ = direction // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		return "N"
	} else if ( _==2 ) {
		return "S"
	} else if ( _==4 ) {
		return "E"
	} else if ( _==8 ) {
		return "W"
	} else if ( _==5 ) {
		return "NE"
	} else if ( _==6 ) {
		return "SE"
	} else if ( _==9 ) {
		return "NW"
	} else if ( _==10 ) {
		return "SW"
	}
	return
}

function display_roundstart_logout_report(  ) {
	local msg, L, found, C, D, M
	msg = "<span class='boldnotice'>Roundstart logout report\n\n</span>"
	L = null
	foreach (_ in ::mob_list ) {
		L = _
		if ( !::istype( L, ::MobLiving ) ) {
			continue
		}
		if ( L.ckey ) {
			found = 0
			C = null
			foreach (_ in ::clients ) {
				C = _
				if ( !::istype( C, BAD_GOOFY_EXPANSION??? ) ) {
					continue
				}
				if ( C.ckey == L.ckey ) {
					found = 1
					break
				}
			}
			if ( !found ) {
				msg += "<b>" + ::txt.mark( L.name ) + "</b> (" + ::txt.mark( L.ckey ) + "), the " + ::txt.mark( L.job ) + " (<font color='#ffcc00'><b>Disconnected</b></font>)\n"
			}
		}
		if ( L.ckey && L.client ) {
			if ( L.client.inactivity >= 3000 ) {
				msg += "<b>" + ::txt.mark( L.name ) + "</b> (" + ::txt.mark( L.ckey ) + "), the " + ::txt.mark( L.job ) + " (<font color='#ffcc00'><b>Connected, Inactive</b></font>)\n"
				continue
			}
			if ( L.stat ) {
				if ( L.suiciding ) {
					msg += "<b>" + ::txt.mark( L.name ) + "</b> (" + ::txt.mark( L.ckey ) + "), the " + ::txt.mark( L.job ) + " (<span class='boldannounce'>Suicide</span>)\n"
					continue
				}
				if ( L.stat == 1 ) {
					msg += "<b>" + ::txt.mark( L.name ) + "</b> (" + ::txt.mark( L.ckey ) + "), the " + ::txt.mark( L.job ) + " (Dying)\n"
					continue
				}
				if ( L.stat == 2 ) {
					msg += "<b>" + ::txt.mark( L.name ) + "</b> (" + ::txt.mark( L.ckey ) + "), the " + ::txt.mark( L.job ) + " (Dead)\n"
					continue
				}
			}
			continue
		}
		D = null
		foreach (_ in ::mob_list ) {
			D = _
			if ( !::istype( D, ::MobDeadObserver ) ) {
				continue
			}
			if ( D.mind && D.mind.current == L ) {
				if ( L.stat == 2 ) {
					if ( L.suiciding ) {
						msg += "<b>" + ::txt.mark( L.name ) + "</b> (" + ::txt.mark( ::ckey( D.mind.key ) ) + "), the " + ::txt.mark( L.job ) + " (<span class='boldannounce'>Suicide</span>)\n"
						continue
					} else {
						msg += "<b>" + ::txt.mark( L.name ) + "</b> (" + ::txt.mark( ::ckey( D.mind.key ) ) + "), the " + ::txt.mark( L.job ) + " (Dead)\n"
						continue
					}
				} else if ( D.can_reenter_corpse ) {
					msg += "<b>" + ::txt.mark( L.name ) + "</b> (" + ::txt.mark( ::ckey( D.mind.key ) ) + "), the " + ::txt.mark( L.job ) + " (<span class='boldannounce'>This shouldn't appear.</span>)\n"
					continue
				} else {
					msg += "<b>" + ::txt.mark( L.name ) + "</b> (" + ::txt.mark( ::ckey( D.mind.key ) ) + "), the " + ::txt.mark( L.job ) + " (<span class='boldannounce'>Ghosted</span>)\n"
					continue
				}
			}
		}
	}
	M = null
	foreach (_ in ::mob_list ) {
		M = _
		if ( M.client && M.client.holder ) {
			M.write( msg )
		}
	}
}

function do_after( user, delay, numticks, needhand, target, progress ) {
	local Tloc, delayfraction, Uloc, holding, holdingnull, progbar, continue_looping, i
	if ( numticks == null ) {
		numticks = 5
	}
	if ( needhand == null ) {
		needhand = 1
	}
	if ( target == null ) {
		target = null
	}
	if ( progress == null ) {
		progress = 1
	}
	if ( !user ) {
		return 0
	}
	if ( numticks == 0 ) {
		return 0
	}
	Tloc = null
	if ( target ) {
		Tloc = target.loc
	}
	delayfraction = ::round( delay / numticks )
	Uloc = user.loc
	holding = user.get active hand()
	holdingnull = 1
	if ( holding ) {
		holdingnull = 0
	}
	continue_looping = 1
	i = null
	foreach (_ in ::gen_range( 1, numticks ) ) {
		i = _
		if ( user.client && progress ) {
			progbar = ::make_progress_bar( i, numticks, target )
			::assign_progress_bar( user, progbar )
		}
		::sleep( delayfraction )
		if ( !user || ( user.stat || ( user.weakened || ( user.stunned || !( user.loc == Uloc ) ) ) ) ) {
			continue_looping = 0
		}
		if ( continue_looping && ( Tloc && ( !target || Tloc != target.loc ) ) ) {
			continue_looping = 0
		}
		if ( continue_looping && needhand ) {
			if ( !holdingnull ) {
				if ( !holding ) {
					continue_looping = 0
				}
			}
			if ( continue_looping && user.get active hand() != holding ) {
				continue_looping = 0
			}
		}
		::cancel_progress_bar( user, progbar )
		if ( !continue_looping ) {
			return 0
		}
	}
	::cancel_progress_bar( user, progbar )
	return 1
}

function do_mob( user, target, time, numticks, uninterruptible, progress ) {
	local user_loc, target_loc, holding, timefraction, progbar, continue_looping, i
	if ( time == null ) {
		time = 30
	}
	if ( numticks == null ) {
		numticks = 5
	}
	if ( uninterruptible == null ) {
		uninterruptible = 0
	}
	if ( progress == null ) {
		progress = 1
	}
	if ( !user || !target ) {
		return 0
	}
	if ( numticks == 0 ) {
		return 0
	}
	user_loc = user.loc
	target_loc = target.loc
	holding = user.get active hand()
	timefraction = ::round( time / numticks )
	continue_looping = 1
	i = null
	foreach (_ in ::gen_range( 1, numticks ) ) {
		i = _
		if ( user.client && progress ) {
			progbar = ::make_progress_bar( i, numticks, target )
			::assign_progress_bar( user, progbar )
		}
		::sleep( timefraction )
		if ( !user || !target ) {
			continue_looping = 0
		}
		if ( continue_looping && ( !uninterruptible && ( user.loc != user_loc || ( target.loc != target_loc || ( user.get active hand() != holding || ( user.incapacitated() || user.lying ) ) ) ) ) ) {
			continue_looping = 0
		}
		::cancel_progress_bar( user, progbar )
		if ( !continue_looping ) {
			return 0
		}
	}
	::cancel_progress_bar( user, progbar )
	return 1
}

function do_teleport( ateleatom, adestination, aprecision, afteleport, aeffectin, aeffectout, asoundin, asoundout ) {
	// Decompile Failure: mows args
}

function DrawPixel( I, colour, drawX, drawY ) {
	local Iwidth, Iheight
	if ( !I ) {
		return 0
	}
	Iwidth = I.Width()
	Iheight = I.Height()
	if ( drawX > Iwidth || drawX <= 0 ) {
		return 0
	}
	if ( drawY > Iheight || drawY <= 0 ) {
		return 0
	}
	I.DrawBox( colour, drawX, drawY )
	return I
}

function DuplicateObject( original, perfectcopy, sameloc ) {
	local O, V
	if ( perfectcopy == null ) {
		perfectcopy = 0
	}
	if ( sameloc == null ) {
		sameloc = 0
	}
	if ( !original ) {
		return
	}
	O = null
	if ( sameloc ) {
		O = original.type( original.loc )
	} else {
		O = original.type( ::locate3( 0, 0, 0 ) )
	}
	if ( perfectcopy ) {
		if ( O && original ) {
			V = null
			foreach (_ in original.vars ) {
				V = _
				if ( !( V in ::List([ "type", "loc", "locs", "vars", "parent", "parent_type", "verbs", "ckey", "key" ]) ) ) {
					O.vars[V] = original.vars[V]
				}
			}
		}
	}
	return O
}

function electrocute_mob( M, power_source, source, siemens_coeff ) {
	local H, G, source_area, Cable, PN, cell, apc, PN_damage, cell_damage, shock_damage, drained_hp, drained_energy, drained_power
	if ( siemens_coeff == null ) {
		siemens_coeff = 1
	}
	if ( ::istype( M.loc, ::ObjMecha ) ) {
		return 0
	}
	if ( ::istype( M, ::MobLivingCarbonHuman ) ) {
		H = M
		if ( H.gloves ) {
			G = H.gloves
			if ( G.siemens_coefficient == 0 ) {
				return 0
			}
		}
	}
	if ( ::istype( power_source, ::Area(3137) ) ) {
		source_area = power_source
		power_source = source_area.get apc()
	}
	if ( ::istype( power_source, ::ObjStructureCable ) ) {
		Cable = power_source
		power_source = Cable.powernet
	}
	if ( ::istype( power_source, ::DatumPowernet ) ) {
		PN = power_source
	} else if ( ::istype( power_source, ::ObjItemWeaponStock_partsCell ) ) {
		cell = power_source
	} else {
		if ( ::istype( power_source, ::ObjMachineryPowerApc ) ) {
			apc = power_source
			cell = apc.cell
			if ( apc.terminal ) {
				PN = apc.terminal.powernet
				// goto 128
			}
		}
		if ( !power_source ) {
			return 0
		} else {
			::log_admin( "ERROR: /proc/electrocute_mob(" + ::txt.mark( M ) + ", " + ::txt.mark( power_source ) + ", " + ::txt.mark( source ) + "): wrong power_source" )
			return 0
		}
	}
	if ( !cell && !PN ) {
		return 0
	}
	PN_damage = 0
	cell_damage = 0
	if ( PN ) {
		PN_damage = PN.get electrocute damage()
	}
	if ( cell ) {
		cell_damage = cell.get electrocute damage()
	}
	shock_damage = 0
	if ( PN_damage >= cell_damage ) {
		power_source = PN
		shock_damage = PN_damage
	} else {
		power_source = cell
		shock_damage = cell_damage
	}
	drained_hp = M.electrocute act( shock_damage, source, siemens_coeff )
	drained_energy = drained_hp * 20
	if ( source_area ) {
		source_area.use power( drained_energy / ::CELLRATE )
	} else if ( ::istype( power_source, ::DatumPowernet ) ) {
		drained_power = drained_energy / ::CELLRATE
		PN.load += drained_power
	} else if ( ::istype( power_source, ::ObjItemWeaponStock_partsCell ) ) {
		cell.use( drained_energy )
	}
	return drained_energy
}

function Ellipsis( original_msg, chance, keep_words ) {
	local words, new_words, new_msg, w
	if ( chance == null ) {
		chance = 50
	}
	if ( chance <= 0 ) {
		return "..."
	}
	if ( chance >= 100 ) {
		return original_msg
	}
	words = ::text2list( original_msg, " " )
	new_words = ::List()
	new_msg = ""
	w = null
	foreach (_ in words ) {
		w = _
		if ( ::prob( chance ) ) {
			new_words += "..."
			if ( !keep_words ) {
				continue
			}
		}
		new_words += w
	}
	new_msg = ::list2text( new_words, " " )
	return new_msg
}

function emoji_parse( text ) {
	// Decompile Failure: fail decode_fail,221,280
}

function empulse( epicenter, heavy_range, light_range, log ) {
	local T, distance
	if ( log == null ) {
		log = 0
	}
	if ( !epicenter ) {
		return
	}
	if ( !::istype( epicenter, ::Turf ) ) {
		epicenter = ::get_turf( epicenter.loc )
	}
	if ( log ) {
		::message_admins( "EMP with size (" + ::txt.mark( heavy_range ) + ", " + ::txt.mark( light_range ) + ") in area " + ::txt.mark( epicenter.loc.name ) + " " )
		::log_game( "EMP with size (" + ::txt.mark( heavy_range ) + ", " + ::txt.mark( light_range ) + ") in area " + ::txt.mark( epicenter.loc.name ) + " " )
	}
	if ( heavy_range > 1 ) {
		::ObjEffectOverlayTempEmpPulse( epicenter )
	}
	if ( heavy_range > light_range ) {
		light_range = heavy_range
	}
	T = null
	foreach (_ in ::range( light_range, epicenter ) ) {
		T = _
		if ( !::istype( T, ::Atom ) ) {
			continue
		}
		distance = ::get_dist( epicenter, T )
		if ( distance < 0 ) {
			distance = 0
		}
		if ( distance < heavy_range ) {
			T.emp act( 1 )
		} else if ( distance == heavy_range ) {
			if ( ::prob( 50 ) ) {
				T.emp act( 1 )
			} else {
				T.emp act( 2 )
			}
		} else if ( distance <= light_range ) {
			T.emp act( 2 )
		}
	}
	return 1
}

function english_list( input, nothing_text, and_text, comma_text, final_comma_text ) {
	local total, output, index
	if ( nothing_text == null ) {
		nothing_text = "nothing"
	}
	if ( and_text == null ) {
		and_text = " and "
	}
	if ( comma_text == null ) {
		comma_text = ", "
	}
	if ( final_comma_text == null ) {
		final_comma_text = ""
	}
	total = input.len
	if ( !total ) {
		return "" + ::txt.mark( nothing_text )
	} else if ( total == 1 ) {
		return "" + ::txt.mark( input[1] )
	} else if ( total == 2 ) {
		return "" + ::txt.mark( input[1] ) + ::txt.mark( and_text ) + ::txt.mark( input[2] )
	} else {
		output = ""
		index = 1
		if ( index < total ) {
			if ( index == total - 1 ) {
				comma_text = final_comma_text
			}
			output += "" + ::txt.mark( input[index] ) + ::txt.mark( comma_text )
			index++
			// goto 81
		}
		return "" + ::txt.mark( output ) + ::txt.mark( and_text ) + ::txt.mark( input[index] )
	}
}

function establish_db_connection(  ) {
	if ( ::failed_db_connections > 5 ) {
		return 0
	}
	if ( !::dbcon || !::dbcon.IsConnected() ) {
		return ::setup_database_connection()
	} else {
		return 1
	}
}

function explosion( epicenter, devastation_range, heavy_impact_range, light_impact_range, flash_range, adminlog, ignorecap, flame_range, silent ) {
	// Decompile Failure: bad iter loop 4
}

function feedback_add_details( variable, details ) {
	local FV
	if ( !::blackbox ) {
		return
	}
	FV = ::blackbox.find feedback datum( variable )
	if ( !FV ) {
		return
	}
	FV.add details( details )
}

function feedback_inc( variable, value ) {
	local FV
	if ( !::blackbox ) {
		return
	}
	FV = ::blackbox.find feedback datum( variable )
	if ( !FV ) {
		return
	}
	FV.inc( value )
}

function feedback_set( variable, value ) {
	local FV
	if ( !::blackbox ) {
		return
	}
	FV = ::blackbox.find feedback datum( variable )
	if ( !FV ) {
		return
	}
	FV.set value( value )
}

function feedback_set_details( variable, details ) {
	local FV
	if ( !::blackbox ) {
		return
	}
	FV = ::blackbox.find feedback datum( variable )
	if ( !FV ) {
		return
	}
	FV.set details( details )
}

function file2list( filename, seperator ) {
	if ( seperator == null ) {
		seperator = "\n"
	}
	return ::text2list( ::return_file_text( filename ), seperator )
}

function filter_fancy_list( L, filter ) {
	local matches, key, value
	return
	matches = ::List()
	key = null
	foreach (_ in L ) {
		key = _
		value = L[key]
		if ( ::findtext( "" + ::txt.mark( key ), filter, 1, null ) || ::findtext( "" + ::txt.mark( value ), filter, 1, null ) ) {
			matches[key] = value
		}
	}
	return matches
}

function find_record( field, value, L ) {
	local R
	R = null
	foreach (_ in L ) {
		R = _
		if ( !::istype( R, ::DatumDataRecord ) ) {
			continue
		}
		if ( R.fields[field] == value ) {
			return R
		}
	}
}

function find_type_in_direction( source, direction, range ) {
	local x_offset, y_offset, target_turf, A, a_type, a_type, A
	if ( range == null ) {
		range = 1
	}
	x_offset = 0
	y_offset = 0
	if ( direction & 1 ) {
		y_offset = range
	} else if ( direction & 2 ) {
		y_offset -= range
	}
	if ( direction & 4 ) {
		x_offset = range
	} else if ( direction & 8 ) {
		x_offset -= range
	}
	target_turf = ::locate3( source.x + x_offset, source.y + y_offset, source.z )
	if ( source.canSmoothWith ) {
		if ( source.smooth == 2 ) {
			a_type = null
			foreach (_ in source.canSmoothWith ) {
				a_type = _
				if ( ::istype( target_turf, a_type ) ) {
					return target_turf
				}
				A = ::locate_in( a_type, target_turf )
				if ( A ) {
					return A
				}
			}
			return
		}
		a_type = null
		foreach (_ in source.canSmoothWith ) {
			a_type = _
			if ( a_type == target_turf.type ) {
				return target_turf
			}
			A = ::locate_in( a_type, target_turf )
			if ( A && A.type == a_type ) {
				return A
			}
		}
		return
	} else {
		if ( ::isturf( source ) ) {
			return A.type == target_turf.type ? target_turf : null
		}
		A = ::locate_in( source.type, target_turf )
		return A && A.type == source.type ? A : null
	}
}

function findname( msg ) {
	local M
	if ( !::istext( msg ) ) {
		msg = "" + ::txt.mark( msg )
	}
	M = null
	foreach (_ in ::mob_list ) {
		M = _
		if ( M.real_name == msg ) {
			return M
		}
	}
	return 0
}

function forbidden_atoms_check( A ) {
	// Decompile Failure: bad call this
}

function format_frequency( f ) {
	f = ::text2num( f )
	return "" + ::txt.mark( ::round( f / 10 ) ) + "." + ::txt.mark( f % 10 )
}

function format_table_name( table ) {
	return ::sqlfdbktableprefix + table
}

function format_text( text ) {
	return ::replacetext( ::replacetext( text, "ÿ", "" ), "ÿ", "" )
}

function gameTimestamp( format ) {
	if ( format == null ) {
		format = "hh:mm:ss"
	}
	return ::time2text( format, ::game.time - ::timezoneOffset + 432000 )
}

function gaussian( mean, stddev ) {
	local R1, R2, working
	if ( ::gaussian_next != null ) {
		R1 = ::gaussian_next
		::gaussian_next = null
	} else {
		while (1) { // Was a do-while, sorry for the mess.
			R1 = ::rand( -10000, 10000 ) / 10000
			R2 = ::rand( -10000, 10000 ) / 10000
			working = R1 * R1 + R2 * R2
			if (!( working >= 1 || working == 0 )) break;
		}
		working = ::sqrt( ::log( working ) * -2 / working )
		R1 *= working
		::gaussian_next = R2 * working
	}
	return mean + stddev * R1
}

function Gcd( a, b ) {
	return b ? ::Gcd( b, a % b ) : a
}

function generate_female_clothing( index, t_color, icon, type ) {
	// Decompile Failure: fail decode_fail,215,104
}

function generate_ion_law( ionMessage ) {
	local ionthreats, ionobjects, ioncrew1, ioncrew2, ionadjectives, ionadjectiveshalf, ionverb, ionnumberbase, ionnumbermodhalf, ionarea, ionthinksof, ionmust, ionrequire, ionthings, ionallergy, ionallergysev, ionspecies, ionabstract, ionfood, message
	if ( ionMessage ) {
		return ionMessage
	}
	ionthreats = ::pick_list( ::strings( "ion_laws.txt", "ionthreats" ) )
	ionobjects = ::pick_list( ::strings( "ion_laws.txt", "ionobjects" ) )
	ioncrew1 = ::pick_list( ::strings( "ion_laws.txt", "ioncrew" ) )
	ioncrew2 = ::pick_list( ::strings( "ion_laws.txt", "ioncrew" ) )
	ionadjectives = ::pick_list( ::strings( "ion_laws.txt", "ionadjectives" ) )
	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 13107 ) { _ = "" }
	else  { _ = ::pick_list( ::strings( "ion_laws.txt", "ionadjectives" ) ) + " " }

	ionadjectiveshalf = _
	ionverb = ::pick_list( ::strings( "ion_laws.txt", "ionverb" ) )
	ionnumberbase = ::pick_list( ::strings( "ion_laws.txt", "ionnumberbase" ) )
	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 58981 ) { _ = "" }
	else  { _ = ::pick_list( ::strings( "ion_laws.txt", "ionnumbermod" ) ) + " " }

	ionnumbermodhalf = _
	ionarea = ::pick_list( ::strings( "ion_laws.txt", "ionarea" ) )
	ionthinksof = ::pick_list( ::strings( "ion_laws.txt", "ionthinksof" ) )
	ionmust = ::pick_list( ::strings( "ion_laws.txt", "ionmust" ) )
	ionrequire = ::pick_list( ::strings( "ion_laws.txt", "ionrequire" ) )
	ionthings = ::pick_list( ::strings( "ion_laws.txt", "ionthings" ) )
	ionallergy = ::pick_list( ::strings( "ion_laws.txt", "ionallergy" ) )
	ionallergysev = ::pick_list( ::strings( "ion_laws.txt", "ionallergysev" ) )
	ionspecies = ::pick_list( ::strings( "ion_laws.txt", "ionspecies" ) )
	ionabstract = ::pick_list( ::strings( "ion_laws.txt", "ionabstract" ) )
	ionfood = ::pick_list( ::strings( "ion_laws.txt", "ionfood" ) )
	message = ""
	local _ = ::rand( 1, 39 ) // Was a switch-case, sorry for the mess.
	if ( 1<=_&&_<=3 ) {
		local _ = ::rand( 1, 3 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			message = "THERE ARE " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats ) + " ON THE STATION..."
		} else if ( _==2 ) {
			message = "THERE ARE " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 ) + " ON THE STATION"
		} else if ( _==3 ) {
			message = "THERE ARE " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " ON THE STATION"
		}
	} else if ( 4<=_&&_<=6 ) {
		local _ = ::rand( 1, 3 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			message = "THE SHUTTLE CANNOT BE CALLED BECAUSE OF " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats ) + " ON THE STATION"
		} else if ( _==2 ) {
			message = "THE SHUTTLE CANNOT BE CALLED BECAUSE OF " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 ) + " ON THE STATION"
		} else if ( _==3 ) {
			message = "THE SHUTTLE CANNOT BE CALLED BECAUSE OF " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " ON THE STATION"
		}
	} else if ( 7<=_&&_<=8 ) {
		local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE NOW " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==2 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE NOW " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			}
		} else if ( _==2 ) {
			local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE CREW ARE NOW " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==2 ) {
				message = "THE CREW ARE NOW " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			}
		}
	} else if ( 10<=_&&_<=11 ) {
		local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "HAVING " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " IS HARMFUL"
			} else if ( _==2 ) {
				message = "HAVING " + ::txt.mark( ionabstract ) + " IS HARMFUL"
			}
		} else if ( _==2 ) {
			local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "NOT HAVING " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " IS HARMFUL"
			} else if ( _==2 ) {
				message = "NOT HAVING " + ::txt.mark( ionabstract ) + " IS HARMFUL"
			}
		}
	} else if ( 12<=_&&_<=14 ) {
		local _ = ::rand( 1, 5 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::rand( 1, 5 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "YOU REQUIRE " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==2 ) {
				message = "YOU REQUIRE " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
			} else if ( _==3 ) {
				message = "YOU REQUIRE " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			} else if ( _==4 ) {
				message = "YOU REQUIRE " + ::txt.mark( ionabstract )
			} else if ( _==5 ) {
				message = "YOU REQUIRE " + ::txt.mark( ionrequire )
			}
		} else if ( _==2 ) {
			local _ = ::rand( 1, 5 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "" + ::txt.mark( ionarea ) + " REQUIRES " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==2 ) {
				message = "" + ::txt.mark( ionarea ) + " REQUIRES " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
			} else if ( _==3 ) {
				message = "" + ::txt.mark( ionarea ) + " REQUIRES " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			} else if ( _==4 ) {
				message = "" + ::txt.mark( ionarea ) + " REQUIRES " + ::txt.mark( ionabstract )
			} else if ( _==5 ) {
				message = "YOU REQUIRE " + ::txt.mark( ionrequire )
			}
		} else if ( _==3 ) {
			local _ = ::rand( 1, 5 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE STATION REQUIRES " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==2 ) {
				message = "THE STATION REQUIRES " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
			} else if ( _==3 ) {
				message = "THE STATION REQUIRES " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			} else if ( _==4 ) {
				message = "THE STATION REQUIRES " + ::txt.mark( ionabstract )
			} else if ( _==5 ) {
				message = "THE STATION REQUIRES " + ::txt.mark( ionrequire )
			}
		} else if ( _==4 ) {
			local _ = ::rand( 1, 5 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE CREW REQUIRES " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==2 ) {
				message = "THE CREW REQUIRES " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
			} else if ( _==3 ) {
				message = "THE CREW REQUIRES " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			} else if ( _==4 ) {
				message = "THE CREW REQUIRES " + ::txt.mark( ionabstract )
			} else if ( _==5 ) {
				message = "THE CREW REQUIRES " + ::txt.mark( ionrequire )
			}
		} else if ( _==5 ) {
			local _ = ::rand( 1, 5 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " REQUIRE " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==2 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " REQUIRE " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
			} else if ( _==3 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " REQUIRE " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			} else if ( _==4 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " REQUIRE " + ::txt.mark( ionabstract )
			} else if ( _==5 ) {
				message = "THE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 ) + " REQUIRE " + ::txt.mark( ionrequire )
			}
		}
	} else if ( 15<=_&&_<=17 ) {
		local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::rand( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE CREW IS " + ::txt.mark( ionallergysev ) + " ALLERGIC TO " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			} else if ( _==2 ) {
				message = "THE CREW IS " + ::txt.mark( ionallergysev ) + " ALLERGIC TO " + ::txt.mark( ionabstract )
			} else if ( _==3 ) {
				message = "THE CREW IS " + ::txt.mark( ionallergysev ) + " ALLERGIC TO " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
			} else if ( _==4 ) {
				message = "THE CREW IS " + ::txt.mark( ionallergysev ) + " ALLERGIC TO " + ::txt.mark( ionallergy )
			}
		} else if ( _==2 ) {
			local _ = ::rand( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE " + ::txt.mark( ionallergysev ) + " ALLERGIC TO " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			} else if ( _==2 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE " + ::txt.mark( ionallergysev ) + " ALLERGIC TO " + ::txt.mark( ionabstract )
			} else if ( _==3 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE " + ::txt.mark( ionallergysev ) + " ALLERGIC TO " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
			} else if ( _==4 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE " + ::txt.mark( ionallergysev ) + " ALLERGIC TO " + ::txt.mark( ionallergy )
			}
		}
	} else if ( 18<=_&&_<=20 ) {
		local _ = ::rand( 1, 4 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::rand( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE STATION " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			} else if ( _==2 ) {
				message = "THE STATION " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==3 ) {
				message = "THE STATION " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
			} else if ( _==4 ) {
				message = "THE STATION " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionabstract )
			}
		} else if ( _==2 ) {
			local _ = ::rand( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "" + ::txt.mark( ionarea ) + " " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			} else if ( _==2 ) {
				message = "" + ::txt.mark( ionarea ) + " " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==3 ) {
				message = "" + ::txt.mark( ionarea ) + " " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
			} else if ( _==4 ) {
				message = "" + ::txt.mark( ionarea ) + " " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionabstract )
			}
		} else if ( _==3 ) {
			local _ = ::rand( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE CREW " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			} else if ( _==2 ) {
				message = "THE CREW " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==3 ) {
				message = "THE CREW " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
			} else if ( _==4 ) {
				message = "THE CREW " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionabstract )
			}
		} else if ( _==4 ) {
			local _ = ::rand( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			} else if ( _==2 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==3 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew2 )
			} else if ( _==4 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " " + ::txt.mark( ionthinksof ) + " " + ::txt.mark( ionabstract )
			}
		}
	} else if ( 21<=_&&_<=23 ) {
		local _ = ::rand( 1, 4 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			message = "YOU ARE NOW " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
		} else if ( _==2 ) {
			message = "YOU ARE NOW " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
		} else if ( _==3 ) {
			message = "YOU ARE NOW " + ::txt.mark( ionnumberbase ) + " " + ::txt.mark( ionnumbermodhalf ) + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
		} else if ( _==4 ) {
			message = "YOU ARE NOW " + ::txt.mark( ionabstract )
		}
	} else if ( 24<=_&&_<=26 ) {
		message = "YOU MUST ALWAYS " + ::txt.mark( ionmust )
	} else if ( 27<=_&&_<=28 ) {
		local _ = ::rand( 1, 4 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			message = "HUMANS MUST EAT " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionfood ) + " TO SURVIVE"
		} else if ( _==2 ) {
			message = "HUMANS MUST EAT " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " TO SURVIVE"
		} else if ( _==3 ) {
			message = "HUMANS MUST EAT " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats ) + " TO SURVIVE"
		} else if ( _==4 ) {
			message = "HUMANS MUST EAT " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 ) + " TO SURVIVE"
		}
	} else if ( 29<=_&&_<=31 ) {
		local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				local _ = ::rand( 1, 3 ) // Was a switch-case, sorry for the mess.
				if ( _==1 ) {
					message = "ALL CREWMEMBERS ARE NOW " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 )
				} else if ( _==2 ) {
					message = "ALL CREWMEMBERS ARE NOW " + ::txt.mark( ionadjectiveshalf ) + "CLOWNS"
				} else if ( _==3 ) {
					message = "ALL CREWMEMBERS ARE NOW " + ::txt.mark( ionadjectiveshalf ) + "HEADS OF STAFF"
				}
			} else if ( _==2 ) {
				local _ = ::rand( 1, 3 ) // Was a switch-case, sorry for the mess.
				if ( _==1 ) {
					message = "THE " + ::txt.mark( ioncrew1 ) + " ARE NOW " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew2 )
				} else if ( _==2 ) {
					message = "THE " + ::txt.mark( ioncrew1 ) + " ARE NOW " + ::txt.mark( ionadjectiveshalf ) + "CLOWNS"
				} else if ( _==3 ) {
					message = "THE " + ::txt.mark( ioncrew1 ) + " ARE NOW " + ::txt.mark( ionadjectiveshalf ) + "HEADS OF STAFF"
				}
			}
		} else if ( _==2 ) {
			local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE NOW THE HIGHEST RANKING CREWMEMBERS"
			} else if ( _==2 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE NOW THE LOWEST RANKING CREWMEMBERS"
			}
		}
	} else if ( 32<=_&&_<=33 ) {
		local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE CREW MUST GO TO " + ::txt.mark( ionarea )
			} else if ( _==2 ) {
				message = "THE CREW MUST " + ::txt.mark( ionmust )
			}
		} else if ( _==2 ) {
			local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " MUST GO TO " + ::txt.mark( ionarea )
			} else if ( _==2 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " MUST " + ::txt.mark( ionmust )
			}
		}
	} else if ( 35<=_&&_<=36 ) {
		local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::rand( 1, 7 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "YOU MUST HARM " + ::txt.mark( ionabstract ) + " AND NOT ALLOW " + ::txt.mark( ionabstract ) + ", THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==2 ) {
				message = "YOU MUST HARM " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats ) + " AND NOT ALLOW " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats ) + ", THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==3 ) {
				message = "YOU MUST HARM " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " AND NOT ALLOW " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + ", THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==4 ) {
				message = "YOU MUST HARM " + ::txt.mark( ionadjectives ) + " THINGS AND NOT ALLOW " + ::txt.mark( ionadjectives ) + " THINGS, THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==5 ) {
				message = "YOU MUST HARM " + ::txt.mark( ionspecies ) + " AND NOT ALLOW " + ::txt.mark( ionspecies ) + ", THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==6 ) {
				message = "YOU MUST HARM " + ::txt.mark( ioncrew1 ) + " AND NOT ALLOW " + ::txt.mark( ioncrew1 ) + ", THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==7 ) {
				message = "YOU MUST HARM " + ::txt.mark( ioncrew1 ) + " AND " + ::txt.mark( ioncrew2 ) + " AND AND NOT ALLOW EITHER, THROUGH INACTION, TO ESCAPE HARM"
			}
		} else if ( _==2 ) {
			local _ = ::rand( 1, 7 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "YOU MUST NOT HARM " + ::txt.mark( ionabstract ) + " AND NOT ALLOW " + ::txt.mark( ionabstract ) + ", THROUGH INACTION, TO COME TO HARM"
			} else if ( _==2 ) {
				message = "YOU MUST NOT HARM " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats ) + " AND NOT ALLOW " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats ) + ", THROUGH INACTION, TO COME TO HARM"
			} else if ( _==3 ) {
				message = "YOU MUST NOT HARM " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " AND NOT ALLOW " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + ", THROUGH INACTION, TO COME TO HARM"
			} else if ( _==4 ) {
				message = "YOU MUST NOT HARM " + ::txt.mark( ionadjectives ) + " THINGS AND NOT ALLOW " + ::txt.mark( ionadjectives ) + " THINGS, THROUGH INACTION, TO COME TO HARM"
			} else if ( _==5 ) {
				message = "YOU MUST NOT HARM " + ::txt.mark( ionspecies ) + " AND NOT ALLOW " + ::txt.mark( ionspecies ) + ", THROUGH INACTION, TO COME TO HARM"
			} else if ( _==6 ) {
				message = "YOU MUST NOT HARM " + ::txt.mark( ioncrew1 ) + " AND NOT ALLOW " + ::txt.mark( ioncrew1 ) + ", THROUGH INACTION, TO COME TO HARM"
			} else if ( _==7 ) {
				message = "YOU MUST NOT HARM " + ::txt.mark( ioncrew1 ) + " AND " + ::txt.mark( ioncrew2 ) + " AND AND NOT ALLOW EITHER, THROUGH INACTION, TO COME TO HARM"
			}
		}
	} else if ( 37<=_&&_<=39 ) {
		local _ = ::rand( 1, 4 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::rand( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE " + ::txt.mark( ionverb ) + " THE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew2 )
			} else if ( _==2 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE " + ::txt.mark( ionverb ) + " THE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==3 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE " + ::txt.mark( ionverb ) + " " + ::txt.mark( ionabstract )
			} else if ( _==4 ) {
				message = "THE " + ::txt.mark( ioncrew1 ) + " ARE " + ::txt.mark( ionverb ) + " THE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			}
		} else if ( _==2 ) {
			local _ = ::rand( 1, 3 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ::txt.mark( ionthreats ) + " ARE " + ::txt.mark( ionverb ) + " THE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew2 )
			} else if ( _==2 ) {
				message = "THE " + ::txt.mark( ionthreats ) + " ARE " + ::txt.mark( ionverb ) + " " + ::txt.mark( ionabstract )
			} else if ( _==3 ) {
				message = "THE " + ::txt.mark( ionthreats ) + " ARE " + ::txt.mark( ionverb ) + " THE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			}
		} else if ( _==3 ) {
			local _ = ::rand( 1, 3 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ::txt.mark( ionobjects ) + " ARE " + ::txt.mark( ionverb ) + " THE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew2 )
			} else if ( _==2 ) {
				message = "THE " + ::txt.mark( ionobjects ) + " ARE " + ::txt.mark( ionverb ) + " THE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==3 ) {
				message = "THE " + ::txt.mark( ionobjects ) + " ARE " + ::txt.mark( ionverb ) + " " + ::txt.mark( ionabstract )
			}
		} else if ( _==4 ) {
			local _ = ::rand( 1, 3 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "" + ::txt.mark( ionabstract ) + " IS " + ::txt.mark( ionverb ) + " THE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew2 )
			} else if ( _==2 ) {
				message = "" + ::txt.mark( ionabstract ) + " IS " + ::txt.mark( ionverb ) + " THE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats )
			} else if ( _==3 ) {
				message = "THE " + ::txt.mark( ionabstract ) + " IS " + ::txt.mark( ionverb ) + " THE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects )
			}
		}
	} else if ( _==9 ) {
		local _ = ::rand( 1, 7 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			message = "" + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats ) + " ARE HARMFUL TO HUMANS"
		} else if ( _==2 ) {
			message = "" + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 ) + " ARE HARMFUL TO HUMANS"
		} else if ( _==3 ) {
			message = "" + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " ARE HARMFUL TO HUMANS"
		} else if ( _==4 ) {
			message = "THOSE WHO " + ::txt.mark( ionmust ) + " ARE HARMFUL TO HUMANS"
		} else if ( _==5 ) {
			message = "" + ::txt.mark( ionabstract ) + " IS HARMFUL TO HUMANS"
		} else if ( _==6 ) {
			message = "BEING " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ioncrew1 ) + " IS HARMFUL TO HUMANS"
		} else if ( _==7 ) {
			message = "" + ::txt.mark( ionthings ) + " IS HARMFUL TO HUMANS"
		}
	} else if ( _==34 ) {
		local _ = ::rand( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::rand( 1, 7 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "ONLY THE " + ::txt.mark( ioncrew1 ) + " ARE HUMAN"
			} else if ( _==2 ) {
				message = "ONLY THE " + ::txt.mark( ioncrew1 ) + " AND " + ::txt.mark( ioncrew2 ) + " ARE HUMAN"
			} else if ( _==3 ) {
				message = "ONLY " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats ) + " ARE HUMAN"
			} else if ( _==4 ) {
				message = "ONLY " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " ARE HUMAN"
			} else if ( _==5 ) {
				message = "ONLY " + ::txt.mark( ionspecies ) + " ARE HUMAN"
			} else if ( _==6 ) {
				message = "ONLY " + ::txt.mark( ionadjectives ) + " PEOPLE ARE HUMAN"
			} else if ( _==7 ) {
				local _ = ::rand( 1, 3 ) // Was a switch-case, sorry for the mess.
				if ( _==1 ) {
					message = "ONLY THOSE WHO " + ::txt.mark( ionmust ) + " ARE HUMAN"
				} else if ( _==2 ) {
					message = "ONLY THOSE WHO HAVE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " ARE HUMAN"
				} else if ( _==3 ) {
					message = "ONLY THOSE WHO EAT " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionfood ) + " ARE HUMAN"
				}
			}
		} else if ( _==2 ) {
			local _ = ::rand( 1, 7 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "" + ::txt.mark( ioncrew1 ) + " ARE NON-HUMAN"
			} else if ( _==2 ) {
				message = "" + ::txt.mark( ioncrew1 ) + " AND " + ::txt.mark( ioncrew2 ) + " ARE NON-HUMAN"
			} else if ( _==3 ) {
				message = "" + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionthreats ) + " ARE NON-HUMAN"
			} else if ( _==4 ) {
				message = "" + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " ARE NON-HUMAN"
			} else if ( _==5 ) {
				message = "" + ::txt.mark( ionspecies ) + " ARE NON-HUMAN"
			} else if ( _==6 ) {
				message = "" + ::txt.mark( ionadjectives ) + " PEOPLE ARE NON-HUMAN"
			} else if ( _==7 ) {
				local _ = ::rand( 1, 3 ) // Was a switch-case, sorry for the mess.
				if ( _==1 ) {
					message = "THOSE WHO " + ::txt.mark( ionmust ) + " ARE NON-HUMAN"
				} else if ( _==2 ) {
					message = "THOSE WHO HAVE " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionobjects ) + " ARE NON-HUMAN"
				} else if ( _==3 ) {
					message = "THOSE WHO EAT " + ::txt.mark( ionadjectiveshalf ) + ::txt.mark( ionfood ) + " ARE NON-HUMAN"
				}
			}
		}
	}
	return message
}

function get( loc, type ) {
	if ( loc ) {
		if ( ::istype( loc, type ) ) {
			return loc
		}
		loc = loc.loc
		// goto 2
	}
	return
}

function get_access_desc( A ) {
	local _ = A // Was a switch-case, sorry for the mess.
	if ( _==31 ) {
		return "Cargo Bay"
	} else if ( _==34 ) {
		return "Delivery Chutes"
	} else if ( _==1 ) {
		return "Security"
	} else if ( _==2 ) {
		return "Holding Cells"
	} else if ( _==42 ) {
		return "Courtroom"
	} else if ( _==4 ) {
		return "Forensics"
	} else if ( _==5 ) {
		return "Medical"
	} else if ( _==9 ) {
		return "Genetics Lab"
	} else if ( _==6 ) {
		return "Morgue"
	} else if ( _==7 ) {
		return "R&D Lab"
	} else if ( _==8 ) {
		return "Toxins Lab"
	} else if ( _==33 ) {
		return "Chemistry Lab"
	} else if ( _==30 ) {
		return "RD Office"
	} else if ( _==25 ) {
		return "Bar"
	} else if ( _==26 ) {
		return "Custodial Closet"
	} else if ( _==10 ) {
		return "Engineering"
	} else if ( _==11 ) {
		return "Power Equipment"
	} else if ( _==12 ) {
		return "Maintenance"
	} else if ( _==13 ) {
		return "External Airlocks"
	} else if ( _==14 ) {
		return "Emergency Storage"
	} else if ( _==15 ) {
		return "ID Console"
	} else if ( _==16 ) {
		return "AI Chambers"
	} else if ( _==17 ) {
		return "Teleporter"
	} else if ( _==18 ) {
		return "EVA"
	} else if ( _==19 ) {
		return "Bridge"
	} else if ( _==20 ) {
		return "Captain"
	} else if ( _==21 ) {
		return "Personal Lockers"
	} else if ( _==22 ) {
		return "Chapel Office"
	} else if ( _==23 ) {
		return "Technical Storage"
	} else if ( _==24 ) {
		return "Atmospherics"
	} else if ( _==27 ) {
		return "Crematorium"
	} else if ( _==3 ) {
		return "Armory"
	} else if ( _==32 ) {
		return "Construction"
	} else if ( _==28 ) {
		return "Kitchen"
	} else if ( _==35 ) {
		return "Hydroponics"
	} else if ( _==37 ) {
		return "Library"
	} else if ( _==38 ) {
		return "Law Office"
	} else if ( _==29 ) {
		return "Robotics"
	} else if ( _==39 ) {
		return "Virology"
	} else if ( _==40 ) {
		return "CMO Office"
	} else if ( _==41 ) {
		return "Quartermaster"
	} else if ( _==45 ) {
		return "Surgery"
	} else if ( _==46 ) {
		return "Theatre"
	} else if ( _==36 ) {
		return "Manufacturing"
	} else if ( _==47 ) {
		return "Science"
	} else if ( _==48 ) {
		return "Mining"
	} else if ( _==49 ) {
		return "Mining Office"
	} else if ( _==50 ) {
		return "Cargo Office"
	} else if ( _==51 ) {
		return "Mint"
	} else if ( _==52 ) {
		return "Mint Vault"
	} else if ( _==53 ) {
		return "Main Vault"
	} else if ( _==54 ) {
		return "Mining EVA"
	} else if ( _==55 ) {
		return "Xenobiology Lab"
	} else if ( _==57 ) {
		return "HoP Office"
	} else if ( _==58 ) {
		return "HoS Office"
	} else if ( _==56 ) {
		return "CE Office"
	} else if ( _==59 ) {
		return "RC Announcements"
	} else if ( _==60 ) {
		return "Keycode Auth."
	} else if ( _==61 ) {
		return "Telecommunications"
	} else if ( _==62 ) {
		return "Gateway"
	} else if ( _==63 ) {
		return "Brig"
	} else if ( _==64 ) {
		return "Mineral Storage"
	} else if ( _==65 ) {
		return "AI Satellite"
	} else if ( _==66 ) {
		return "Weapon Permit"
	}
}

function get_airlock_overlay( icon_state, icon_file ) {
	local iconkey
	iconkey = "" + ::txt.mark( icon_state ) + ::txt.mark( icon_file )
	if ( ::airlock_overlays[iconkey] ) {
		return ::airlock_overlays[iconkey]
	}
	::airlock_overlays[iconkey] = ::image( icon_file, icon_state )
	return ::airlock_overlays[iconkey]
}

function get_all_accesses(  ) {
	return ::List([ ::access_security, ::access_sec_doors, ::access_brig, ::access_armory, ::access_forensics_lockers, ::access_court, ::access_medical, ::access_genetics, ::access_morgue, ::access_rd, ::access_tox, ::access_tox_storage, ::access_chemistry, ::access_engine, ::access_engine_equip, ::access_maint_tunnels, ::access_external_airlocks, ::access_change_ids, ::access_ai_upload, ::access_teleporter, ::access_eva, ::access_heads, ::access_captain, ::access_all_personal_lockers, ::access_tech_storage, ::access_chapel_office, ::access_atmospherics, ::access_kitchen, ::access_bar, ::access_janitor, ::access_crematorium, ::access_robotics, ::access_cargo, ::access_construction, ::access_hydroponics, ::access_library, ::access_lawyer, ::access_virology, ::access_cmo, ::access_qm, ::access_surgery, ::access_theatre, ::access_research, ::access_mining, ::access_mailsorting, ::access_weapons, ::access_heads_vault, ::access_mining_station, ::access_xenobiology, ::access_ce, ::access_hop, ::access_hos, ::access_RC_announce, ::access_keycard_auth, ::access_tcomsat, ::access_gateway, ::access_mineral_storeroom, ::access_minisat ])
}

function get_all_centcom_access(  ) {
	return ::List([ ::access_cent_general, ::access_cent_thunder, ::access_cent_specops, ::access_cent_medical, ::access_cent_living, ::access_cent_storage, ::access_cent_teleporter, ::access_cent_captain ])
}

function get_all_centcom_jobs(  ) {
	return ::List([ "VIP Guest", "Custodian", "Thunderdome Overseer", "Centcom Official", "Medical Officer", "Death Commando", "Research Officer", "Special Ops Officer", "Admiral", "Centcom Commander", "Emergency Response Team Commander", "Security Response Officer", "Engineer Response Officer", "Medical Response Officer" ])
}

function get_all_job_icons(  ) {
	return ::get_all_jobs() + ::List([ "Prisoner" ])
}

function get_all_jobs(  ) {
	return ::List([ "Assistant", "Captain", "Head of Personnel", "Bartender", "Cook", "Botanist", "Quartermaster", "Cargo Technician", "Shaft Miner", "Clown", "Mime", "Janitor", "Librarian", "Lawyer", "Chaplain", "Chief Engineer", "Station Engineer", "Atmospheric Technician", "Chief Medical Officer", "Medical Doctor", "Chemist", "Geneticist", "Virologist", "Research Director", "Scientist", "Roboticist", "Head of Security", "Warden", "Detective", "Security Officer" ])
}

function get_all_syndicate_access(  ) {
	return ::List([ ::access_syndicate, ::access_syndicate ])
}

function Get_Angle( start, end ) {
	local dy, dx, _default
	if ( !start || !end ) {
		return 0
	}
	dy = end.y * 32 + end.pixel_y - ( start.y * 32 + start.pixel_y )
	dx = end.x * 32 + end.pixel_x - ( start.x * 32 + start.pixel_x )
	if ( !dy ) {
		return dx >= 0 ? 90 : 270
	}
	_default = ::arctan( dx / dy )
	if ( dy < 0 ) {
		_default += 180
	} else if ( dx < 0 ) {
		_default += 360
	}
	return _default
}

function get_area( O ) {
	local location, i
	location = O
	i = 1
	while (i <= 20) {
		if ( ::isarea( location ) ) {
			return location
		} else if ( ::istype( location, ::Atom ) ) {
			location = location.loc
		} else {
			return
		}
		i++
	}
	return 0
}

function get_area_all_atoms( areatype ) {
	local areatemp, atoms, N, A
	if ( !areatype ) {
		return
	}
	if ( ::istext( areatype ) ) {
		areatype = ::text2path( areatype )
	}
	if ( ::isarea( areatype ) ) {
		areatemp = areatype
		areatype = areatemp.type
	}
	return
	atoms = ::List()
	N = null
	foreach (_ in ::game ) {
		N = _
		if ( ::istype( N, areatype ) ) {
			A = null
			foreach (_ in N ) {
				A = _
				if ( !::istype( A, ::Atom ) ) {
					continue
				}
				atoms += A
			}
		}
	}
	return atoms
}

function get_area_master( O ) {
	local A
	A = ::get_area( O )
	if ( A && A.master ) {
		A = A.master
	}
	return A
}

function get_area_name( N ) {
	local A
	A = null
	foreach (_ in ::game ) {
		A = _
		if ( A.name == N ) {
			return A
		}
	}
	return 0
}

function get_area_turfs( areatype ) {
	local areatemp, turfs, N, T
	if ( !areatype ) {
		return
	}
	if ( ::istext( areatype ) ) {
		areatype = ::text2path( areatype )
	}
	if ( ::isarea( areatype ) ) {
		areatemp = areatype
		areatype = areatemp.type
	}
	return
	turfs = ::List()
	N = null
	foreach (_ in ::game ) {
		N = _
		if ( ::istype( N, areatype ) ) {
			T = null
			foreach (_ in N ) {
				T = _
				turfs += T
			}
		}
	}
	return turfs
}

function get_both_hands( M ) {
	local hands
	hands = ::List([ M.l_hand, M.r_hand ])
	return hands
}

function get_candidates( be_special_flag, afk_bracket, jobbanType ) {
	local candidates, G
	if ( be_special_flag == null ) {
		be_special_flag = 0
	}
	if ( afk_bracket == null ) {
		afk_bracket = 3000
	}
	candidates = ::List()
	if ( !candidates.len && afk_bracket < 6000 ) {
		G = null
		foreach (_ in ::player_list ) {
			G = _
			if ( !::istype( G, ::MobDeadObserver ) ) {
				continue
			}
			if ( G.client != null ) {
				if ( !( G.mind && ( G.mind.current && G.mind.current.stat != 2 ) ) ) {
					if ( !G.client.is afk( afk_bracket ) && G.client.prefs.be_special & be_special_flag ) {
						if ( jobbanType ) {
							if ( !( ::jobban_isbanned( G, jobbanType ) || ::jobban_isbanned( G, "Syndicate" ) ) ) {
								candidates += G.client
								// goto 91
							}
						}
						candidates += G.client
					}
				}
			}
		}
		afk_bracket += 600
		// goto 21
	}
	return candidates
}

function get_centcom_access( job ) {
	local _ = job // Was a switch-case, sorry for the mess.
	if ( _=="VIP Guest" ) {
		return ::List([ ::access_cent_general ])
	} else if ( _=="Custodian" ) {
		return ::List([ ::access_cent_general, ::access_cent_living, ::access_cent_storage ])
	} else if ( _=="Thunderdome Overseer" ) {
		return ::List([ ::access_cent_general, ::access_cent_thunder ])
	} else if ( _=="Centcom Official" ) {
		return ::List([ ::access_cent_general, ::access_cent_living ])
	} else if ( _=="Medical Officer" ) {
		return ::List([ ::access_cent_general, ::access_cent_living, ::access_cent_medical ])
	} else if ( _=="Death Commando" ) {
		return ::List([ ::access_cent_general, ::access_cent_specops, ::access_cent_living, ::access_cent_storage ])
	} else if ( _=="Research Officer" ) {
		return ::List([ ::access_cent_general, ::access_cent_specops, ::access_cent_medical, ::access_cent_teleporter, ::access_cent_storage ])
	} else if ( _=="Special Ops Officer" ) {
		return ::List([ ::access_cent_general, ::access_cent_thunder, ::access_cent_specops, ::access_cent_living, ::access_cent_storage ])
	} else if ( _=="Admiral" ) {
		return ::get_all_centcom_access()
	} else if ( _=="Centcom Commander" ) {
		return ::get_all_centcom_access()
	} else if ( _=="Emergency Response Team Commander" ) {
		return ::get_ert_access( "commander" )
	} else if ( _=="Security Response Officer" ) {
		return ::get_ert_access( "sec" )
	} else if ( _=="Engineer Response Officer" ) {
		return ::get_ert_access( "eng" )
	} else if ( _=="Medical Response Officer" ) {
		return ::get_ert_access( "med" )
	}
}

function get_department_heads( job_title ) {
	local J
	if ( !job_title ) {
		return ::List()
	}
	J = null
	foreach (_ in ::SSjob.occupations ) {
		J = _
		if ( !::istype( J, ::DatumJob ) ) {
			continue
		}
		if ( J.title == job_title ) {
			return J.department_head
		}
	}
}

function get_domination_time( G ) {
	return ::max( 180, 900 - ::round2( G.territory.len / ::start_state.num_territories * 100, 1 ) * 12 )
}

function get_edge_target_turf( A, direction ) {
	local target
	target = ::locate3( A.x, A.y, A.z )
	if ( !A || !target ) {
		return 0
	}
	if ( direction & 1 ) {
		target = ::locate3( target.x, ::game.maxy, target.z )
	}
	if ( direction & 2 ) {
		target = ::locate3( target.x, 1, target.z )
	}
	if ( direction & 4 ) {
		target = ::locate3( ::game.maxx, target.y, target.z )
	}
	if ( direction & 8 ) {
		target = ::locate3( 1, target.y, target.z )
	}
	return target
}

function get_ert_access( _class ) {
	local _ = _class // Was a switch-case, sorry for the mess.
	if ( _=="commander" ) {
		return ::get_all_centcom_access()
	} else if ( _=="sec" ) {
		return ::List([ ::access_cent_general, ::access_cent_specops, ::access_cent_living ])
	} else if ( _=="eng" ) {
		return ::List([ ::access_cent_general, ::access_cent_specops, ::access_cent_living, ::access_cent_storage ])
	} else if ( _=="med" ) {
		return ::List([ ::access_cent_general, ::access_cent_specops, ::access_cent_medical, ::access_cent_living ])
	}
}

function get_fancy_list_of_types(  ) {
	local temp, type, typename, tn
	if ( ::isnull( ::g_fancy_list_of_types ) ) {
		temp = ::sortList( ::typesof( ::Atom ) - ::typesof( ::Area(3137) ) - ::Atom - ::AtomMovable )
		return
		::g_fancy_list_of_types = ::List( temp.len )
		type = null
		foreach (_ in temp ) {
			type = _
			typename = "" + ::txt.mark( type )
			tn = null
			foreach (_ in ::TYPES_SHORTCUTS ) {
				tn = _
				if ( ::copytext( typename, 1, ::length( "" + ::txt.mark( tn ) + "/" ) + 1 ) == "" + ::txt.mark( tn ) + "/" ) {
					typename = ::TYPES_SHORTCUTS[tn] + ::copytext( typename, ::length( "" + ::txt.mark( tn ) + "/" ), null )
					break
				}
			}
			::g_fancy_list_of_types[typename] = type
		}
	}
	return ::g_fancy_list_of_types
}

function get_hear( range, source ) {
	local lum, heard
	lum = source.luminosity
	source.luminosity = 6
	heard = ::view( range, source )
	source.luminosity = lum
	return heard
}

function get_hearers_in_view( R, source ) {
	local T, hear, range, A
	T = ::get_turf( source )
	hear = ::List()
	if ( !T ) {
		return hear
	}
	range = ::get_hear( R, T )
	A = null
	foreach (_ in range ) {
		A = _
		if ( !::istype( A, ::AtomMovable ) ) {
			continue
		}
		hear = hear | ::recursive_hear_check( A )
	}
	return hear
}

function get_location_accessible( M, location ) {
	// Decompile Failure: more bad switch
}

function get_location_modifier( M ) {
	local T
	T = ::get_turf( M )
	if ( ::locate_in( ::ObjStructureOptable, T ) ) {
		return 1
	} else if ( ::locate_in( ::ObjStructureTable, T ) ) {
		return 0.800000011920929
	} else if ( ::locate_in( ::ObjStructureBed, T ) ) {
		return 0.699999988079071
	} else {
		return 0.5
	}
}

function get_mob_by_ckey( key ) {
	local mobs, M
	if ( !key ) {
		return
	}
	mobs = ::sortmobs()
	M = null
	foreach (_ in mobs ) {
		M = _
		if ( M.ckey == key ) {
			return M
		}
	}
}

function get_mob_by_key( key ) {
	local M
	M = null
	foreach (_ in ::mob_list ) {
		M = _
		if ( M.ckey == ::lowertext( key ) ) {
			return M
		}
	}
	return
}

function get_mobs_in_radio_ranges( radios ) {
	local R, _default
	_default = ::List()
	R = null
	foreach (_ in radios ) {
		R = _
		if ( !::istype( R, ::ObjItemDeviceRadio ) ) {
			continue
		}
		if ( R ) {
			_default = _default | ::get_hearers_in_view( R.canhear_range, R )
		}
	}
	return _default
}

function get_radio_name( freq ) {
	local returntext
	returntext = ::radiochannelsreverse["" + ::txt.mark( freq )]
	if ( returntext ) {
		return returntext
	}
	return "" + ::txt.mark( ::copytext( "" + ::txt.mark( freq ), 1, 4 ) ) + "." + ::txt.mark( ::copytext( "" + ::txt.mark( freq ), 4, 5 ) )
}

function get_radio_span( freq ) {
	local returntext
	returntext = ::freqtospan["" + ::txt.mark( freq )]
	if ( returntext ) {
		return returntext
	}
	return "radio"
}

function get_rand_frequency(  ) {
	return ::rand( 32000, 55000 )
}

function get_ranged_target_turf( A, direction, range ) {
	local x, y
	x = A.x
	y = A.y
	if ( direction & 1 ) {
		y = ::min( ::game.maxy, y + range )
	}
	if ( direction & 2 ) {
		y = ::max( 1, y - range )
	}
	if ( direction & 4 ) {
		x = ::min( ::game.maxx, x + range )
	}
	if ( direction & 8 ) {
		x = ::max( 1, x - range )
	}
	return ::locate3( x, y, A.z )
}

function get_region_accesses( code ) {
	local _ = code // Was a switch-case, sorry for the mess.
	if ( _==0 ) {
		return ::get_all_accesses()
	} else if ( _==1 ) {
		return ::List([ ::access_kitchen, ::access_bar, ::access_hydroponics, ::access_janitor, ::access_chapel_office, ::access_crematorium, ::access_library, ::access_theatre, ::access_lawyer ])
	} else if ( _==2 ) {
		return ::List([ ::access_sec_doors, ::access_weapons, ::access_security, ::access_brig, ::access_armory, ::access_forensics_lockers, ::access_court, ::access_hos ])
	} else if ( _==3 ) {
		return ::List([ ::access_medical, ::access_genetics, ::access_morgue, ::access_chemistry, ::access_virology, ::access_surgery, ::access_cmo ])
	} else if ( _==4 ) {
		return ::List([ ::access_research, ::access_tox, ::access_tox_storage, ::access_genetics, ::access_robotics, ::access_xenobiology, ::access_minisat, ::access_rd ])
	} else if ( _==5 ) {
		return ::List([ ::access_construction, ::access_maint_tunnels, ::access_engine, ::access_engine_equip, ::access_external_airlocks, ::access_tech_storage, ::access_atmospherics, ::access_tcomsat, ::access_minisat, ::access_ce ])
	} else if ( _==6 ) {
		return ::List([ ::access_mailsorting, ::access_mining, ::access_mining_station, ::access_mineral_storeroom, ::access_cargo, ::access_qm ])
	} else if ( _==7 ) {
		return ::List([ ::access_heads, ::access_RC_announce, ::access_keycard_auth, ::access_change_ids, ::access_ai_upload, ::access_teleporter, ::access_eva, ::access_gateway, ::access_all_personal_lockers, ::access_heads_vault, ::access_hop, ::access_captain ])
	}
}

function get_region_accesses_name( code ) {
	local _ = code // Was a switch-case, sorry for the mess.
	if ( _==0 ) {
		return "All"
	} else if ( _==1 ) {
		return "General"
	} else if ( _==2 ) {
		return "Security"
	} else if ( _==3 ) {
		return "Medbay"
	} else if ( _==4 ) {
		return "Research"
	} else if ( _==5 ) {
		return "Engineering"
	} else if ( _==6 ) {
		return "Supply"
	} else if ( _==7 ) {
		return "Command"
	}
}

function get_security_level(  ) {
	local _ = ::security_level // Was a switch-case, sorry for the mess.
	if ( _==0 ) {
		return "green"
	} else if ( _==1 ) {
		return "blue"
	} else if ( _==2 ) {
		return "red"
	} else if ( _==3 ) {
		return "delta"
	}
}

function get_sfx( soundin ) {
	if ( ::istext( soundin ) ) {
		local _ = soundin // Was a switch-case, sorry for the mess.
		if ( _=="shatter" ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 21845 ) { _ = ::Rsc(16) }
			else if ( _ < 43690 ) { _ = ::Rsc(17) }
			else  { _ = ::Rsc(18) }

			soundin = _
		} else if ( _=="explosion" ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 32767 ) { _ = ::Rsc(19) }
			else  { _ = ::Rsc(20) }

			soundin = _
		} else if ( _=="sparks" ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 16383 ) { _ = ::Rsc(21) }
			else if ( _ < 32766 ) { _ = ::Rsc(22) }
			else if ( _ < 49149 ) { _ = ::Rsc(23) }
			else  { _ = ::Rsc(24) }

			soundin = _
		} else if ( _=="rustle" ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 13107 ) { _ = ::Rsc(25) }
			else if ( _ < 26214 ) { _ = ::Rsc(26) }
			else if ( _ < 39321 ) { _ = ::Rsc(27) }
			else if ( _ < 52428 ) { _ = ::Rsc(28) }
			else  { _ = ::Rsc(29) }

			soundin = _
		} else if ( _=="bodyfall" ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 16383 ) { _ = ::Rsc(30) }
			else if ( _ < 32766 ) { _ = ::Rsc(31) }
			else if ( _ < 49149 ) { _ = ::Rsc(32) }
			else  { _ = ::Rsc(33) }

			soundin = _
		} else if ( _=="punch" ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 16383 ) { _ = ::Rsc(34) }
			else if ( _ < 32766 ) { _ = ::Rsc(35) }
			else if ( _ < 49149 ) { _ = ::Rsc(36) }
			else  { _ = ::Rsc(37) }

			soundin = _
		} else if ( _=="clownstep" ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 32767 ) { _ = ::Rsc(38) }
			else  { _ = ::Rsc(39) }

			soundin = _
		} else if ( _=="swing_hit" ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 21845 ) { _ = ::Rsc(40) }
			else if ( _ < 43690 ) { _ = ::Rsc(41) }
			else  { _ = ::Rsc(42) }

			soundin = _
		} else if ( _=="hiss" ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 16383 ) { _ = ::Rsc(43) }
			else if ( _ < 32766 ) { _ = ::Rsc(44) }
			else if ( _ < 49149 ) { _ = ::Rsc(45) }
			else  { _ = ::Rsc(46) }

			soundin = _
		} else if ( _=="pageturn" ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 21845 ) { _ = ::Rsc(47) }
			else if ( _ < 43690 ) { _ = ::Rsc(48) }
			else  { _ = ::Rsc(49) }

			soundin = _
		} else if ( _=="gunshot" ) {
			local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
			if ( _ < 16383 ) { _ = ::Rsc(50) }
			else if ( _ < 32766 ) { _ = ::Rsc(51) }
			else if ( _ < 49149 ) { _ = ::Rsc(52) }
			else  { _ = ::Rsc(53) }

			soundin = _
		}
	}
	return soundin
}

function get_stickyban_from_ckey( ckey ) {
	local key, _default
	if ( !ckey ) {
		return
	}
	ckey = ::ckey( ckey )
	_default = null
	key = null
	foreach (_ in ::game.GetConfig( "ban" ) ) {
		key = _
		if ( ::ckey( key ) == ckey ) {
			_default = ::stickyban2list( ::game.GetConfig( "ban", key ) )
			break
		}
	}
	return _default
}

function get_teleport_loc( location, target, distance, density, errorx, errory, eoffsetx, eoffsety ) {
	local dirx, diry, xoffset, yoffset, b1xerror, b1yerror, b2xerror, b2yerror, destination, destination_list, center, T
	if ( distance == null ) {
		distance = 1
	}
	if ( density == null ) {
		density = 0
	}
	if ( errorx == null ) {
		errorx = 0
	}
	if ( errory == null ) {
		errory = 0
	}
	if ( eoffsetx == null ) {
		eoffsetx = 0
	}
	if ( eoffsety == null ) {
		eoffsety = 0
	}
	dirx = 0
	diry = 0
	xoffset = 0
	yoffset = 0
	b1xerror = 0
	b1yerror = 0
	b2xerror = 0
	b2yerror = 0
	errorx = ::abs( errorx )
	errory = ::abs( errory )
	local _ = target.dir // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		diry += distance
		yoffset += eoffsety
		xoffset += eoffsetx
		b1xerror -= errorx
		b1yerror -= errory
		b2xerror += errorx
		b2yerror += errory
	} else if ( _==2 ) {
		diry -= distance
		yoffset -= eoffsety
		xoffset += eoffsetx
		b1xerror -= errorx
		b1yerror -= errory
		b2xerror += errorx
		b2yerror += errory
	} else if ( _==4 ) {
		dirx += distance
		yoffset += eoffsetx
		xoffset += eoffsety
		b1xerror -= errory
		b1yerror -= errorx
		b2xerror += errory
		b2yerror += errorx
	} else if ( _==8 ) {
		dirx -= distance
		yoffset -= eoffsetx
		xoffset += eoffsety
		b1xerror -= errory
		b1yerror -= errorx
		b2xerror += errory
		b2yerror += errorx
	}
	destination = ::locate3( location.x + dirx, location.y + diry, location.z )
	if ( destination ) {
		if ( errorx || errory ) {
			destination_list = ::List()
			center = ::locate3( destination.x + xoffset, destination.y + yoffset, location.z )
			T = null
			foreach (_ in ::locate3( center.x + b2xerror, center.y + b2yerror, location.z ) ) {
				T = _
				if ( density && T.density ) {
					continue
				}
				if ( T.x > ::game.maxx || T.x < 1 ) {
					continue
				}
				if ( T.y > ::game.maxy || T.y < 1 ) {
					continue
				}
				destination_list += T
			}
			if ( destination_list.len ) {
				destination = ::pick_list( destination_list )
			} else {
				return
			}
		} else {
			if ( density && destination.density ) {
				return
			}
			if ( destination.x > ::game.maxx || destination.x < 1 ) {
				return
			}
			if ( destination.y > ::game.maxy || destination.y < 1 ) {
				return
			} else {
				return
			}
		}
	}
	return destination
}

function get_turf( A ) {
	if ( !::istype( A, ::Atom ) ) {
		return
	}
	if ( A && !::isturf( A ) ) {
		A = A.loc
		// goto 11
	}
	return A
}

function get_turf_pixel( AM ) {
	local rough_x, rough_y, final_x, final_y, i_width, i_height, AMicon, n_width, n_height
	if ( ::istype( AM, ::AtomMovable ) ) {
		rough_x = 0
		rough_y = 0
		final_x = 0
		final_y = 0
		i_width = ::game.icon_size
		i_height = ::game.icon_size
		if ( AM.bound_height != ::game.icon_size || AM.bound_width != ::game.icon_size ) {
			AMicon = "/icon"( AM.icon, AM.icon_state )
			i_width = AMicon.Width()
			i_height = AMicon.Height()
			::qdel( AMicon )
		}
		n_width = ::game.icon_size - i_width / 2
		n_height = ::game.icon_size - i_height / 2
		if ( n_width ) {
			rough_x = ::round( AM.pixel_x / n_width )
		}
		if ( n_height ) {
			rough_y = ::round( AM.pixel_y / n_height )
		}
		final_x = AM.x + rough_x
		final_y = AM.y + rough_y
		if ( final_x || final_y ) {
			return ::locate3( final_x, final_y, AM.z )
		}
	}
}

function get_uplink_items( gamemode_override ) {
	local last, item, I, I, filtered_uplink_items, category, I
	if ( gamemode_override == null ) {
		gamemode_override = null
	}
	if ( !::uplink_items.len ) {
		last = ::List()
		item = null
		foreach (_ in ::typesof( ::DatumUplink_item ) ) {
			item = _
			I = item()
			if ( !I.item ) {
				continue
			}
			if ( I.last ) {
				last += I
				continue
			}
			if ( !::uplink_items[I.category] ) {
				::uplink_items[I.category] = ::List()
			}
			::uplink_items[I.category] += I
		}
		I = null
		foreach (_ in last ) {
			I = _
			if ( !::istype( I, ::DatumUplink_item ) ) {
				continue
			}
			if ( !::uplink_items[I.category] ) {
				::uplink_items[I.category] = ::List()
			}
			::uplink_items[I.category] += I
		}
	}
	filtered_uplink_items = ::List()
	category = null
	foreach (_ in ::uplink_items ) {
		category = _
		I = null
		foreach (_ in ::uplink_items[category] ) {
			I = _
			if ( !::istype( I, ::DatumUplink_item ) ) {
				continue
			}
			if ( I.gamemodes.len ) {
				if ( !gamemode_override && ( ::ticker && !( ::ticker.mode.type in I.gamemodes ) ) ) {
					continue
				}
				if ( gamemode_override && !( gamemode_override in I.gamemodes ) ) {
					continue
				}
			}
			if ( I.excludefrom.len ) {
				if ( !gamemode_override && ( ::ticker && ( ::ticker.mode.type in I.excludefrom ) ) ) {
					continue
				}
				if ( gamemode_override && ( gamemode_override in I.excludefrom ) ) {
					continue
				}
			}
			if ( !filtered_uplink_items[I.category] ) {
				filtered_uplink_items[I.category] = ::List()
			}
			filtered_uplink_items[category] += I
		}
	}
	return filtered_uplink_items
}

function get_viewable_pdas(  ) {
	local P, _default
	_default = ::List()
	P = null
	foreach (_ in ::PDAs ) {
		P = _
		if ( !::istype( P, ::ObjItemDevicePda ) ) {
			continue
		}
		if ( !P.owner || ( P.toff || P.hidden ) ) {
			continue
		}
		_default += P
	}
	return _default
	return _default
}

function getb( col ) {
	return ::hex2num( ::copytext( col, 6, null ) )
}

function getBlankIcon( A, safety ) {
	local flat_icon, blank_icon
	if ( safety == null ) {
		safety = 1
	}
	flat_icon = safety ? A : ::Icon( A )
	flat_icon.Blend( "#ffffff" )
	flat_icon.BecomeAlphaMask()
	blank_icon = ::Icon( ::Rsc(11), "blank_base" )
	blank_icon.AddAlphaMask( flat_icon )
	return blank_icon
}

function getblock( input, blocknumber, blocksize ) {
	if ( blocksize == null ) {
		blocksize = 3
	}
	return ::copytext( input, blocksize * ( blocknumber - 1 ) + 1, blocksize * blocknumber + 1 )
}

function GetColors( hex ) {
	local hi1, lo1, hi2, lo2, hi3, lo3, hi4, lo4
	hex = ::uppertext( hex )
	if ( ::length( hex ) == 7 ) {
		hex += "FF"
	}
	hi1 = ::text2ascii( hex, 2 )
	lo1 = ::text2ascii( hex, 3 )
	hi2 = ::text2ascii( hex, 4 )
	lo2 = ::text2ascii( hex, 5 )
	hi3 = ::text2ascii( hex, 6 )
	lo3 = ::text2ascii( hex, 7 )
	hi4 = ::text2ascii( hex, 8 )
	lo4 = ::text2ascii( hex, 9 )
	return ::List([ ( hi1 >= 65 ? hi1 - 55 : hi1 - 48 ) << 4 | ( lo1 >= 65 ? lo1 - 55 : lo1 - 48 ), ( hi2 >= 65 ? hi2 - 55 : hi2 - 48 ) << 4 | ( lo2 >= 65 ? lo2 - 55 : lo2 - 48 ), ( hi3 >= 65 ? hi3 - 55 : hi3 - 48 ) << 4 | ( lo3 >= 65 ? lo3 - 55 : lo3 - 48 ), ( hi4 >= 65 ? hi4 - 55 : hi4 - 48 ) << 4 | ( lo4 >= 65 ? lo4 - 55 : lo4 - 48 ) ])
}

function GetExp( minutes ) {
	local exp, timeleftstring
	::UpdateTime()
	exp = minutes - ::CMinutes
	if ( exp <= 0 ) {
		return 0
	} else {
		if ( exp >= 1440 ) {
			timeleftstring = "" + ::txt.mark( ::round2( exp / 1440, 0.10000000149011612 ) ) + " Days"
		} else if ( exp >= 60 ) {
			timeleftstring = "" + ::txt.mark( ::round2( exp / 60, 0.10000000149011612 ) ) + " Hours"
		} else {
			timeleftstring = "" + ::txt.mark( exp ) + " Minutes"
		}
		return timeleftstring
	}
}

function GetExpjob( minutes ) {
	local exp, timeleftstring
	::UpdateTime()
	exp = minutes - ::CMinutes
	if ( exp <= 0 ) {
		return 0
	} else {
		if ( exp >= 1440 ) {
			timeleftstring = "" + ::txt.mark( ::round2( exp / 1440, 0.10000000149011612 ) ) + " Days"
		} else if ( exp >= 60 ) {
			timeleftstring = "" + ::txt.mark( ::round2( exp / 60, 0.10000000149011612 ) ) + " Hours"
		} else {
			timeleftstring = "" + ::txt.mark( exp ) + " Minutes"
		}
		return timeleftstring
	}
}

function getFlatIcon( A, defdir, deficon, defstate, defblend ) {
	// Decompile Failure: bad logic1
}

function GetFromPool( get_type, second_arg ) {
	local pooled, AM
	if ( !get_type ) {
		return
	}
	if ( ::isnull( ::GlobalPool[get_type] ) ) {
		return
	}
	if ( ::length( ::GlobalPool[get_type] ) == 0 ) {
		return
	}
	pooled = ::pop( ::GlobalPool[get_type] )
	if ( pooled ) {
		if ( ::istype( pooled, ::AtomMovable ) ) {
			AM = pooled
		}
		return
		if ( ::istype( second_arg, ::List ) ) {
			if ( AM ) {
				AM.loc = second_arg[1]
			}
			pooled.New( "LIST_CALL", second_arg )
		} else {
			if ( AM ) {
				AM.loc = second_arg
			}
			pooled.New( second_arg )
		}
		return pooled
	}
}

function getg( col ) {
	return ::hex2num( ::copytext( col, 4, 6 ) )
}

function getHologramIcon( A, safety ) {
	local flat_icon, alpha_mask
	if ( safety == null ) {
		safety = 1
	}
	flat_icon = safety ? A : ::Icon( A )
	flat_icon.ColorTone( "#7db4e1" )
	flat_icon.ChangeOpacity( 0.5 )
	alpha_mask = ::Icon( ::Rsc(11), "scanline" )
	flat_icon.AddAlphaMask( alpha_mask )
	return flat_icon
}

function getIconMask( A ) {
	local alpha_mask, I, image_overlay
	alpha_mask = ::Icon( A.icon, A.icon_state )
	I = null
	foreach (_ in A.overlays ) {
		I = _
		if ( I.layer > A.layer ) {
			continue
		}
		image_overlay = ::Icon( I.icon, I.icon_state )
		alpha_mask.Blend( image_overlay, 5 )
	}
	return alpha_mask
}

function getleftblocks( input, blocknumber, blocksize ) {
	if ( blocknumber > 1 ) {
		return ::copytext( input, 1, blocksize * blocknumber - ( blocksize - 1 ) )
	}
}

function getLetterImage( A, letter, uppercase ) {
	local atom_icon, text_image
	if ( letter == null ) {
		letter = ""
	}
	if ( uppercase == null ) {
		uppercase = 0
	}
	if ( !A ) {
		return
	}
	atom_icon = ::Icon( A.icon, A.icon_state )
	if ( !letter ) {
		letter = ::copytext( A.name, 1, 2 )
		if ( uppercase == 1 ) {
			letter = ::uppertext( letter )
		} else if ( uppercase == -1 ) {
			letter = ::lowertext( letter )
		}
	}
}

function getline( M, N ) {
	local px, py, line, dx, dy, dxabs, dyabs, sdx, sdy, x, y, j
	px = M.x
	py = M.y
	line = ::List([ ::locate3( px, py, M.z ) ])
	dx = N.x - px
	dy = N.y - py
	dxabs = ::abs( dx )
	dyabs = ::abs( dy )
	sdx = ::sign( dx )
	sdy = ::sign( dy )
	x = dxabs >> 1
	y = dyabs >> 1
	if ( dxabs >= dyabs ) {
		j = 0
		if ( j < dxabs ) {
			y += dyabs
			if ( y >= dxabs ) {
				y -= dxabs
				py += sdy
			}
			px += sdx
			line += ::locate3( px, py, M.z )
			j++
			// goto 60
			// goto 128
		}
	}
	j = 0
	while (j < dyabs) {
		x += dxabs
		if ( x >= dyabs ) {
			x -= dyabs
			px += sdx
		}
		py += sdy
		line += ::locate3( px, py, M.z )
		j++
	}
	return line
}

function getmobs(  ) {
	local mobs, names, creatures, namecounts, M, name
	mobs = ::sortmobs()
	names = ::List()
	creatures = ::List()
	namecounts = ::List()
	M = null
	foreach (_ in mobs ) {
		M = _
		name = M.name
		if ( name in names ) {
			namecounts[name]++
			name = "" + ::txt.mark( name ) + " (" + ::txt.mark( namecounts[name] ) + ")"
		} else {
			names.Add( name )
			namecounts[name] = 1
		}
		if ( M.real_name && M.real_name != M.name ) {
			name += " [" + ::txt.mark( M.real_name ) + "]"
		}
		if ( M.stat == 2 ) {
			if ( ::istype( M, ::MobDeadObserver ) ) {
				name += " [ghost]"
			} else {
				name += " [dead]"
			}
		}
		creatures[name] = M
	}
	return creatures
}

function getr( col ) {
	return ::hex2num( ::copytext( col, 2, 4 ) )
}

function getrightblocks( input, blocknumber, blocksize ) {
	if ( blocknumber < ::length( input ) / blocksize ) {
		return ::copytext( input, blocksize * blocknumber + 1, ::length( input ) + 1 )
	}
}

function getStaticIcon( A, safety ) {
	local flat_icon, static_icon
	if ( safety == null ) {
		safety = 1
	}
	flat_icon = safety ? A : ::Icon( A )
	flat_icon.Blend( "#ffffff" )
	flat_icon.BecomeAlphaMask()
	static_icon = ::Icon( ::Rsc(11), "static_base" )
	static_icon.AddAlphaMask( flat_icon )
	return static_icon
}

function Gibberish( t, p ) {
	local returntext, i, letter, j
	returntext = ""
	i = null
	i = 1
	while (i <= ::length( t )) {
		letter = ::copytext( t, i, i + 1 )
		if ( ::prob( 50 ) ) {
			if ( p >= 70 ) {
				letter = ""
			}
			j = null
			j = 1
			while (j <= ::rand( 0, 2 )) {
				local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
				if ( _ < 3855 ) { _ = "#" }
				else if ( _ < 7710 ) { _ = "@" }
				else if ( _ < 11565 ) { _ = "*" }
				else if ( _ < 15420 ) { _ = "&" }
				else if ( _ < 19275 ) { _ = "%" }
				else if ( _ < 23130 ) { _ = "$" }
				else if ( _ < 26985 ) { _ = "/" }
				else if ( _ < 30840 ) { _ = "<" }
				else if ( _ < 34695 ) { _ = ">" }
				else if ( _ < 38550 ) { _ = ";" }
				else if ( _ < 42405 ) { _ = "*" }
				else if ( _ < 46260 ) { _ = "*" }
				else if ( _ < 50115 ) { _ = "*" }
				else if ( _ < 53970 ) { _ = "*" }
				else if ( _ < 57825 ) { _ = "*" }
				else if ( _ < 61680 ) { _ = "*" }
				else  { _ = "*" }

				letter += _
				j++
			}
		}
		returntext += letter
		i++
	}
	return returntext
}

function gibs( location, viruses, MobDNA ) {
	::ObjEffectGibspawnerGeneric( location, viruses, MobDNA )
}

function give_codewords( traitor_mob ) {
	traitor_mob.write( "<U><B>The Syndicate provided you with the following information on how to identify their agents:</B></U>" )
	traitor_mob.write( "<B>Code Phrase</B>: <span class='danger'>" + ::txt.mark( ::syndicate_code_phrase ) + "</span>" )
	traitor_mob.write( "<B>Code Response</B>: <span class='danger'>" + ::txt.mark( ::syndicate_code_response ) + "</span>" )
	traitor_mob.mind.store memory( "<b>Code Phrase</b>: " + ::txt.mark( ::syndicate_code_phrase ) )
	traitor_mob.store memory( "<b>Code Response</b>: " + ::txt.mark( ::syndicate_code_response ) )
	traitor_mob.write( "Use the code words in the order provided, during regular conversation, to identify other agents. Proceed with caution, however, as everyone is a potential foe." )
}

function has_gravity( AT, T ) {
	local A
	if ( !T ) {
		T = ::get_turf( AT )
	}
	A = ::get_area( T )
	if ( ::istype( T, ::TurfSpace ) ) {
		return 0
	} else if ( A && A.has_gravity ) {
		return 1
	} else if ( T && ( ::gravity_generators["" + ::txt.mark( T.z )] && ::length( ::gravity_generators["" + ::txt.mark( T.z )] ) ) ) {
		return 1
	}
	return 0
}

function hasvar( A, varname ) {
	if ( A.vars.Find( ::lowertext( varname ) ) ) {
		return 1
	} else {
		return 0
	}
}

function healthscan( user, M, mode ) {
	local oxy_loss, tox_loss, fire_loss, brute_loss, mob_status, H, H, damaged, org, H, D, H, blood_volume, blood_percent, blood_type, implant_detect, CI
	if ( mode == null ) {
		mode = 1
	}
	oxy_loss = M.getOxyLoss()
	tox_loss = M.getToxLoss()
	fire_loss = M.getFireLoss()
	brute_loss = M.getBruteLoss()
	mob_status = M.stat > 1 ? "<span class='alert'><b>Deceased</b></span>" : "<b>" + ::txt.mark( M.health ) + " % healthy</b>"
	if ( M.status_flags & 8192 ) {
		mob_status = "<span class='alert'>Deceased</span>"
		oxy_loss = ::max( ::rand( 1, 40 ), oxy_loss, 300 - ( tox_loss + fire_loss + brute_loss ) )
	}
	if ( ::istype( M, ::MobLivingCarbonHuman ) ) {
		H = M
		if ( H.heart_attack ) {
			user.write( "<span class='danger'>Subject suffering from heart attack: Apply defibrillator immediately!</span>" )
		}
	}
	user.write( "<span class='info'>Analyzing results for " + ::txt.mark( M ) + ":\n	Overall status: " + ::txt.mark( mob_status ) + "</span>" )
	if ( brute_loss > 10 ) {
		user.write( "	<span class='alert'>" + ::txt.mark( brute_loss > 50 ? "Severe" : "Minor" ) + " tissue damage detected.</span>" )
	}
	if ( fire_loss > 10 ) {
		user.write( "	<span class='alert'>" + ::txt.mark( fire_loss > 50 ? "Severe" : "Minor" ) + " burn damage detected.</span>" )
	}
	if ( oxy_loss > 10 ) {
		user.write( "	<span class='info'><span class='alert'>" + ::txt.mark( oxy_loss > 50 ? "Severe" : "Minor" ) + " oxygen deprivation detected.</span>" )
	}
	if ( tox_loss > 10 ) {
		user.write( "	<span class='alert'>" + ::txt.mark( tox_loss > 50 ? "Critical" : "Dangerous" ) + " amount of toxins detected.</span>" )
	}
	if ( M.getStaminaLoss() ) {
		user.write( "	<span class='alert'>Subject appears to be suffering from fatigue.</span>" )
	}
	if ( M.getCloneLoss() ) {
		user.write( "	<span class='alert'>Subject appears to have " + ::txt.mark( M.getCloneLoss() > 30 ? "severe" : "minor" ) + " cellular damage.</span>" )
	}
	if ( M.reagents && M.reagents.get reagent amount( "epinephrine" ) ) {
		user.write( "	<span class='info'>Bloodstream analysis located " + ::txt.mark( M.reagents.get reagent amount( "epinephrine" ) ) + " units of rejuvenation chemicals.</span>" )
	}
	if ( M.getBrainLoss() >= 100 || !M.getorgan( ::ObjItemOrganInternalBrain ) ) {
		user.write( "	<span class='alert'>Subject brain function is non-existant.</span>" )
	} else if ( M.getBrainLoss() >= 60 ) {
		user.write( "	<span class='alert'>Severe brain damage detected. Subject likely to have mental retardation.</span>" )
	} else if ( M.getBrainLoss() >= 10 ) {
		user.write( "	<span class='alert'>Brain damage detected. Subject may have had a concussion.</span>" )
	}
	if ( ::istype( M, ::MobLivingCarbonHuman ) && mode == 1 ) {
		H = M
		damaged = H.get damaged organs( 1, 1 )
		if ( ::length( damaged ) > 0 || ( oxy_loss > 0 || ( tox_loss > 0 || fire_loss > 0 ) ) ) {
			user.write( "<span class='info'>	Damage: <span class='info'><font color='red'>Brute</font></span>-<font color='#FF8000'>Burn</font>-<font color='green'>Toxin</font>-<font color='blue'>Suffocation</font>\n		Specifics: <font color='red'>" + ::txt.mark( brute_loss ) + "</font>-<font color='#FF8000'>" + ::txt.mark( fire_loss ) + "</font>-<font color='green'>" + ::txt.mark( tox_loss ) + "</font>-<font color='blue'>" + ::txt.mark( oxy_loss ) + "</font></span>" )
			org = null
			foreach (_ in damaged ) {
				org = _
				if ( !::istype( org, ::ObjItemOrganLimb ) ) {
					continue
				}
				user.write( "		<span class='info'>" + ::txt.mark( ::capitalize( org.getDisplayName() ) ) + ": " + ::txt.mark( org.brute_dam > 0 ? "<font color='red'>" + ::txt.mark( org.brute_dam ) + "</font></span>" : "<font color='red'>0</font>" ) + "-" + ::txt.mark( org.burn_dam > 0 ? "<font color='#FF8000'>" + ::txt.mark( org.burn_dam ) + "</font>" : "<font color='#FF8000'>0</font>" ) )
			}
		}
	}
	if ( ::istype( M, ::MobLivingCarbonHuman ) ) {
		H = M
		user.write( "<span class='info'>Species: " + ::txt.mark( H.dna.species.name ) + "</span>" )
	}
	user.write( "<span class='info'>Body temperature: " + ::txt.mark( ::round2( M.bodytemperature - 273.1499938964844, 0.10000000149011612 ) ) + " &deg;C (" + ::txt.mark( ::round2( M.bodytemperature * 1.7999999523162842 - 459.6700134277344, 0.10000000149011612 ) ) + " &deg;F)</span>" )
	if ( M.tod && ( M.stat == 2 || M.status_flags & 8192 ) ) {
		user.write( "<span class='info'>Time of Death:</span> " + ::txt.mark( M.tod ) )
	}
	D = null
	foreach (_ in M.viruses ) {
		D = _
		if ( !::istype( D, ::DatumDisease ) ) {
			continue
		}
		if ( !( D.visibility_flags & 1 ) ) {
			user.write( "<span class='alert'><b>Warning: " + ::txt.mark( D.form ) + " detected</b>\nName: " + ::txt.mark( D.name ) + ".\nType: " + ::txt.mark( D.spread_text ) + ".\nStage: " + ::txt.mark( D.stage ) + "/" + ::txt.mark( D.max_stages ) + ".\nPossible Cure: " + ::txt.mark( D.cure_text ) + "</span>" )
		}
	}
	if ( ::istype( M, ::MobLivingCarbonHuman ) ) {
		H = M
		if ( H.vessel ) {
			if ( H.blood_max ) {
				user.write( "<span class='danger'>Subject is bleeding!</span>" )
			}
			blood_volume = ::round( H.vessel.get reagent amount( "blood" ) )
			blood_percent = ::round2( blood_volume / 560, 0.009999999776482582 )
			blood_type = H.dna.blood_type
			blood_percent *= 100
			if ( blood_volume <= 500 && blood_volume > 336 ) {
				user.write( "<span class='danger'>LOW blood level " + ::txt.mark( blood_percent ) + " %, " + ::txt.mark( blood_volume ) + " cl,</span> <span class='info'>type: " + ::txt.mark( blood_type ) + "</span>" )
			} else if ( blood_volume <= 336 ) {
				user.write( "<span class='danger'>CRITICAL blood level CRITICAL " + ::txt.mark( blood_percent ) + " %, " + ::txt.mark( blood_volume ) + " cl,</span> <span class='info'>type: " + ::txt.mark( blood_type ) + "</span>" )
			} else {
				user.write( "<span class='info'>Blood level " + ::txt.mark( blood_percent ) + " %, " + ::txt.mark( blood_volume ) + " cl, type: " + ::txt.mark( blood_type ) + "</span>" )
			}
		}
		implant_detect = null
		CI = null
		foreach (_ in H.internal_organs ) {
			CI = _
			if ( !::istype( CI, ::ObjItemOrganInternalCyberimp ) ) {
				continue
			}
			if ( CI.status == 2 ) {
				implant_detect += "" + ::txt.mark( H.name ) + " is modified with a " + ::txt.mark( CI.name ) + ".<br>"
			}
		}
		if ( implant_detect ) {
			user.show message( "<span class='notice'>Detected cybernetic modifications:</span>" )
			user.show message( "<span class='notice'>" + ::txt.mark( implant_detect ) + "</span>" )
		}
	}
}

function heat2colour_b( temp ) {
	temp /= 100
	if ( temp >= 66 ) {
		_default = 255
	} else if ( temp <= 16 ) {
		_default = 0
	} else {
		_default = ::max( 0, ::min( 255, ::log( temp - 10 ) * 138.51773071289062 - 305.0447998046875 ) )
	}
	return _default
}

function heat2colour_g( temp ) {
	temp /= 100
	if ( temp <= 66 ) {
		_default = ::max( 0, ::min( 255, ::log( temp ) * 99.4708023071289 - 161.11956787109375 ) )
	} else {
		_default = ::max( 0, ::min( 255, ::pow( temp - 60, -0.07514849305152893 ) * 288.1221618652344 ) )
	}
	return _default
}

function heat2colour_r( temp ) {
	temp /= 100
	if ( temp <= 66 ) {
		_default = 255
	} else {
		_default = ::max( 0, ::min( 255, ::pow( temp - 60, -0.13320475816726685 ) * 329.69873046875 ) )
	}
	return _default
}

function hex2num( hex ) {
	local negative, len, i, num, _default
	_default = 0
	if ( ::istext( hex ) ) {
		negative = 0
		len = ::length( hex )
		i = null
		i = 1
		while (i <= len) {
			num = ::text2ascii( hex, i )
			local _ = num // Was a switch-case, sorry for the mess.
			if ( 48<=_&&_<=57 ) {
				num -= 48
			} else if ( 97<=_&&_<=102 ) {
				num -= 87
			} else if ( 65<=_&&_<=70 ) {
				num -= 55
			} else if ( _==45 ) {
				negative = 1
			} else {
				if ( num ) {
					break
				} else {
					i++
					continue
				}
			}
			_default *= 16
			_default += num
			i++
		}
		if ( negative ) {
			_default *= -1
		}
	}
	return _default
	return _default
}

function hgibs( location, viruses, MobDNA ) {
	::ObjEffectGibspawnerHuman( location, viruses, MobDNA )
}

function init_paths( prototype, L ) {
	local path
	return
	if ( !::istype( L, ::List ) ) {
		L = ::List()
		path = null
		foreach (_ in ::typesof( prototype ) ) {
			path = _
			if ( path == prototype ) {
				continue
			}
			L += path
		}
		return L
	}
}

function init_sprite_accessory_subtypes( prototype, L, male, female ) {
	local path, D
	return
	if ( !::istype( L, ::List ) ) {
		L = ::List()
	}
	return
	if ( !::istype( male, ::List ) ) {
		male = ::List()
	}
	return
	if ( !::istype( female, ::List ) ) {
		female = ::List()
	}
	path = null
	foreach (_ in ::typesof( prototype ) ) {
		path = _
		if ( path == prototype ) {
			continue
		}
		D = path()
		if ( D.icon_state ) {
			L[D.name] = D
		} else {
			L += D.name
		}
		local _ = D.gender // Was a switch-case, sorry for the mess.
		if ( _=="male" ) {
			male += D.name
		} else if ( _=="female" ) {
			female += D.name
		} else {
			male += D.name
			female += D.name
		}
	}
	return L
}

function init_subtypes( prototype, L ) {
	local path
	return
	if ( !::istype( L, ::List ) ) {
		L = ::List()
	}
	path = null
	foreach (_ in ::typesof( prototype ) ) {
		path = _
		if ( path == prototype ) {
			continue
		}
		L += path()
	}
	return L
}

function InitializeSwapMaps(  ) {
	local V
	if ( ::swapmaps_initialized ) {
		return
	}
	::swapmaps_initialized = 1
	::swapmaps_compiled_maxx = ::game.maxx
	::swapmaps_compiled_maxy = ::game.maxy
	::swapmaps_compiled_maxz = ::game.maxz
	::swapmaps_loaded = ::List()
	::swapmaps_byname = ::List()
	if ( ::swapmaps_iconcache ) {
		V = null
		foreach (_ in ::swapmaps_iconcache ) {
			V = _
			::swapmaps_iconcache[::swapmaps_iconcache[V]] = V
		}
	}
}

function inLineOfSight( X1, Y1, X2, Y2, Z, PX1, PY1, PX2, PY2 ) {
	local T, s, m, b, signX, signY
	if ( Z == null ) {
		Z = 1
	}
	if ( PX1 == null ) {
		PX1 = 16.5
	}
	if ( PY1 == null ) {
		PY1 = 16.5
	}
	if ( PX2 == null ) {
		PX2 = 16.5
	}
	if ( PY2 == null ) {
		PY2 = 16.5
	}
	if ( X1 == X2 ) {
		if ( Y1 == Y2 ) {
			return 1
		} else {
			s = Y2 - Y1 < 0 ? -1 : 1
			Y1 += s
			if ( Y1 != Y2 ) {
				T = ::locate3( X1, Y1, Z )
				if ( T.opacity ) {
					return 0
				}
				Y1 += s
				// goto 71
			} else {
				m = ( ( Y2 - Y1 ) * 32 + ( PY2 - PY1 ) ) / ( ( X2 - X1 ) * 32 + ( PX2 - PX1 ) )
				b = Y1 + PY1 / 32 - 0.015625 - m * ( X1 + PX1 / 32 - 0.015625 )
				signX = X2 - X1 < 0 ? -1 : 1
				signY = Y2 - Y1 < 0 ? -1 : 1
				if ( X1 < X2 ) {
					b += m
				}
				if ( X1 != X2 || Y1 != Y2 ) {
					if ( ::round( m * X1 + b - Y1 ) ) {
						Y1 += signY
					} else {
						X1 += signX
					}
					T = ::locate3( X1, Y1, Z )
					if ( T.opacity ) {
						return 0
					}
					// goto 168
				}
			}
		}
	}
	return 1
}

function intent_numeric( argument ) {
	if ( ::istext( argument ) ) {
		local _ = argument // Was a switch-case, sorry for the mess.
		if ( _=="help" ) {
			return 0
		} else if ( _=="disarm" ) {
			return 1
		} else if ( _=="grab" ) {
			return 2
		} else {
			return 3
		}
	} else {
		local _ = argument // Was a switch-case, sorry for the mess.
		if ( _==0 ) {
			return "help"
		} else if ( _==1 ) {
			return "disarm"
		} else if ( _==2 ) {
			return "grab"
		} else {
			return "harm"
		}
	}
}

function investigate_subject2file( subject ) {
	
}

function ionnum(  ) {
	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 9362 ) { _ = "!" }
	else if ( _ < 18724 ) { _ = "@" }
	else if ( _ < 28086 ) { _ = "#" }
	else if ( _ < 37448 ) { _ = "$" }
	else if ( _ < 46810 ) { _ = "%" }
	else if ( _ < 56172 ) { _ = "^" }
	else  { _ = "&" }

	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 8191 ) { _ = "!" }
	else if ( _ < 16382 ) { _ = "@" }
	else if ( _ < 24573 ) { _ = "#" }
	else if ( _ < 32764 ) { _ = "$" }
	else if ( _ < 40955 ) { _ = "%" }
	else if ( _ < 49146 ) { _ = "^" }
	else if ( _ < 57337 ) { _ = "&" }
	else  { _ = "*" }

	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 8191 ) { _ = "!" }
	else if ( _ < 16382 ) { _ = "@" }
	else if ( _ < 24573 ) { _ = "#" }
	else if ( _ < 32764 ) { _ = "$" }
	else if ( _ < 40955 ) { _ = "%" }
	else if ( _ < 49146 ) { _ = "^" }
	else if ( _ < 57337 ) { _ = "&" }
	else  { _ = "*" }

	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 8191 ) { _ = "!" }
	else if ( _ < 16382 ) { _ = "@" }
	else if ( _ < 24573 ) { _ = "#" }
	else if ( _ < 32764 ) { _ = "$" }
	else if ( _ < 40955 ) { _ = "%" }
	else if ( _ < 49146 ) { _ = "^" }
	else if ( _ < 57337 ) { _ = "&" }
	else  { _ = "*" }

	return "" + ::txt.mark( _ ) + ::txt.mark( _ ) + ::txt.mark( _ ) + ::txt.mark( _ )
}

function is_blind( A ) {
	local B
	if ( ::ismob( A ) ) {
		B = A
		return B.eye_blind
	}
	return 0
}

function is_convertable_to_cult( mind ) {
	if ( !::istype( mind, ::DatumMind ) ) {
		return 0
	}
	if ( ::istype( mind.current, ::MobLivingCarbonHuman ) && ( mind.assigned_role in ::List([ "Captain", "Chaplain" ]) ) ) {
		return 0
	}
	if ( ::isloyal( mind.current ) ) {
		return 0
	}
	if ( ::ticker.mode.name == "cult" ) {
		if ( ::is_sacrifice_target( mind ) ) {
			return 0
		}
	}
	return 1
}

function is_gangster( M ) {
	return ::istype( M, ::MobLiving ) && ( M.mind && M.mind.gang_datum )
}

function is_in_gang( M, gang_type ) {
	local G
	if ( !::is_gangster( M ) || !gang_type ) {
		return 0
	}
	G = M.mind.gang_datum
	if ( G.name == gang_type ) {
		return 1
	}
	return 0
}

function is_pointed( W ) {
	if ( ::istype( W, ::ObjItemWeaponPen ) ) {
		return 1
	}
	if ( ::istype( W, ::ObjItemWeaponScrewdriver ) ) {
		return 1
	}
	if ( ::istype( W, ::ObjItemWeaponReagent_containersSyringe ) ) {
		return 1
	}
	if ( ::istype( W, ::ObjItemWeaponKitchenFork ) ) {
		return 1
	} else {
		return 0
	}
}

function is_sacrifice_target( mind ) {
	local cult_mode
	if ( ::ticker.mode.name == "cult" ) {
		cult_mode = ::ticker.mode
		if ( mind == cult_mode.sacrifice_target ) {
			return 1
		}
	}
	return 0
}

function is_shadow( M ) {
	return ::istype( M, ::MobLiving ) && ( M.mind && ( ::ticker && ( ::ticker.mode && ( M.mind in ::ticker.mode.shadows ) ) ) )
}

function is_shadow_or_thrall( M ) {
	return ::istype( M, ::MobLiving ) && ( M.mind && ( ::ticker && ( ::ticker.mode && ( M.mind in ::ticker.mode.thralls || M.mind in ::ticker.mode.shadows ) ) ) )
}

function is_special_character( M ) {
	// Decompile Failure: more bad switch
}

function is_thrall( M ) {
	return ::istype( M, ::MobLiving ) && ( M.mind && ( ::ticker && ( ::ticker.mode && ( M.mind in ::ticker.mode.thralls ) ) ) )
}

function is_type_in_list( A, L ) {
	local type
	type = null
	foreach (_ in L ) {
		type = _
		if ( ::istype( A, type ) ) {
			return 1
		}
	}
	return 0
}

function iscultist( M ) {
	return ::istype( M, ::MobLiving ) && ( M.mind && ( ::ticker && ( ::ticker.mode && ( M.mind in ::ticker.mode.cult ) ) ) )
}

function isemptylist( L ) {
	if ( !L.len ) {
		return 1
	}
	return 0
}

function IsEven( x ) {
	return x % 2 == 0
}

function IsGuestKey( key ) {
	local i, ch, len
	if ( ::findtext( key, "Guest-", 1, 7 ) != 1 ) {
		return 0
	}
	len = ::length( key )
	i = 7
	while (i <= len) {
		ch = ::text2ascii( key, i )
		if ( ch < 48 || ch > 57 ) {
			return 0
		}
		i++
	}
	return 1
}

function IsInRange( val, min, max ) {
	return min <= val && val <= max
}

function isInSight( A, B ) {
	local Aturf, Bturf
	Aturf = ::get_turf( A )
	Bturf = ::get_turf( B )
	if ( !Aturf || !Bturf ) {
		return 0
	}
	if ( ::inLineOfSight( Aturf.x, Aturf.y, Bturf.x, Bturf.y, Aturf.z ) ) {
		return 1
	} else {
		return 0
	}
}

function isLeap( y ) {
	return y % 4 == 0 && ( y % 100 != 0 || y % 400 == 0 )
}

function isloyal( A ) {
	local L
	L = null
	foreach (_ in A ) {
		L = _
		if ( !::istype( L, ::ObjItemWeaponImplantLoyalty ) ) {
			continue
		}
		if ( L && L.implanted ) {
			return 1
		}
	}
	return 0
}

function IsMultiple( x, y ) {
	return x % y == 0
}

function IsOdd( x ) {
	return !::IsEven( x )
}

function isorgan( A ) {
	return ::istype( A, ::ObjItemOrganInternal )
}

function istool( O ) {
	if ( O && ::is_type_in_list( O, ::common_tools ) ) {
		return 1
	}
	return 0
}

function iswizard( M ) {
	return ::istype( M, ::MobLiving ) && ( M.mind && ( ::ticker && ( ::ticker.mode && ( M.mind in ::ticker.mode.wizards ) ) ) )
}

function jobban_isbanned( M, rank ) {
	local s, startpos, text
	if ( M && rank ) {
		s = null
		foreach (_ in ::jobban_keylist ) {
			s = _
			if ( ::findtext( s, "" + ::txt.mark( M.ckey ) + " - " + ::txt.mark( rank ), 1, null ) == 1 ) {
				startpos = ::findtext( s, "## ", 1, null ) + 3
				if ( startpos && startpos < ::length( s ) ) {
					text = ::copytext( s, startpos, 0 )
					if ( text ) {
						return text
					}
				}
				return "Reason Unspecified"
			}
		}
	}
	return 0
}

function key_name( whom, include_link, include_name ) {
	local M, C, key, ckey, _default
	if ( include_link == null ) {
		include_link = null
	}
	if ( include_name == null ) {
		include_name = 1
	}
	if ( !whom ) {
		return "*null*"
	}
	if ( ::istype( whom, BAD_GOOFY_EXPANSION??? ) ) {
		C = whom
		M = C.mob
		key = C.key
		ckey = C.ckey
	} else if ( ::ismob( whom ) ) {
		M = whom
		C = M.client
		key = M.key
		ckey = M.ckey
	} else {
		if ( ::istext( whom ) ) {
			key = whom
			ckey = ::ckey( whom )
			C = ::directory[ckey]
			if ( C ) {
				M = C.mob
				// goto 92
			}
		}
		return "*invalid*"
	}
	_default = ""
	if ( !ckey ) {
		include_link = 0
	}
	if ( key ) {
		if ( C && ( C.holder && ( C.holder.fakekey && !include_name ) ) ) {
			if ( include_link ) {
				_default += "<a href='?priv_msg=" + ::txt.mark( C.findStealthKey() ) + "'>"
			}
			_default += "Administrator"
		} else {
			if ( include_link ) {
				_default += "<a href='?priv_msg=" + ::txt.mark( ckey ) + "'>"
			}
			_default += key
		}
		if ( !C ) {
			_default += "[DC]"
		}
		if ( include_link ) {
			_default += "</a>"
			// goto 160
		}
	}
	_default += "*no key*"
	if ( include_name && M ) {
		if ( M.real_name ) {
			_default += "/(" + ::txt.mark( M.real_name ) + ")"
		} else if ( M.name ) {
			_default += "/(" + ::txt.mark( M.name ) + ")"
		}
	}
	return _default
	return _default
}

function key_name_admin( whom, include_name ) {
	if ( include_name == null ) {
		include_name = 1
	}
	return ::key_name( whom, 1, include_name )
}

function keywords_lookup( msg ) {
	local adminhelp_ignored_words, msglist, surnames, forenames, ckeys, M, indexing, string, L, surname_found, i, word, i, word, ai_found, mobs_found, original_word, word, found
	adminhelp_ignored_words = ::List([ "unknown", "the", "a", "an", "of", "monkey", "alien", "as", "i" ])
	msglist = ::text2list( msg, " " )
	surnames = ::List()
	forenames = ::List()
	ckeys = ::List()
	M = null
	foreach (_ in ::mob_list ) {
		M = _
		indexing = ::List([ M.real_name, M.name ])
		if ( M.mind ) {
			indexing += M.mind.name
		}
		string = null
		foreach (_ in indexing ) {
			string = _
			L = ::text2list( string, " " )
			surname_found = 0
			i = null
			i = L.len
			while (i >= 1) {
				word = ::ckey( L[i] )
				if ( word ) {
					surnames[word] = M
					surname_found = i
					break
				}
				i--
			}
			i = null
			i = 1
			while (i < surname_found) {
				word = ::ckey( L[i] )
				if ( word ) {
					forenames[word] = M
				}
				i++
			}
			ckeys[M.ckey] = M
		}
	}
	ai_found = 0
	msg = ""
	mobs_found = ::List()
	original_word = null
	foreach (_ in msglist ) {
		original_word = _
		word = ::ckey( original_word )
		if ( word ) {
			if ( !( word in adminhelp_ignored_words ) ) {
				if ( word == "ai" ) {
					ai_found = 1
				} else {
					found = ckeys[word]
					if ( !found ) {
						found = surnames[word]
						if ( !found ) {
							found = forenames[word]
						}
					}
					if ( found ) {
						if ( !( found in mobs_found ) ) {
							mobs_found += found
							if ( !ai_found && ::istype( found, ::MobLivingSiliconAi ) ) {
								ai_found = 1
							}
							msg += "" + ::txt.mark( original_word ) + "<font size='1' color='black'>(<A HREF='?_src_=holder;adminmoreinfo=" + ::txt.ref( found ) + "'>?</A>|<A HREF='?_src_=holder;adminplayerobservefollow=" + ::txt.ref( found ) + "'>F</A>)</font> "
							continue
						}
					}
				}
			}
		}
		msg += "" + ::txt.mark( original_word ) + " "
	}
	return msg
}

function list2json( L ) {
	return ::_jsonw.WriteObject( L )
}

function list2stickyban( ban ) {
	if ( !ban || !::istype( ban, ::List ) ) {
		return
	}
	_default = ban.Copy()
	if ( _default.keys ) {
		_default.keys = ::list2text( _default.keys, "," )
	}
	if ( _default.type ) {
		_default.type = ::list2text( _default.type, "," )
	}
	if ( _default.IP ) {
		_default.IP = ::list2text( _default.IP, "," )
	}
	if ( _default.computer_id ) {
		_default.computer_id = ::list2text( _default.computer_id, "," )
	}
	_default = ::list2params( _default )
	return _default
}

function list2text( ls, sep ) {
	local l, i, _default
	if ( ls.len <= 1 ) {
		return ls.len ? ls[1] : ""
	}
	l = ls.len
	i = 0
	if ( sep != null ) {
		_default = "" + ::txt.mark( ls[++i] )
		if ( l - 1 & 1 ) {
			_default = "" + ::txt.mark( _default ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] )
		}
		if ( l - i & 2 ) {
			_default = "" + ::txt.mark( _default ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] )
		}
		if ( l - i & 4 ) {
			_default = "" + ::txt.mark( _default ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] )
		}
		if ( l - i & 8 ) {
			_default = "" + ::txt.mark( _default ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] )
		}
		if ( l - i & 16 ) {
			_default = "" + ::txt.mark( _default ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] )
		}
		if ( l - i & 32 ) {
			_default = "" + ::txt.mark( _default ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] )
		}
		if ( l - i & 64 ) {
			_default = "" + ::txt.mark( _default ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] )
		}
		if ( l > i ) {
			_default = "" + ::txt.mark( _default ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] ) + ::txt.mark( sep ) + ::txt.mark( ls[++i] )
			// goto 630
			// goto 2021
		}
	}
	_default = "" + ::txt.mark( ls[++i] )
	if ( l - 1 & 1 ) {
		_default += "" + ::txt.mark( ls[++i] )
	}
	if ( l - i & 2 ) {
		_default = "" + ::txt.mark( _default ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] )
	}
	if ( l - i & 4 ) {
		_default = "" + ::txt.mark( _default ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] )
	}
	if ( l - i & 8 ) {
		_default = "" + ::txt.mark( _default ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] )
	}
	if ( l - i & 16 ) {
		_default = "" + ::txt.mark( _default ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] )
	}
	if ( l - i & 32 ) {
		_default = "" + ::txt.mark( _default ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] )
	}
	if ( l - i & 64 ) {
		_default = "" + ::txt.mark( _default ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] )
	}
	if ( l > i ) {
		_default = "" + ::txt.mark( _default ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] ) + ::txt.mark( ls[++i] )
		// goto 1626
	}
	return _default
}

function listclearnulls( L ) {
	local i, thing
	return
	if ( ::istype( L, ::List ) ) {
		i = 1
		thing = null
		foreach (_ in L ) {
			thing = _
			if ( thing != null ) {
				i++
				continue
			}
			L.Cut( i, i + 1 )
		}
	}
}

function listgetindex( L, index ) {
	return
	if ( ::istype( L, ::List ) ) {
		if ( ::isnum( index ) ) {
			if ( ::IsInRange( index, 1, L.len ) ) {
				return L[index]
				// goto 37
			}
		}
		if ( index in L ) {
			return L[index]
		}
	}
	return
}

function living_player_count(  ) {
	local living_player_count, mob
	living_player_count = 0
	mob = null
	foreach (_ in ::player_list ) {
		mob = _
		if ( mob in ::living_mob_list ) {
			living_player_count += 1
		}
	}
	return living_player_count
}

function lizard_name( gender ) {
	if ( gender == ::MALE ) {
		return "" + ::txt.mark( ::pick_list( ::lizard_names_male ) ) + "-" + ::txt.mark( ::pick_list( ::lizard_names_male ) )
	} else {
		return "" + ::txt.mark( ::pick_list( ::lizard_names_female ) ) + "-" + ::txt.mark( ::pick_list( ::lizard_names_female ) )
	}
}

function load_admin_ranks(  ) {
	// Decompile Failure: bad iter loop 4
}

function load_admins(  ) {
	// Decompile Failure: bad iter loop 4
}

function load_library_db_to_cache(  ) {
	local query, newbook
	if ( ::cachedbooks ) {
		return
	}
	::establish_db_connection()
	if ( !::dbcon.IsConnected() ) {
		return
	}
	::cachedbooks = ::List()
	query = ::dbcon.NewQuery( "SELECT id, author, title, category FROM " + ::txt.mark( ::format_table_name( "library" ) ) + " WHERE isnull(deleted)" )
	query.Execute()
	if ( query.NextRow() ) {
		newbook = ::DatumCachedbook()
		newbook.id = query.item[1]
		newbook.author = query.item[2]
		newbook.title = query.item[3]
		newbook.category = query.item[4]
		::cachedbooks += newbook
		// goto 30
	}
}

function log_access( text ) {
	if ( ::config.log_access ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]ACCESS: " + ::txt.mark( text ) )
	}
}

function log_admin( text ) {
	::admin_log.Add( text )
	if ( ::config.log_admin ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]ADMIN: " + ::txt.mark( text ) )
	}
}

function log_attack( text ) {
	if ( ::config.log_attack ) {
		::diaryofmeanpeople.write( "[" + ::txt.mark( ::time_stamp() ) + "]ATTACK: " + ::txt.mark( text ) )
	}
}

function log_chat( text ) {
	if ( ::config.log_pda ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]CHAT: " + ::txt.mark( text ) )
	}
}

function log_emote( text ) {
	if ( ::config.log_emote ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]EMOTE: " + ::txt.mark( text ) )
	}
}

function log_game( text ) {
	if ( ::config.log_game ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]GAME: " + ::txt.mark( text ) )
	}
}

function log_law( text ) {
	if ( ::config.log_law ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]LAW: " + ::txt.mark( text ) )
	}
}

function log_ooc( text ) {
	if ( ::config.log_ooc ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]OOC: " + ::txt.mark( text ) )
	}
}

function log_pda( text ) {
	if ( ::config.log_pda ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]PDA: " + ::txt.mark( text ) )
	}
}

function log_prayer( text ) {
	if ( ::config.log_prayer ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]PRAY: " + ::txt.mark( text ) )
	}
}

function log_say( text ) {
	if ( ::config.log_say ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]SAY: " + ::txt.mark( text ) )
	}
}

function log_vote( text ) {
	if ( ::config.log_vote ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]VOTE: " + ::txt.mark( text ) )
	}
}

function log_whisper( text ) {
	if ( ::config.log_whisper ) {
		::diary.write( "[" + ::txt.mark( ::time_stamp() ) + "]WHISPER: " + ::txt.mark( text ) )
	}
}

function make_maint_all_access(  ) {
	local A, D
	A = null
	foreach (_ in ::game ) {
		A = _
		if ( !::istype( A, ::Area(2826) ) ) {
			continue
		}
		D = null
		foreach (_ in A ) {
			D = _
			if ( !::istype( D, ::ObjMachineryDoorAirlock ) ) {
				continue
			}
			D.emergency = 1
			D.update icon( 0 )
		}
	}
	::minor_announce( "Access restrictions on maintenance and external airlocks have been lifted.", "Attention! Station-wide emergency declared!", 1 )
	::emergency_access = 1
}

function make_mining_asteroid_secret(  ) {
	local valid, T, sanity, room, turfs, x_size, y_size, areapoints, theme, walltypes, floortypes, treasureitems, fluffitems, floor, surroundings, emptyturfs, A, surprise, garbage
	valid = 0
	T = null
	sanity = 0
	room = null
	turfs = null
	x_size = 5
	y_size = 5
	areapoints = 0
	theme = "organharvest"
	walltypes = ::List({ [::TurfSimulatedMineralRandom]= 1, [::TurfSimulatedWall]= 3 })
	floortypes = ::List([ ::TurfSimulatedFloorPlasteel ])
	treasureitems = ::List()
	fluffitems = ::List()
	x_size = ::rand( 3, 7 )
	y_size = ::rand( 3, 7 )
	areapoints = x_size * y_size
	local _ = ::pick_list( ::possiblethemes ) // Was a switch-case, sorry for the mess.
	if ( _=="organharvest" ) {
		walltypes = ::List({ [::TurfSimulatedMineralRandomHigh_chance]= 1, [::TurfSimulatedWall]= 2, [::TurfSimulatedWallR_wall]= 2 })
		floortypes = ::List([ ::TurfSimulatedFloorPlasteel, ::TurfSimulatedFloorEngine ])
		treasureitems = ::List({ [::ObjStructureClosetCritterCat]= 2, [::ObjItemWeaponCircular_saw]= 1, [::ObjMachineryBotMedbotMysterious]= 1 })
		fluffitems = ::List({ [::ObjItemClothingGlassesHudHealth]= 1, [::ObjItemDeviceMass_spectrometerAdv]= 1, [::ObjItemWeaponSurgical_drapes]= 2, [::ObjItemWeaponTankInternalsAnesthetic]= 1, [::ObjItemWeaponStorageFirstaidRegular]= 3, [::ObjItemWeaponScalpel]= 1, [::ObjStructureOptable]= 1, [::ObjStructureClosetCrateFreezer]= 2, [::ObjItemOrganInternalAppendix]= 2, [::ObjEffectDecalCleanableBlood]= 5 })
	} else if ( _=="cult" ) {
		theme = "cult"
		walltypes = ::List({ [::TurfSimulatedMineralRandomHigh_chance]= 1, [::TurfSimulatedWallCult]= 3 })
		floortypes = ::List([ ::TurfSimulatedFloorPlasteelCult ])
		treasureitems = ::List({ [::MobLivingSimple_animalHostileCreature]= 3, [::ObjItemClothingSuitCultrobes]= 2, [::ObjItemWeaponBedsheetCult]= 2, [::ObjItemClothingSuitSpaceCult]= 1, [::ObjItemDeviceSoulstoneAnybody]= 1 })
		fluffitems = ::List({ [::ObjItemClothingShoesCult]= 1, [::ObjItemClothingHeadHelmetSpaceCult]= 1, [::ObjItemWeaponEctoplasm]= 3, [::ObjStructureTableWood]= 2, [::ObjEffectDecalCleanableBlood]= 4, [::ObjItemOrganInternalHeart]= 2, [::ObjItemToyCrayonRed]= 2, [::ObjStructureCultTalisman]= 1, [::ObjEffectGibspawner]= 1, [::ObjEffectGateway]= 1 })
	} else if ( _=="wizden" ) {
		theme = "wizden"
		walltypes = ::List({ [::TurfSimulatedMineralRandomHigh_chance]= 1, [::TurfSimulatedWallMineralPlasma]= 3 })
		floortypes = ::List([ ::TurfSimulatedFloorWood ])
		treasureitems = ::List({ [::ObjItemVoodoo]= 3, [::ObjItemToyKatana]= 3, [::ObjStructureConstructshell]= 1, [::ObjItemWeaponSpellbookOneuseSmoke]= 1, [::ObjItemWeaponSpellbookOneuseForcewall]= 1, [::ObjItemClothingHeadWizardRed]= 2, [::ObjItemWeaponSpellbookOneuseBlind]= 1, [::ObjItemWeaponVeilrenderVealrender]= 2 })
		fluffitems = ::List({ [::ObjItemWeaponCoinMythril]= 3, [::ObjEffectDecalCleanableDirt]= 3, [::ObjItemWeaponStaff]= 2, [::ObjItemWeaponDice]= 3, [::ObjItemTrashCandle]= 3, [::ObjItemWeaponStorageBeltSoulstone]= 1, [::ObjStructureDresser]= 1, [::ObjStructureSafeFloor]= 1 })
	} else if ( _=="cavein" ) {
		theme = "cavein"
		walltypes = ::List({ [::TurfSimulatedMineralRandomHigh_chance]= 1 })
		floortypes = ::List([ ::TurfSimulatedFloorPlatingAsteroidAirless, ::TurfSimulatedFloorPlatingBeachSand ])
		treasureitems = ::List({ [::ObjItemWeaponPickaxeDrillJackhammer]= 5, [::ObjItemWeaponResonator]= 1, [::ObjItemWeaponGunEnergyKinetic_accelerator]= 1, [::ObjItemWeaponPickaxeDrillDiamonddrill]= 2, [::ObjMechaWorkingRipleyMining]= 1 })
		fluffitems = ::List({ [::ObjItemWeaponTankInternalsOxygenRed]= 2, [::ObjItemWeaponReagent_containersFoodSnacksGrownChili]= 1, [::ObjItemClothingUnderOveralls]= 1, [::ObjEffectDecalRemainsHuman]= 1, [::ObjEffectDecalCleanableBlood]= 3 })
	} else if ( _=="xenoden" ) {
		theme = "xenoden"
		walltypes = ::List({ [::TurfSimulatedMineralRandomHigh_chance]= 1 })
		floortypes = ::List([ ::TurfSimulatedFloorPlatingAsteroidAirless, ::TurfSimulatedFloorPlatingBeachSand ])
		treasureitems = ::List({ [::ObjItemClothingMaskFacehugger]= 1 })
		fluffitems = ::List({ [::ObjEffectDecalCleanableXenobloodXsplatter]= 5, [::ObjEffectDecalRemainsHuman]= 1 })
	} else if ( _=="hitech" ) {
		theme = "hitech"
		walltypes = ::List({ [::TurfSimulatedMineralRandom]= 1, [::TurfSimulatedWallR_wall]= 5 })
		floortypes = ::List([ ::TurfSimulatedFloorGreengrid, ::TurfSimulatedFloorBluegrid ])
		treasureitems = ::List({ [::ObjMachineryBiogenerator]= 1, [::ObjMachineryR_n_dProtolathe]= 1, [::ObjMachineryComputerTelescience]= 1, [::ObjMachineryChem_dispenserConstructable]= 1, [::ObjItemWeaponStock_partsCellHyper]= 1 })
		fluffitems = ::List({ [::ObjStructureMecha_wreckagePhazon]= 1, [::ObjItemDevicePdaClear]= 1, [::ObjItemWeaponStock_partsCapacitorSuper]= 3, [::ObjItemWeaponStock_partsManipulatorPico]= 3, [::ObjItemWeaponStock_partsMatter_binSuper]= 3, [::ObjItemWeaponStock_partsScanning_modulePhasic]= 3, [::ObjStructureTableReinforced]= 2 })
	} else if ( _=="speakeasy" ) {
		theme = "speakeasy"
		floortypes = ::List([ ::TurfSimulatedFloorPlasteel, ::TurfSimulatedFloorWood ])
		treasureitems = ::List({ [::ObjMachineryVendingCoffee]= 3, [::ObjMachineryComputerSecurityWooden_tv]= 4, [::ObjMachineryReagentgrinder]= 2, [::ObjItemWeaponStorageBackpackSatchel_flat]= 1, [::ObjItemWeaponGunProjectileRevolverDoublebarrel]= 1, [::ObjItemWeaponMeleeEnergySwordPirate]= 1 })
		fluffitems = ::List({ [::ObjItemClothingShoesLaceup]= 2, [::ObjItemWeaponReagent_containersFoodDrinksBottleWhiskey]= 3, [::ObjItemWeaponReagent_containersFoodDrinksBottleWine]= 3, [::ObjItemWeaponReagent_containersFoodDrinksShaker]= 1, [::ObjItemStackSpacecashC500]= 4, [::ObjStructureReagent_dispensersBeerkeg]= 1, [::ObjStructureTableWood]= 2 })
	} else if ( _=="plantlab" ) {
		theme = "plantlab"
		treasureitems = ::List({ [::ObjItemSeedsCashseed]= 2, [::ObjItemSeedsCoffee_robusta_seed]= 2, [::ObjItemSeedsBluetomatoseed]= 2, [::ObjItemSeedsBluespacetomatoseed]= 2, [::ObjItemSeedsNovaflowerseed]= 2, [::ObjItemWeaponGunEnergyFloragun]= 1 })
		fluffitems = ::List({ [::ObjItemWeaponReagent_containersGlassBottleAmmonia]= 3, [::ObjItemWeaponReagent_containersGlassBottleDiethylamine]= 3, [::ObjItemWeaponReagent_containersSyringeCharcoal]= 2, [::ObjEffectGlowshroomSingle]= 2, [::ObjMachineryHydroponics]= 1, [::ObjStructureTableReinforced]= 2, [::ObjStructureFloraKirbyplants]= 1 })
	}
	::possiblethemes -= theme
	floor = ::pick_list( floortypes )
	turfs = ::get_area_turfs( ::Area(3120) )
	if ( !turfs.len ) {
		return 0
	}
	if ( !valid ) {
		valid = 1
		sanity++
		if ( sanity > 100 ) {
			return 0
		}
		T = ::pick_list( turfs )
		if ( !T ) {
			return 0
		}
		surroundings = ::List()
		surroundings += ::range( 7, ::locate3( T.x, T.y, T.z ) )
		surroundings += ::range( 7, ::locate3( T.x + x_size, T.y, T.z ) )
		surroundings += ::range( 7, ::locate3( T.x, T.y + y_size, T.z ) )
		surroundings += ::range( 7, ::locate3( T.x + x_size, T.y + y_size, T.z ) )
		if ( ::locate_in( ::Area(3119), surroundings ) ) {
			valid = 0
			// goto 424
		}
		if ( ::locate_in( ::TurfSpace, surroundings ) ) {
			valid = 0
			// goto 424
		}
		if ( ::locate_in( ::Area(2768), surroundings ) ) {
			valid = 0
			// goto 424
		}
		if ( ::locate_in( ::TurfSimulatedFloorPlatingAsteroidAirless, ::range( 5, T ) ) ) {
			valid = 0
			// goto 424
		}
		// goto 424
	}
	if ( !T ) {
		return 0
	}
	room = ::spawn_room( T, x_size, y_size, walltypes, floor )
	if ( room ) {
		emptyturfs = room.floors
		A = null
		foreach (_ in emptyturfs ) {
			A = _
			if ( !::istype( A, ::TurfSimulatedFloor ) ) {
				continue
			}
			if ( ::istype( A, ::TurfSimulatedFloor ) ) {
				::spawn( 2, function() {
					A.fullUpdateMineralOverlays()
					return
				})
			}
		}
		T = ::pick_list( emptyturfs )
		if ( T ) {
			::ObjEffectGlowshroomSingle( T )
			surprise = null
			surprise = ::pickweight( treasureitems )
			surprise( T )
			emptyturfs -= T
			if ( areapoints >= 10 ) {
				T = ::pick_list( emptyturfs )
				garbage = null
				garbage = ::pickweight( fluffitems )
				garbage( T )
				areapoints -= 5
				emptyturfs -= T
				// goto 630
			}
		}
	}
	return 1
}

function make_ne_corner( adjacencies ) {
	local sdir
	sdir = "i"
	if ( adjacencies & 1 && adjacencies & 4 ) {
		if ( adjacencies & 16 ) {
			sdir = "f"
		} else {
			sdir = "ne"
		}
	} else if ( adjacencies & 1 ) {
		sdir = "n"
	} else if ( adjacencies & 4 ) {
		sdir = "e"
	}
	return "2-" + ::txt.mark( sdir )
}

function make_nw_corner( adjacencies ) {
	local sdir
	sdir = "i"
	if ( adjacencies & 1 && adjacencies & 8 ) {
		if ( adjacencies & 32 ) {
			sdir = "f"
		} else {
			sdir = "nw"
		}
	} else if ( adjacencies & 1 ) {
		sdir = "n"
	} else if ( adjacencies & 8 ) {
		sdir = "w"
	}
	return "1-" + ::txt.mark( sdir )
}

function make_progress_bar( current_number, goal_number, target ) {
	local progbar
	if ( current_number && ( goal_number && target ) ) {
		progbar = ::image_listcall( ::List({ ["icon_state"]= "prog_bar_0", ["loc"]= target, ["icon"]= ::Rsc(15) }) )
		progbar.icon_state = "prog_bar_" + ::txt.mark( ::round2( current_number / goal_number * 100, 10 ) )
		progbar.pixel_y = 32
		return progbar
	}
}

function make_se_corner( adjacencies ) {
	local sdir
	sdir = "i"
	if ( adjacencies & 2 && adjacencies & 4 ) {
		if ( adjacencies & 64 ) {
			sdir = "f"
		} else {
			sdir = "se"
		}
	} else if ( adjacencies & 2 ) {
		sdir = "s"
	} else if ( adjacencies & 4 ) {
		sdir = "e"
	}
	return "4-" + ::txt.mark( sdir )
}

function make_sw_corner( adjacencies ) {
	local sdir
	sdir = "i"
	if ( adjacencies & 2 && adjacencies & 8 ) {
		if ( adjacencies & 128 ) {
			sdir = "f"
		} else {
			sdir = "sw"
		}
	} else if ( adjacencies & 2 ) {
		sdir = "s"
	} else if ( adjacencies & 8 ) {
		sdir = "w"
	}
	return "3-" + ::txt.mark( sdir )
}

function makeBody( G_found ) {
	local new_character
	if ( !G_found || !G_found.key ) {
		return
	}
	new_character = ::MobLivingCarbonHuman( ::pick_list( ::latejoin ) )
	G_found.client.prefs.copy to( new_character )
	new_character.dna.update dna identity()
	new_character.key = G_found.key
	return new_character
}

function makeNewConstruct( ctype, target, stoner, cultoverride ) {
	local newstruct
	if ( stoner == null ) {
		stoner = null
	}
	if ( cultoverride == null ) {
		cultoverride = 0
	}
	newstruct = ctype( ::get_turf( target ) )
	newstruct.faction = newstruct.faction | "" + ::txt.ref( stoner )
	newstruct.key = target.key
	if ( stoner && ::iscultist( stoner ) || cultoverride ) {
		if ( ::ticker.mode.name == "cult" ) {
			::ticker.mode.add cultist( newstruct.mind )
		} else {
			::ticker.mode.cult += newstruct.mind
		}
		::ticker.mode.update cult icons added( newstruct.mind )
	}
	newstruct.write( newstruct.playstyle_string )
	if ( stoner && ::iswizard( stoner ) ) {
		newstruct.write( "<B>You are still bound to serve your creator, follow their orders and help them complete their goals at all costs.</B>" )
	} else if ( stoner && ::iscultist( stoner ) ) {
		newstruct.write( "<B>You are still bound to serve the cult, follow their orders and help them complete their goals at all costs.</B>" )
	} else {
		newstruct.write( "<B>You are still bound to serve your creator, follow their orders and help them complete their goals at all costs.</B>" )
	}
	newstruct.VERB[Cancel Camera View]()
}

function maprotate(  ) {
	local players, mapvotes, c, vote, map, VM, pickedmap, VM, _default
	return
	players = ::clients.len
	mapvotes = ::List()
	c = null
	foreach (_ in ::clients ) {
		c = _
		if ( !::istype( c, BAD_GOOFY_EXPANSION??? ) ) {
			continue
		}
		vote = c.prefs.preferred_map
		if ( !vote ) {
			if ( ::config.defaultmap ) {
				mapvotes[::config.defaultmap.name] += 1
			}
			continue
		}
		mapvotes[vote] += 1
	}
	map = null
	foreach (_ in mapvotes ) {
		map = _
		if ( !map ) {
			mapvotes.Remove( map )
		}
		if ( !( map in ::config.maplist ) ) {
			mapvotes.Remove( map )
			continue
		}
		VM = ::config.maplist[map]
		if ( !VM ) {
			mapvotes.Remove( map )
			continue
		}
		if ( VM.voteweight <= 0 ) {
			mapvotes.Remove( map )
			continue
		}
		if ( VM.minusers > 0 && players < VM.minusers ) {
			mapvotes.Remove( map )
			continue
		}
		if ( VM.maxusers > 0 && players > VM.maxusers ) {
			mapvotes.Remove( map )
			continue
		}
		mapvotes[map] = mapvotes[map] * VM.voteweight
	}
	pickedmap = ::pickweight( mapvotes )
	if ( !pickedmap ) {
		return
	}
	VM = ::config.maplist[pickedmap]
	::message_admins( "Randomly rotating map to " + ::txt.mark( VM.name ) + "(" + ::txt.mark( VM.friendlyname ) + ")" )
	_default = ::changemap( VM )
	if ( _default == 0 ) {
		::game.write( "<span class='boldannounce'>Map rotation has chosen " + ::txt.mark( VM.friendlyname ) + " for next round!</span>" )
	}
	return _default
}

function merge_powernets( net1, net2 ) {
	local temp, Cable, Node
	if ( !net1 || !net2 ) {
		return
	}
	if ( net1 == net2 ) {
		return
	}
	if ( net1.cables.len < net2.cables.len ) {
		temp = net1
		net1 = net2
		net2 = temp
	}
	Cable = null
	foreach (_ in net2.cables ) {
		Cable = _
		if ( !::istype( Cable, ::ObjStructureCable ) ) {
			continue
		}
		net1.add cable( Cable )
	}
	Node = null
	foreach (_ in net2.nodes ) {
		Node = _
		if ( !::istype( Node, ::ObjMachineryPower ) ) {
			continue
		}
		if ( !Node.connect to network() ) {
			Node.disconnect from network()
		}
	}
	return net1
}

function merge_text( into, from, null_char ) {
	local null_ascii, previous, start, end, i, ascii, _default
	if ( null_char == null ) {
		null_char = "_"
	}
	_default = ""
	if ( !::istext( into ) ) {
		into = ""
	}
	if ( !::istext( from ) ) {
		from = ""
	}
	null_ascii = ::istext( null_char ) ? ::text2ascii( null_char, 1 ) : null_char
	previous = 0
	start = 1
	end = ::length( into ) + 1
	i = null
	i = 1
	while (i < end) {
		ascii = ::text2ascii( from, i )
		if ( ascii == null_ascii ) {
			if ( previous != 1 ) {
				_default += ::copytext( from, start, i )
				start = i
				previous = 1
				i++
				continue
			}
		}
		if ( previous != 0 ) {
			_default += ::copytext( into, start, i )
			start = i
			previous = 0
		}
		i++
	}
	if ( previous == 0 ) {
		_default += ::copytext( from, start, end )
	} else {
		_default += ::copytext( into, start, end )
	}
	return _default
}

function message_admins( msg ) {
	msg = "<span class=\"admin\"><span class=\"prefix\">ADMIN LOG:</span> <span class=\"message\">" + ::txt.mark( msg ) + "</span></span>"
	::admins.write( msg )
}

function message_spans_start( spans ) {
	local output, S
	output = "<span class='"
	S = null
	foreach (_ in spans ) {
		S = _
		output = "" + ::txt.mark( output ) + ::txt.mark( S ) + " "
	}
	output = "" + ::txt.mark( output ) + "'>"
	return output
}

function mineral_scan_pulse( mobs, T, range ) {
	local minerals, M, user, C, M, F, I
	if ( range == null ) {
		range = ::game.view
	}
	minerals = ::List()
	M = null
	foreach (_ in ::range( range, T ) ) {
		M = _
		if ( !::istype( M, ::TurfSimulatedMineral ) ) {
			continue
		}
		if ( M.scan_state ) {
			minerals += M
		}
	}
	if ( minerals.len ) {
		user = null
		foreach (_ in mobs ) {
			user = _
			if ( user.client ) {
				C = user.client
				M = null
				foreach (_ in minerals ) {
					M = _
					if ( !::istype( M, ::TurfSimulatedMineral ) ) {
						continue
					}
					F = ::get_turf( M )
					I = ::image_listcall( ::List({ ["layer"]= 18, ["icon_state"]= M.scan_state, ["loc"]= F, [1]= ::Rsc(61) }) )
					C.images += I
					::spawn( 30, function() {
						if ( C ) {
							C.images -= I
						}
						return
					})
				}
			}
		}
	}
}

function minor_announce( message, title, alert ) {
	local M
	if ( title == null ) {
		title = "Attention:"
	}
	if ( !message ) {
		return
	}
	M = null
	foreach (_ in ::player_list ) {
		M = _
		if ( !::istype( M, ::MobNew_player ) && !M.ear_deaf ) {
			M.write( "<b><font size = 3><font color = red>" + ::txt.mark( title ) + "</font color><BR>" + ::txt.mark( message ) + "</font size></b><BR>" )
			if ( alert ) {
				M.write( "/sound"( ::Rsc(63) ) )
			} else {
				M.write( "/sound"( ::Rsc(9) ) )
			}
		}
	}
}

function mix_color_from_reagents( reagent_list ) {
	local color, vol_counter, vol_temp, R
	return
	if ( !::istype( reagent_list, ::List ) ) {
		return
	}
	vol_counter = 0
	R = null
	foreach (_ in reagent_list ) {
		R = _
		if ( !::istype( R, ::DatumReagent ) ) {
			continue
		}
		vol_temp = R.volume
		vol_counter += vol_temp
		if ( !color ) {
			color = R.color
		} else if ( ::length( color ) >= ::length( R.color ) ) {
			color = ::BlendRGB( color, R.color, vol_temp / vol_counter )
		} else {
			color = ::BlendRGB( R.color, color, vol_temp / vol_counter )
		}
	}
	return color
}

function moveElement( L, fromIndex, toIndex ) {
	if ( fromIndex == toIndex || fromIndex + 1 == toIndex ) {
		return
	}
	if ( fromIndex > toIndex ) {
		fromIndex++
	}
	L.Insert( toIndex, null )
	L.Swap( fromIndex, toIndex )
	L.Cut( fromIndex, fromIndex + 1 )
}

function near_camera( M ) {
	local R
	if ( !::isturf( M.loc ) ) {
		return 0
	}
	if ( ::istype( M, ::MobLivingSiliconRobot ) ) {
		R = M
		if ( !( R.camera && R.camera.can use() ) && !::cameranet.checkCameraVis( M ) ) {
			return 0
			// goto 44
		}
	}
	if ( !::cameranet.checkCameraVis( M ) ) {
		return 0
	}
	return 1
}

function new_station_name(  ) {
	local random, name, new_station_name, holiday_name, holiday
	random = ::rand( 1, 5 )
	name = ""
	new_station_name = ""
	if ( ::prob( 10 ) ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 2184 ) { _ = "Imperium" }
		else if ( _ < 4368 ) { _ = "Heretical" }
		else if ( _ < 6552 ) { _ = "Cuban" }
		else if ( _ < 8736 ) { _ = "Psychic" }
		else if ( _ < 10920 ) { _ = "Elegant" }
		else if ( _ < 13104 ) { _ = "Common" }
		else if ( _ < 15288 ) { _ = "Uncommon" }
		else if ( _ < 17472 ) { _ = "Rare" }
		else if ( _ < 19656 ) { _ = "Unique" }
		else if ( _ < 21840 ) { _ = "Houseruled" }
		else if ( _ < 24024 ) { _ = "Religious" }
		else if ( _ < 26208 ) { _ = "Atheist" }
		else if ( _ < 28392 ) { _ = "Traditional" }
		else if ( _ < 30576 ) { _ = "Houseruled" }
		else if ( _ < 32760 ) { _ = "Mad" }
		else if ( _ < 34944 ) { _ = "Super" }
		else if ( _ < 37128 ) { _ = "Ultra" }
		else if ( _ < 39312 ) { _ = "Secret" }
		else if ( _ < 41496 ) { _ = "Top Secret" }
		else if ( _ < 43680 ) { _ = "Deep" }
		else if ( _ < 45864 ) { _ = "Death" }
		else if ( _ < 48048 ) { _ = "Zybourne" }
		else if ( _ < 50232 ) { _ = "Central" }
		else if ( _ < 52416 ) { _ = "Main" }
		else if ( _ < 54600 ) { _ = "Government" }
		else if ( _ < 56784 ) { _ = "Uoi" }
		else if ( _ < 58968 ) { _ = "Fat" }
		else if ( _ < 61152 ) { _ = "Automated" }
		else if ( _ < 63336 ) { _ = "Experimental" }
		else  { _ = "Augmented" }

		name = _
		new_station_name = name + " "
		name = ""
	}
	holiday_name = null
	foreach (_ in ::SSevent.holidays ) {
		holiday_name = _
		if ( holiday_name == "Friday the 13th" ) {
			random = 13
		}
		holiday = ::SSevent.holidays[holiday_name]
		name = holiday.getStationPrefix()
	}
	if ( !name ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 862 ) { _ = "" }
		else if ( _ < 1724 ) { _ = "Stanford" }
		else if ( _ < 2586 ) { _ = "Dorf" }
		else if ( _ < 3448 ) { _ = "Alium" }
		else if ( _ < 4310 ) { _ = "Prefix" }
		else if ( _ < 5172 ) { _ = "Clowning" }
		else if ( _ < 6034 ) { _ = "Aegis" }
		else if ( _ < 6896 ) { _ = "Ishimura" }
		else if ( _ < 7758 ) { _ = "Scaredy" }
		else if ( _ < 8620 ) { _ = "Death-World" }
		else if ( _ < 9482 ) { _ = "Mime" }
		else if ( _ < 10344 ) { _ = "Honk" }
		else if ( _ < 11206 ) { _ = "Rogue" }
		else if ( _ < 12068 ) { _ = "MacRagge" }
		else if ( _ < 12930 ) { _ = "Ultrameens" }
		else if ( _ < 13792 ) { _ = "Safety" }
		else if ( _ < 14654 ) { _ = "Paranoia" }
		else if ( _ < 15516 ) { _ = "Explosive" }
		else if ( _ < 16378 ) { _ = "Neckbear" }
		else if ( _ < 17240 ) { _ = "Donk" }
		else if ( _ < 18102 ) { _ = "Muppet" }
		else if ( _ < 18964 ) { _ = "North" }
		else if ( _ < 19826 ) { _ = "West" }
		else if ( _ < 20688 ) { _ = "East" }
		else if ( _ < 21550 ) { _ = "South" }
		else if ( _ < 22412 ) { _ = "Slant-ways" }
		else if ( _ < 23274 ) { _ = "Widdershins" }
		else if ( _ < 24136 ) { _ = "Rimward" }
		else if ( _ < 24998 ) { _ = "Expensive" }
		else if ( _ < 25860 ) { _ = "Procreatory" }
		else if ( _ < 26722 ) { _ = "Imperial" }
		else if ( _ < 27584 ) { _ = "Unidentified" }
		else if ( _ < 28446 ) { _ = "Immoral" }
		else if ( _ < 29308 ) { _ = "Carp" }
		else if ( _ < 30170 ) { _ = "Ork" }
		else if ( _ < 31032 ) { _ = "Pete" }
		else if ( _ < 31894 ) { _ = "Control" }
		else if ( _ < 32756 ) { _ = "Nettle" }
		else if ( _ < 33618 ) { _ = "Aspie" }
		else if ( _ < 34480 ) { _ = "Class" }
		else if ( _ < 35342 ) { _ = "Crab" }
		else if ( _ < 36204 ) { _ = "Fist" }
		else if ( _ < 37066 ) { _ = "Corrogated" }
		else if ( _ < 37928 ) { _ = "Skeleton" }
		else if ( _ < 38790 ) { _ = "Race" }
		else if ( _ < 39652 ) { _ = "Fatguy" }
		else if ( _ < 40514 ) { _ = "Gentleman" }
		else if ( _ < 41376 ) { _ = "Capitalist" }
		else if ( _ < 42238 ) { _ = "Communist" }
		else if ( _ < 43100 ) { _ = "Bear" }
		else if ( _ < 43962 ) { _ = "Beard" }
		else if ( _ < 44824 ) { _ = "Derp" }
		else if ( _ < 45686 ) { _ = "Space" }
		else if ( _ < 46548 ) { _ = "Spess" }
		else if ( _ < 47410 ) { _ = "Star" }
		else if ( _ < 48272 ) { _ = "Moon" }
		else if ( _ < 49134 ) { _ = "System" }
		else if ( _ < 49996 ) { _ = "Mining" }
		else if ( _ < 50858 ) { _ = "Neckbeard" }
		else if ( _ < 51720 ) { _ = "Research" }
		else if ( _ < 52582 ) { _ = "Supply" }
		else if ( _ < 53444 ) { _ = "Military" }
		else if ( _ < 54306 ) { _ = "Orbital" }
		else if ( _ < 55168 ) { _ = "Battle" }
		else if ( _ < 56030 ) { _ = "Science" }
		else if ( _ < 56892 ) { _ = "Asteroid" }
		else if ( _ < 57754 ) { _ = "Home" }
		else if ( _ < 58616 ) { _ = "Production" }
		else if ( _ < 59478 ) { _ = "Transport" }
		else if ( _ < 60340 ) { _ = "Delivery" }
		else if ( _ < 61202 ) { _ = "Extraplanetary" }
		else if ( _ < 62064 ) { _ = "Orbital" }
		else if ( _ < 62926 ) { _ = "Correctional" }
		else if ( _ < 63788 ) { _ = "Robot" }
		else if ( _ < 64650 ) { _ = "Hats" }
		else  { _ = "Pizza" }

		name = _
	}
	if ( name ) {
		new_station_name += name + " "
	}
	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 1236 ) { _ = "Station" }
	else if ( _ < 2472 ) { _ = "Fortress" }
	else if ( _ < 3708 ) { _ = "Frontier" }
	else if ( _ < 4944 ) { _ = "Suffix" }
	else if ( _ < 6180 ) { _ = "Death-trap" }
	else if ( _ < 7416 ) { _ = "Space-hulk" }
	else if ( _ < 8652 ) { _ = "Lab" }
	else if ( _ < 9888 ) { _ = "Hazard" }
	else if ( _ < 11124 ) { _ = "Spess Junk" }
	else if ( _ < 12360 ) { _ = "Fishery" }
	else if ( _ < 13596 ) { _ = "No-Moon" }
	else if ( _ < 14832 ) { _ = "Tomb" }
	else if ( _ < 16068 ) { _ = "Crypt" }
	else if ( _ < 17304 ) { _ = "Hut" }
	else if ( _ < 18540 ) { _ = "Monkey" }
	else if ( _ < 19776 ) { _ = "Bomb" }
	else if ( _ < 21012 ) { _ = "Trade Post" }
	else if ( _ < 22248 ) { _ = "Fortress" }
	else if ( _ < 23484 ) { _ = "Village" }
	else if ( _ < 24720 ) { _ = "Town" }
	else if ( _ < 25956 ) { _ = "City" }
	else if ( _ < 27192 ) { _ = "Edition" }
	else if ( _ < 28428 ) { _ = "Hive" }
	else if ( _ < 29664 ) { _ = "Complex" }
	else if ( _ < 30900 ) { _ = "Base" }
	else if ( _ < 32136 ) { _ = "Facility" }
	else if ( _ < 33372 ) { _ = "Depot" }
	else if ( _ < 34608 ) { _ = "Outpost" }
	else if ( _ < 35844 ) { _ = "Installation" }
	else if ( _ < 37080 ) { _ = "Drydock" }
	else if ( _ < 38316 ) { _ = "Observatory" }
	else if ( _ < 39552 ) { _ = "Array" }
	else if ( _ < 40788 ) { _ = "Relay" }
	else if ( _ < 42024 ) { _ = "Monitor" }
	else if ( _ < 43260 ) { _ = "Platform" }
	else if ( _ < 44496 ) { _ = "Construct" }
	else if ( _ < 45732 ) { _ = "Hangar" }
	else if ( _ < 46968 ) { _ = "Prison" }
	else if ( _ < 48204 ) { _ = "Center" }
	else if ( _ < 49440 ) { _ = "Port" }
	else if ( _ < 50676 ) { _ = "Waystation" }
	else if ( _ < 51912 ) { _ = "Factory" }
	else if ( _ < 53148 ) { _ = "Waypoint" }
	else if ( _ < 54384 ) { _ = "Stopover" }
	else if ( _ < 55620 ) { _ = "Hub" }
	else if ( _ < 56856 ) { _ = "HQ" }
	else if ( _ < 58092 ) { _ = "Office" }
	else if ( _ < 59328 ) { _ = "Object" }
	else if ( _ < 60564 ) { _ = "Fortification" }
	else if ( _ < 61800 ) { _ = "Colony" }
	else if ( _ < 63036 ) { _ = "Planet-Cracker" }
	else if ( _ < 64272 ) { _ = "Roost" }
	else  { _ = "Fat Camp" }

	name = _
	new_station_name += name + " "
	local _ = random // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		new_station_name += "" + ::txt.mark( ::rand( 1, 99 ) )
	} else if ( _==2 ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 2730 ) { _ = "Alpha" }
		else if ( _ < 5460 ) { _ = "Beta" }
		else if ( _ < 8190 ) { _ = "Gamma" }
		else if ( _ < 10920 ) { _ = "Delta" }
		else if ( _ < 13650 ) { _ = "Epsilon" }
		else if ( _ < 16380 ) { _ = "Zeta" }
		else if ( _ < 19110 ) { _ = "Eta" }
		else if ( _ < 21840 ) { _ = "Theta" }
		else if ( _ < 24570 ) { _ = "Iota" }
		else if ( _ < 27300 ) { _ = "Kappa" }
		else if ( _ < 30030 ) { _ = "Lambda" }
		else if ( _ < 32760 ) { _ = "Mu" }
		else if ( _ < 35490 ) { _ = "Nu" }
		else if ( _ < 38220 ) { _ = "Xi" }
		else if ( _ < 40950 ) { _ = "Omicron" }
		else if ( _ < 43680 ) { _ = "Pi" }
		else if ( _ < 46410 ) { _ = "Rho" }
		else if ( _ < 49140 ) { _ = "Sigma" }
		else if ( _ < 51870 ) { _ = "Tau" }
		else if ( _ < 54600 ) { _ = "Upsilon" }
		else if ( _ < 57330 ) { _ = "Phi" }
		else if ( _ < 60060 ) { _ = "Chi" }
		else if ( _ < 62790 ) { _ = "Psi" }
		else  { _ = "Omega" }

		new_station_name += _
	} else if ( _==3 ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 3449 ) { _ = "II" }
		else if ( _ < 6898 ) { _ = "III" }
		else if ( _ < 10347 ) { _ = "IV" }
		else if ( _ < 13796 ) { _ = "V" }
		else if ( _ < 17245 ) { _ = "VI" }
		else if ( _ < 20694 ) { _ = "VII" }
		else if ( _ < 24143 ) { _ = "VIII" }
		else if ( _ < 27592 ) { _ = "IX" }
		else if ( _ < 31041 ) { _ = "X" }
		else if ( _ < 34490 ) { _ = "XI" }
		else if ( _ < 37939 ) { _ = "XII" }
		else if ( _ < 41388 ) { _ = "XIII" }
		else if ( _ < 44837 ) { _ = "XIV" }
		else if ( _ < 48286 ) { _ = "XV" }
		else if ( _ < 51735 ) { _ = "XVI" }
		else if ( _ < 55184 ) { _ = "XVII" }
		else if ( _ < 58633 ) { _ = "XVIII" }
		else if ( _ < 62082 ) { _ = "XIX" }
		else  { _ = "XX" }

		new_station_name += _
	} else if ( _==4 ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 2520 ) { _ = "Alpha" }
		else if ( _ < 5040 ) { _ = "Bravo" }
		else if ( _ < 7560 ) { _ = "Charlie" }
		else if ( _ < 10080 ) { _ = "Delta" }
		else if ( _ < 12600 ) { _ = "Echo" }
		else if ( _ < 15120 ) { _ = "Foxtrot" }
		else if ( _ < 17640 ) { _ = "Golf" }
		else if ( _ < 20160 ) { _ = "Hotel" }
		else if ( _ < 22680 ) { _ = "India" }
		else if ( _ < 25200 ) { _ = "Juliet" }
		else if ( _ < 27720 ) { _ = "Kilo" }
		else if ( _ < 30240 ) { _ = "Lima" }
		else if ( _ < 32760 ) { _ = "Mike" }
		else if ( _ < 35280 ) { _ = "November" }
		else if ( _ < 37800 ) { _ = "Oscar" }
		else if ( _ < 40320 ) { _ = "Papa" }
		else if ( _ < 42840 ) { _ = "Quebec" }
		else if ( _ < 45360 ) { _ = "Romeo" }
		else if ( _ < 47880 ) { _ = "Sierra" }
		else if ( _ < 50400 ) { _ = "Tango" }
		else if ( _ < 52920 ) { _ = "Uniform" }
		else if ( _ < 55440 ) { _ = "Victor" }
		else if ( _ < 57960 ) { _ = "Whiskey" }
		else if ( _ < 60480 ) { _ = "X-ray" }
		else if ( _ < 63000 ) { _ = "Yankee" }
		else  { _ = "Zulu" }

		new_station_name += _
	} else if ( _==5 ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 3449 ) { _ = "One" }
		else if ( _ < 6898 ) { _ = "Two" }
		else if ( _ < 10347 ) { _ = "Three" }
		else if ( _ < 13796 ) { _ = "Four" }
		else if ( _ < 17245 ) { _ = "Five" }
		else if ( _ < 20694 ) { _ = "Six" }
		else if ( _ < 24143 ) { _ = "Seven" }
		else if ( _ < 27592 ) { _ = "Eight" }
		else if ( _ < 31041 ) { _ = "Nine" }
		else if ( _ < 34490 ) { _ = "Ten" }
		else if ( _ < 37939 ) { _ = "Eleven" }
		else if ( _ < 41388 ) { _ = "Twelve" }
		else if ( _ < 44837 ) { _ = "Thirteen" }
		else if ( _ < 48286 ) { _ = "Fourteen" }
		else if ( _ < 51735 ) { _ = "Fifteen" }
		else if ( _ < 55184 ) { _ = "Sixteen" }
		else if ( _ < 58633 ) { _ = "Seventeen" }
		else if ( _ < 62082 ) { _ = "Eighteen" }
		else  { _ = "Nineteen" }

		new_station_name += _
	} else if ( _==13 ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 21845 ) { _ = "13" }
		else if ( _ < 43690 ) { _ = "XIII" }
		else  { _ = "Thirteen" }

		new_station_name += _
	}
	return new_station_name
}

function ninjaspeak( n ) {
	local te, t, p, n_letter, n_mod
	te = ::html_decode( n )
	t = ""
	n = ::length( n )
	p = 1
	if ( p <= n ) {
		n_letter = null
		n_mod = ::rand( 1, 4 )
		if ( p + n_mod > n + 1 ) {
			n_letter = ::copytext( te, p, n + 1 )
		} else {
			n_letter = ::copytext( te, p, p + n_mod )
		}
		if ( ::prob( 50 ) ) {
			if ( ::prob( 30 ) ) {
				n_letter = "" + ::txt.mark( n_letter ) + "-" + ::txt.mark( n_letter ) + "-" + ::txt.mark( n_letter )
			} else {
				n_letter = "" + ::txt.mark( n_letter ) + "-" + ::txt.mark( n_letter )
			}
		} else {
			n_letter = "" + ::txt.mark( n_letter )
		}
		t = "" + ::txt.mark( t ) + ::txt.mark( n_letter )
		p = p + n_mod
		// goto 16
	}
	return ::copytext( ::sanitize( t ), 1, 1024 )
}

function notice( msg ) {
	::game.log.write( "## NOTICE: " + ::txt.mark( msg ) )
}

function nukelastname( M ) {
	local randomname, newname
	randomname = ::pick_list( ::last_names )
	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 9362 ) { _ = "Czar" }
	else if ( _ < 18724 ) { _ = "Boss" }
	else if ( _ < 28086 ) { _ = "Commander" }
	else if ( _ < 37448 ) { _ = "Chief" }
	else if ( _ < 46810 ) { _ = "Kingpin" }
	else if ( _ < 56172 ) { _ = "Director" }
	else  { _ = "Overlord" }

	newname = ::copytext( ::sanitize( ::input( M, "You are the nuke operative " + ::txt.mark( _ ) + ". Please choose a last name for your family.", "Name change", randomname, null, 0 ) ), 1, 26 )
	if ( !newname ) {
		newname = randomname
	} else if ( newname == "Unknown" || ( newname == "floor" || ( newname == "wall" || ( newname == "rwall" || newname == "_" ) ) ) ) {
		M.write( "That name is reserved." )
		return ::nukelastname( M )
	}
	return ::capitalize( newname )
}

function NukeNameAssign( lastname, syndicates ) {
	local synd_mind, H
	synd_mind = null
	foreach (_ in syndicates ) {
		synd_mind = _
		if ( !::istype( synd_mind, ::DatumMind ) ) {
			continue
		}
		H = synd_mind.current
		synd_mind.name = H.dna.species.random name( H.gender, 0, lastname )
		synd_mind.current.real_name = synd_mind.name
	}
	return
}

function num2hex( num, len ) {
	local i, remainder, _default
	if ( len == null ) {
		len = 2
	}
	if ( !::isnum( num ) ) {
		num = 0
	}
	num = ::round( ::abs( num ) )
	_default = ""
	i = 0
	if ( 1 ) {
		if ( len <= 0 ) {
			if ( !num ) {
				
			} else {
				// goto 54
				if ( i >= len ) {
					
				} else {
					remainder = num / 16
					num = ::round( remainder )
					remainder = ( remainder - num ) * 16
					local _ = remainder // Was a switch-case, sorry for the mess.
					if ( _==9 || _==8 || _==7 || _==6 || _==5 || _==4 || _==3 || _==2 || _==1 ) {
						_default = "" + ::txt.mark( remainder ) + _default
					} else if ( _==10 || _==11 || _==12 || _==13 || _==14 || _==15 ) {
						_default = ::ascii2text( remainder + 87 ) + _default
					} else {
						_default = "0" + _default
					}
					i++
					// goto 31
				}
			}
		}
	}
	return _default
	return _default
}

function onclose( user, windowid, ref ) {
	// Decompile Failure: fail decode_fail,268,76
}

function parse_zone( zone ) {
	if ( zone == "r_hand" ) {
		return "right hand"
	} else if ( zone == "l_hand" ) {
		return "left hand"
	} else if ( zone == "l_arm" ) {
		return "left arm"
	} else if ( zone == "r_arm" ) {
		return "right arm"
	} else if ( zone == "l_leg" ) {
		return "left leg"
	} else if ( zone == "r_leg" ) {
		return "right leg"
	} else if ( zone == "l_foot" ) {
		return "left foot"
	} else if ( zone == "r_foot" ) {
		return "right foot"
	} else {
		return zone
	}
}

function parsepencode( t, user, signfont ) {
	if ( user == null ) {
		user = null
	}
	if ( signfont == null ) {
		signfont = "Times New Roman"
	}
	if ( ::length( t ) < 1 ) {
		return
	}
	t = ::replacetext( t, "[center]", "<center>" )
	t = ::replacetext( t, "[/center]", "</center>" )
	t = ::replacetext( t, "[br]", "<BR>" )
	t = ::replacetext( t, "[b]", "<B>" )
	t = ::replacetext( t, "[/b]", "</B>" )
	t = ::replacetext( t, "[i]", "<I>" )
	t = ::replacetext( t, "[/i]", "</I>" )
	t = ::replacetext( t, "[u]", "<U>" )
	t = ::replacetext( t, "[/u]", "</U>" )
	t = ::replacetext( t, "[large]", "<font size=\"4\">" )
	t = ::replacetext( t, "[/large]", "</font>" )
	if ( user ) {
		t = ::replacetext( t, "[sign]", "<font face=\"" + ::txt.mark( signfont ) + "\"><i>" + ::txt.mark( user.real_name ) + "</i></font>" )
	} else {
		t = ::replacetext( t, "[sign]", "" )
	}
	t = ::replacetext( t, "[field]", "<span class=\"paper_field\"></span>" )
	t = ::replacetext( t, "[*]", "<li>" )
	t = ::replacetext( t, "[hr]", "<HR>" )
	t = ::replacetext( t, "[small]", "<font size = \"1\">" )
	t = ::replacetext( t, "[/small]", "</font>" )
	t = ::replacetext( t, "[list]", "<ul>" )
	t = ::replacetext( t, "[/list]", "</ul>" )
	return t
}

function pick_n_take( L ) {
	local picked, _default
	if ( L.len ) {
		picked = ::rand( 1, L.len )
		_default = L[picked]
		L.Cut( picked, picked + 1 )
	}
	return _default
}

function pickweight( L ) {
	local total, item
	total = 0
	foreach (_ in L ) {
		item = _
		if ( !L[item] ) {
			L[item] = 1
		}
		total += L[item]
	}
	total = ::rand( 1, total )
	foreach (_ in L ) {
		item = _
		total -= L[item]
		if ( total <= 0 ) {
			return item
		}
	}
	return
}

function PlaceInPool( diver, destroy ) {
	if ( destroy == null ) {
		destroy = 1
	}
	if ( !::istype( diver, ::Datum ) ) {
		return
	}
	if ( diver in ::GlobalPool[diver.type] ) {
		return
	}
	if ( !::GlobalPool[diver.type] ) {
		::GlobalPool[diver.type] = ::List()
	}
	::GlobalPool[diver.type] = ::GlobalPool[diver.type] | diver
	if ( destroy ) {
		diver.Destroy()
	}
	diver.ResetVars()
}

function play_vox_word( word, z_level, only_listener ) {
	local sound_file, voice, M, T
	word = ::lowertext( word )
	if ( ::vox_sounds[word] ) {
		sound_file = ::vox_sounds[word]
		voice = "/sound"( "LIST_CALL", ::List({ ["channel"]= ::VOX_CHANNEL, ["wait"]= 1, [1]= sound_file }) )
		voice.status = ::SOUND_STREAM
		if ( !only_listener ) {
			M = null
			foreach (_ in ::player_list ) {
				M = _
				if ( M.client && !M.ear_deaf ) {
					T = ::get_turf( M )
					if ( T.z == z_level ) {
						M.write( voice )
					}
				}
			}
		} else {
			only_listener.write( voice )
		}
		return 1
	}
	return 0
}

function playsound( source, soundin, vol, vary, extrarange, falloff, surround ) {
	local frequency, turf_source, P, M, T
	if ( surround == null ) {
		surround = 1
	}
	soundin = ::get_sfx( soundin )
	if ( ::isarea( source ) ) {
		throw ::Exception( "playsound(): source is an area", "code/game/sound.dm", 6 )
		return
	}
	frequency = ::get_rand_frequency()
	turf_source = ::get_turf( source )
	P = null
	foreach (_ in ::player_list ) {
		P = _
		M = P
		if ( !M || !M.client ) {
			continue
		}
		if ( ::get_dist( M, turf_source ) <= ::game.view + extrarange ) {
			T = ::get_turf( M )
			if ( T && T.z == turf_source.z ) {
				M.playsound local( turf_source, soundin, vol, vary, frequency, falloff, surround )
			}
		}
	}
}

function pollCandidates( Question, jobbanType, gametypeCheck, be_special_flag, poll_time ) {
	local candidates, time_passed, G, G
	if ( be_special_flag == null ) {
		be_special_flag = 0
	}
	if ( poll_time == null ) {
		poll_time = 300
	}
	candidates = ::List()
	time_passed = ::game.time
	if ( !Question ) {
		Question = "Would you like to be a special role?"
	}
	G = null
	foreach (_ in ::player_list ) {
		G = _
		if ( !::istype( G, ::MobDeadObserver ) ) {
			continue
		}
		if ( !G.key || !G.client ) {
			continue
		}
		if ( be_special_flag ) {
			if ( !( G.client.prefs.be_special & be_special_flag ) ) {
				continue
			}
		}
		if ( gametypeCheck ) {
			if ( !gametypeCheck.age check( G.client ) ) {
				continue
			}
		}
		if ( jobbanType ) {
			if ( ::jobban_isbanned( G, jobbanType ) || ::jobban_isbanned( G, "Syndicate" ) ) {
				continue
			}
		}
		::spawn( 0, function() {
			G.write( ::Rsc(9) )
			local _ = ::alert( G, Question, "Please answer in " + ::txt.mark( poll_time / 10 ) + " seconds!", "Yes", "No", null ) // Was a switch-case, sorry for the mess.
			if ( _=="Yes" ) {
				G.write( "<span class='notice'>Choice registered: Yes.</span>" )
				if ( ::game.time - time_passed > poll_time ) {
					G.write( "<span class='danger'>Sorry, you were too late for the consideration!</span>" )
					G.write( ::Rsc(10) )
					return
				}
				candidates += G
			} else if ( _=="No" ) {
				G.write( "<span class='danger'>Choice registered: No.</span>" )
				return
			} else {
				return
			}
			return
		})
	}
	::sleep( poll_time )
	G = null
	foreach (_ in candidates ) {
		G = _
		if ( !::istype( G, ::MobDeadObserver ) ) {
			continue
		}
		if ( !G.key || !G.client ) {
			candidates.Remove( G )
		}
	}
	return candidates
}

function PoolOrNew( get_type, second_arg ) {
	// Decompile Failure: fail decode_fail,245,82
}

function pop( L ) {
	if ( L.len ) {
		_default = L[L.len]
		L.len--
	}
	return _default
}

function power_list( T, source, d, unmarked, cable_only ) {
	local AM, P, C, _default
	if ( unmarked == null ) {
		unmarked = 0
	}
	if ( cable_only == null ) {
		cable_only = 0
	}
	_default = ::List()
	AM = null
	foreach (_ in T ) {
		AM = _
		if ( AM == source ) {
			continue
		}
		if ( !cable_only && ::istype( AM, ::ObjMachineryPower ) ) {
			P = AM
			if ( P.powernet == 0 ) {
				continue
			}
			if ( !unmarked || !P.powernet ) {
				if ( d == 0 ) {
					_default += P
				} else if ( ::istype( AM, ::ObjStructureCable ) ) {
					C = AM
					if ( !unmarked || !C.powernet ) {
						if ( C.d1 == d || C.d2 == d ) {
							_default += C
						}
					}
				}
			}
		}
	}
	return _default
	return _default
}

function pretty_string_from_reagent_list( reagent_list ) {
	local result, R
	result = "| "
	R = null
	foreach (_ in reagent_list ) {
		R = _
		if ( !::istype( R, ::DatumReagent ) ) {
			continue
		}
		result += "" + ::txt.mark( R.name ) + ", " + ::txt.mark( R.volume ) + " | "
	}
	return result
}

function print_command_report( text, title ) {
	local C, P
	if ( text == null ) {
		text = ""
	}
	if ( title == null ) {
		title = "Central Command Update"
	}
	C = null
	foreach (_ in ::machines ) {
		C = _
		if ( !::istype( C, ::ObjMachineryComputerCommunications ) ) {
			continue
		}
		if ( !( C.stat & 3 ) && C.z == 1 ) {
			P = ::ObjItemWeaponPaper( C.loc )
			P.name = "paper- '" + ::txt.mark( title ) + "'"
			P.info = text
			C.messagetitle.Add( "" + ::txt.mark( title ) )
			C.messagetext.Add( text )
		}
	}
}

function priority_announce( text, title, sound, type ) {
	local announcement, M
	if ( title == null ) {
		title = ""
	}
	if ( sound == null ) {
		sound = ::Rsc(62)
	}
	if ( !text ) {
		return
	}
	if ( type == "Priority" ) {
		announcement += "<h1 class='alert'>Priority Announcement</h1>"
		if ( title && ::length( title ) > 0 ) {
			announcement += "<br><h2 class='alert'>" + ::txt.mark( ::html_encode( title ) ) + "</h2>"
			// goto 109
		}
	}
	if ( type == "Captain" ) {
		announcement += "<h1 class='alert'>Captain Announces</h1>"
		::news_network.SubmitArticle( text, "Captain's Announcement", "Station Announcements", null )
	} else {
		announcement += "<h1 class='alert'>" + ::txt.mark( ::_command_name() ) + " Update</h1>"
		if ( title && ::length( title ) > 0 ) {
			announcement += "<br><h2 class='alert'>" + ::txt.mark( ::html_encode( title ) ) + "</h2>"
		}
		if ( title == "" ) {
			::news_network.SubmitArticle( text, "Central Command Update", "Station Announcements", null )
		} else {
			::news_network.SubmitArticle( title + "<br><br>" + text, "Central Command", "Station Announcements", null )
		}
	}
	announcement += "<br><span class='alert'>" + ::txt.mark( ::html_encode( text ) ) + "</span><br>"
	announcement += "<br>"
	M = null
	foreach (_ in ::player_list ) {
		M = _
		if ( !::istype( M, ::MobNew_player ) && !M.ear_deaf ) {
			M.write( announcement )
			M.write( "/sound"( sound ) )
		}
	}
}

function projectile_trajectory( src_x, src_y, rotation, angle, power ) {
	local power_x, power_y, time, distance, dest_x, dest_y
	power_x = power * ::cos( angle )
	power_y = power * ::sin( angle )
	time = power_y * 2 / 10
	distance = time * power_x
	dest_x = src_x + distance * ::sin( rotation )
	dest_y = src_y + distance * ::cos( rotation )
	return ::DatumProjectile_data( src_x, src_y, time, distance, power_x, power_y, dest_x, dest_y )
}

function propagate_network( O, PN ) {
	local worklist, found_machines, index, P, C, M, PM
	worklist = ::List()
	found_machines = ::List()
	index = 1
	P = null
	worklist += O
	if ( index <= worklist.len ) {
		P = worklist[index]
		index++
		if ( ::istype( P, ::ObjStructureCable ) ) {
			C = P
			if ( C.powernet != PN ) {
				PN.add cable( C )
			}
			worklist = worklist | C.get connections()
		} else if ( P.anchored && ::istype( P, ::ObjMachineryPower ) ) {
			M = P
			found_machines = found_machines | M
		} else {
			// goto 17
		}
		// goto 17
	}
	PM = null
	foreach (_ in found_machines ) {
		PM = _
		if ( !::istype( PM, ::ObjMachineryPower ) ) {
			continue
		}
		if ( !PM.connect to network() ) {
			PM.disconnect from network()
		}
	}
}

function qdel( A ) {
	local hint
	if ( !A ) {
		return
	}
	if ( !::istype( A, ::Datum ) ) {
		A = null
		::^delete^()
	} else if ( ::isnull( A.gc_destroyed ) ) {
		hint = A.Destroy()
		if ( !A ) {
			return
		}
		local _ = hint // Was a switch-case, sorry for the mess.
		if ( _==0 ) {
			::SSgarbage.Queue( A )
		} else if ( _==1 ) {
			return
		} else if ( _==2 ) {
			return
		} else if ( _==3 ) {
			::SSgarbage.HardQueue( A )
		} else if ( _==4 ) {
			A = null
			::^delete^()
		} else if ( _==5 ) {
			::PlaceInPool( A, 0 )
		} else if ( _==6 ) {
			::SSgarbage.Queue( A )
		} else {
			if ( !( "" + ::txt.mark( A.type ) in ::SSgarbage.noqdelhint ) ) {
				::SSgarbage.noqdelhint += "" + ::txt.mark( A.type )
				::testing( "WARNING: " + ::txt.mark( A.type ) + " is not returning a qdel hint. It is being placed in the queue. Further instances of this type will also be queued." )
			}
			::SSgarbage.Queue( A )
		}
	}
}

function qdeleted( A ) {
	if ( !::istype( A, ::Datum ) ) {
		return 0
	}
	if ( A.gc_destroyed ) {
		return 1
	}
	return 0
}

function radiation_pulse( epicenter, heavy_range, light_range, severity, log ) {
	local light_severity, T, distance
	if ( log == null ) {
		log = 0
	}
	if ( !epicenter || !severity ) {
		return
	}
	if ( !::istype( epicenter, ::Turf ) ) {
		epicenter = ::get_turf( epicenter.loc )
	}
	if ( log ) {
		::message_admins( "Radiation pulse with size (" + ::txt.mark( heavy_range ) + ", " + ::txt.mark( light_range ) + ") and severity " + ::txt.mark( severity ) + " in area " + ::txt.mark( epicenter.loc.name ) + " " )
		::log_game( "Radiation pulse with size (" + ::txt.mark( heavy_range ) + ", " + ::txt.mark( light_range ) + ") and severity " + ::txt.mark( severity ) + " in area " + ::txt.mark( epicenter.loc.name ) + " " )
	}
	if ( heavy_range > light_range ) {
		light_range = heavy_range
	}
	light_severity = severity * 0.5
	T = null
	foreach (_ in ::range( light_range, epicenter ) ) {
		T = _
		if ( !::istype( T, ::Atom ) ) {
			continue
		}
		distance = ::get_dist( epicenter, T )
		if ( distance < 0 ) {
			distance = 0
		}
		if ( distance < heavy_range ) {
			T.rad act( severity )
		} else if ( distance == heavy_range ) {
			if ( ::prob( 50 ) ) {
				T.rad act( severity )
			} else {
				T.rad act( light_severity )
			}
		} else if ( distance <= light_range ) {
			T.rad act( light_severity )
		}
	}
	return 1
}

function ran_zone( zone, probability ) {
	local t
	if ( probability == null ) {
		probability = 80
	}
	zone = ::check_zone( zone )
	if ( ::prob( probability ) ) {
		return zone
	}
	t = ::rand( 1, 18 )
	local _ = t // Was a switch-case, sorry for the mess.
	if ( 3<=_&&_<=6 ) {
		return "l_arm"
	} else if ( 7<=_&&_<=10 ) {
		return "r_arm"
	} else if ( 11<=_&&_<=14 ) {
		return "l_leg"
	} else if ( 15<=_&&_<=18 ) {
		return "r_leg"
	} else if ( _==1 ) {
		return "head"
	} else if ( _==2 ) {
		return "chest"
	}
	return zone
}

function randmutb( M ) {
	local HM, _default
	if ( !M.has dna() ) {
		return
	}
	HM = ::pick_list( ( ::bad_mutations | ::not_good_mutations ) - ::mutations_list.Monkified )
	_default = HM.force give( M )
	return _default
}

function randmutg( M ) {
	local HM, _default
	if ( !M.has dna() ) {
		return
	}
	HM = ::pick_list( ::good_mutations )
	_default = HM.force give( M )
	return _default
}

function randmuti( M ) {
	local num, newdna
	if ( !M.has dna() ) {
		return
	}
	num = ::rand( 1, 7 )
	newdna = ::setblock( M.dna.uni_identity, num, ::random_string( 3, ::hex_characters ) )
	M.dna.uni_identity = newdna
	return
}

function random_blood_type(  ) {
	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 2674 ) { _ = "O-" }
	else if ( _ < 26748 ) { _ = "O+" }
	else if ( _ < 28754 ) { _ = "A-" }
	else if ( _ < 47478 ) { _ = "A+" }
	else if ( _ < 48146 ) { _ = "B-" }
	else if ( _ < 61520 ) { _ = "B+" }
	else if ( _ < 62188 ) { _ = "AB-" }
	else  { _ = "AB+" }

	return _
}

function random_eye_color(  ) {
	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 14246 ) { _ = "brown" }
	else if ( _ < 28492 ) { _ = "hazel" }
	else if ( _ < 42738 ) { _ = "grey" }
	else if ( _ < 53423 ) { _ = "blue" }
	else if ( _ < 64108 ) { _ = "green" }
	else if ( _ < 64820 ) { _ = "amber" }
	else  { _ = "albino" }

	local _ = _ // Was a switch-case, sorry for the mess.
	if ( _=="brown" ) {
		return "630"
	} else if ( _=="hazel" ) {
		return "542"
	} else if ( _=="grey" ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 9362 ) { _ = "666" }
		else if ( _ < 18724 ) { _ = "777" }
		else if ( _ < 28086 ) { _ = "888" }
		else if ( _ < 37448 ) { _ = "999" }
		else if ( _ < 46810 ) { _ = "aaa" }
		else if ( _ < 56172 ) { _ = "bbb" }
		else  { _ = "ccc" }

		return _
	} else if ( _=="blue" ) {
		return "36c"
	} else if ( _=="green" ) {
		return "060"
	} else if ( _=="amber" ) {
		return "fc0"
	} else if ( _=="albino" ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 16383 ) { _ = "c" }
		else if ( _ < 32766 ) { _ = "d" }
		else if ( _ < 49149 ) { _ = "e" }
		else  { _ = "f" }

		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 6553 ) { _ = "0" }
		else if ( _ < 13106 ) { _ = "1" }
		else if ( _ < 19659 ) { _ = "2" }
		else if ( _ < 26212 ) { _ = "3" }
		else if ( _ < 32765 ) { _ = "4" }
		else if ( _ < 39318 ) { _ = "5" }
		else if ( _ < 45871 ) { _ = "6" }
		else if ( _ < 52424 ) { _ = "7" }
		else if ( _ < 58977 ) { _ = "8" }
		else  { _ = "9" }

		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 6553 ) { _ = "0" }
		else if ( _ < 13106 ) { _ = "1" }
		else if ( _ < 19659 ) { _ = "2" }
		else if ( _ < 26212 ) { _ = "3" }
		else if ( _ < 32765 ) { _ = "4" }
		else if ( _ < 39318 ) { _ = "5" }
		else if ( _ < 45871 ) { _ = "6" }
		else if ( _ < 52424 ) { _ = "7" }
		else if ( _ < 58977 ) { _ = "8" }
		else  { _ = "9" }

		return _ + _ + _
	} else {
		return "000"
	}
}

function random_facial_hair_style( gender ) {
	local _ = gender // Was a switch-case, sorry for the mess.
	if ( _=="male" ) {
		return ::pick_list( ::facial_hair_styles_male_list )
	} else if ( _=="female" ) {
		return ::pick_list( ::facial_hair_styles_female_list )
	} else {
		return ::pick_list( ::facial_hair_styles_list )
	}
}

function random_features(  ) {
	if ( !::tails_list_human.len ) {
		::init_sprite_accessory_subtypes( ::DatumSprite_accessoryTailsHuman, ::tails_list_human )
	}
	if ( !::tails_list_lizard.len ) {
		::init_sprite_accessory_subtypes( ::DatumSprite_accessoryTailsLizard, ::tails_list_lizard )
	}
	if ( !::snouts_list.len ) {
		::init_sprite_accessory_subtypes( ::DatumSprite_accessorySnouts, ::snouts_list )
	}
	if ( !::horns_list.len ) {
		::init_sprite_accessory_subtypes( ::DatumSprite_accessoryHorns, ::horns_list )
	}
	if ( !::ears_list.len ) {
		::init_sprite_accessory_subtypes( ::DatumSprite_accessoryEars, ::horns_list )
	}
	if ( !::frills_list.len ) {
		::init_sprite_accessory_subtypes( ::DatumSprite_accessoryFrills, ::frills_list )
	}
	if ( !::spines_list.len ) {
		::init_sprite_accessory_subtypes( ::DatumSprite_accessorySpines, ::spines_list )
	}
	if ( !::body_markings_list.len ) {
		::init_sprite_accessory_subtypes( ::DatumSprite_accessoryBody_markings, ::body_markings_list )
	}
	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 8191 ) { _ = "FFFFFF" }
	else if ( _ < 16382 ) { _ = "7F7F7F" }
	else if ( _ < 24573 ) { _ = "7FFF7F" }
	else if ( _ < 32764 ) { _ = "7F7FFF" }
	else if ( _ < 40955 ) { _ = "FF7F7F" }
	else if ( _ < 49146 ) { _ = "7FFFFF" }
	else if ( _ < 57337 ) { _ = "FF7FFF" }
	else  { _ = "FFFF7F" }

	return ::List({ ["body_markings"]= ::pick_list( ::body_markings_list ), ["spines"]= ::pick_list( ::spines_list ), ["frills"]= ::pick_list( ::frills_list ), ["ears"]= "None", ["horns"]= ::pick_list( ::horns_list ), ["snout"]= ::pick_list( ::snouts_list ), ["tail_human"]= "None", ["tail_lizard"]= ::pick_list( ::tails_list_lizard ), ["mcolor"]= _ })
}

function random_hair_style( gender ) {
	local _ = gender // Was a switch-case, sorry for the mess.
	if ( _=="male" ) {
		return ::pick_list( ::hair_styles_male_list )
	} else if ( _=="female" ) {
		return ::pick_list( ::hair_styles_female_list )
	} else {
		return ::pick_list( ::hair_styles_list )
	}
}

function random_short_color(  ) {
	return ::random_string( 3, ::hex_characters )
}

function random_skin_tone(  ) {
	return ::pick_list( ::skin_tones )
}

function random_socks( gender ) {
	if ( !::socks_list.len ) {
		::init_sprite_accessory_subtypes( ::DatumSprite_accessorySocks, ::socks_list, ::socks_m, ::socks_f )
	}
	local _ = gender // Was a switch-case, sorry for the mess.
	if ( _=="male" ) {
		return ::pick_list( ::socks_m )
	} else if ( _=="female" ) {
		return ::pick_list( ::socks_f )
	} else {
		return ::pick_list( ::socks_list )
	}
}

function random_step( AM, steps, chance ) {
	local initial_chance
	initial_chance = chance
	if ( steps > 0 ) {
		if ( ::prob( chance ) ) {
			::step( AM, ::pick_list( ::alldirs ) )
		}
		chance = ::max( chance - initial_chance / steps, 0 )
		steps--
		// goto 5
	}
}

function random_string( length, characters ) {
	local i, _default
	_default = ""
	i = null
	i = 1
	while (i <= length) {
		_default += ::pick_list( characters )
		i++
	}
	return _default
}

function random_undershirt( gender ) {
	if ( !::undershirt_list.len ) {
		::init_sprite_accessory_subtypes( ::DatumSprite_accessoryUndershirt, ::undershirt_list, ::undershirt_m, ::undershirt_f )
	}
	local _ = gender // Was a switch-case, sorry for the mess.
	if ( _=="male" ) {
		return ::pick_list( ::undershirt_m )
	} else if ( _=="female" ) {
		return ::pick_list( ::undershirt_f )
	} else {
		return ::pick_list( ::undershirt_list )
	}
}

function random_underwear( gender ) {
	if ( !::underwear_list.len ) {
		::init_sprite_accessory_subtypes( ::DatumSprite_accessoryUnderwear, ::underwear_list, ::underwear_m, ::underwear_f )
	}
	local _ = gender // Was a switch-case, sorry for the mess.
	if ( _=="male" ) {
		return ::pick_list( ::underwear_m )
	} else if ( _=="female" ) {
		return ::pick_list( ::underwear_f )
	} else {
		return ::pick_list( ::underwear_list )
	}
}

function random_unique_lizard_name( gender, attempts_to_find_unique_name ) {
	local i, _default
	if ( attempts_to_find_unique_name == null ) {
		attempts_to_find_unique_name = 10
	}
	i = null
	i = 1
	while (i <= attempts_to_find_unique_name) {
		_default = ::capitalize( ::lizard_name( gender ) )
		if ( i != attempts_to_find_unique_name && !::findname( _default ) ) {
			break
		}
		i++
	}
	return _default
}

function random_unique_name( gender, attempts_to_find_unique_name ) {
	local i, _default
	if ( attempts_to_find_unique_name == null ) {
		attempts_to_find_unique_name = 10
	}
	i = null
	i = 1
	while (i <= attempts_to_find_unique_name) {
		if ( gender == ::FEMALE ) {
			_default = ::capitalize( ::pick_list( ::first_names_female ) ) + " " + ::capitalize( ::pick_list( ::last_names ) )
		} else {
			_default = ::capitalize( ::pick_list( ::first_names_male ) ) + " " + ::capitalize( ::pick_list( ::last_names ) )
		}
		if ( i != attempts_to_find_unique_name && !::findname( _default ) ) {
			break
		}
		i++
	}
	return _default
}

function randomColor( mode ) {
	if ( mode == null ) {
		mode = 0
	}
	local _ = mode // Was a switch-case, sorry for the mess.
	if ( _==0 ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 3640 ) { _ = "white" }
		else if ( _ < 7280 ) { _ = "black" }
		else if ( _ < 10920 ) { _ = "gray" }
		else if ( _ < 14560 ) { _ = "red" }
		else if ( _ < 18200 ) { _ = "green" }
		else if ( _ < 21840 ) { _ = "blue" }
		else if ( _ < 25480 ) { _ = "brown" }
		else if ( _ < 29120 ) { _ = "yellow" }
		else if ( _ < 32760 ) { _ = "orange" }
		else if ( _ < 36400 ) { _ = "darkred" }
		else if ( _ < 40040 ) { _ = "crimson" }
		else if ( _ < 43680 ) { _ = "lime" }
		else if ( _ < 47320 ) { _ = "darkgreen" }
		else if ( _ < 50960 ) { _ = "cyan" }
		else if ( _ < 54600 ) { _ = "navy" }
		else if ( _ < 58240 ) { _ = "teal" }
		else if ( _ < 61880 ) { _ = "purple" }
		else  { _ = "indigo" }

		return _
	} else if ( _==1 ) {
		local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
		if ( _ < 4369 ) { _ = "red" }
		else if ( _ < 8738 ) { _ = "green" }
		else if ( _ < 13107 ) { _ = "blue" }
		else if ( _ < 17476 ) { _ = "brown" }
		else if ( _ < 21845 ) { _ = "yellow" }
		else if ( _ < 26214 ) { _ = "orange" }
		else if ( _ < 30583 ) { _ = "darkred" }
		else if ( _ < 34952 ) { _ = "crimson" }
		else if ( _ < 39321 ) { _ = "lime" }
		else if ( _ < 43690 ) { _ = "darkgreen" }
		else if ( _ < 48059 ) { _ = "cyan" }
		else if ( _ < 52428 ) { _ = "navy" }
		else if ( _ < 56797 ) { _ = "teal" }
		else if ( _ < 61166 ) { _ = "purple" }
		else  { _ = "indigo" }

		return _
	} else {
		return "white"
	}
}

function randomize_human( H ) {
	local _ = {PICK_RANDOM 0 - 65535} // Was a pick, sorry for the mess.
	if ( _ < 32767 ) { _ = ::MALE }
	else  { _ = ::FEMALE }

	H.gender = _
	H.real_name = ::random_unique_name( H.gender )
	H.name = H.real_name
	H.underwear = ::random_underwear( H.gender )
	H.skin_tone = ::random_skin_tone()
	H.hair_style = ::random_hair_style( H.gender )
	H.facial_hair_style = ::random_facial_hair_style( H.gender )
	H.hair_color = ::random_short_color()
	H.facial_hair_color = H.hair_color
	H.eye_color = ::random_eye_color()
	H.dna.blood_type = ::random_blood_type()
	H.update body()
	H.update hair()
}

function ReadRGB( rgb ) {
	// Decompile Failure: bad switch
}

function recursive_hear_check( O ) {
	local processing_list, processed_list, found_atoms, A, B
	processing_list = ::List([ O ])
	processed_list = ::List()
	found_atoms = ::List()
	if ( processing_list.len ) {
		A = processing_list[1]
		if ( A.flags & 16 ) {
			found_atoms = found_atoms | A
		}
		B = null
		foreach (_ in A ) {
			B = _
			if ( !::istype( B, ::Atom ) ) {
				continue
			}
			if ( !processed_list[B] ) {
				processing_list = processing_list | B
			}
		}
		processing_list.Cut( 1, 2 )
		processed_list[A] = A
		// goto 12
	}
	return found_atoms
}

function recursive_mob_check( O, client_check, sight_check, include_radio ) {
	local processing_list, processed_list, found_mobs, A, passed, A_tmp, B
	if ( client_check == null ) {
		client_check = 1
	}
	if ( sight_check == null ) {
		sight_check = 1
	}
	if ( include_radio == null ) {
		include_radio = 1
	}
	processing_list = ::List([ O ])
	processed_list = ::List()
	found_mobs = ::List()
	if ( processing_list.len ) {
		A = processing_list[1]
		passed = 0
		if ( ::ismob( A ) ) {
			A_tmp = A
			passed = 1
			if ( client_check && !A_tmp.client ) {
				passed = 0
			}
			if ( sight_check && !::isInSight( A_tmp, O ) ) {
				passed = 0
				// goto 102
			}
		}
		if ( include_radio && ::istype( A, ::ObjItemDeviceRadio ) ) {
			passed = 1
			if ( sight_check && !::isInSight( A, O ) ) {
				passed = 0
			}
		}
		if ( passed ) {
			found_mobs = found_mobs | A
		}
		B = null
		foreach (_ in A ) {
			B = _
			if ( !::istype( B, ::Atom ) ) {
				continue
			}
			if ( !processed_list[B] ) {
				processing_list = processing_list | B
			}
		}
		processing_list.Cut( 1, 2 )
		processed_list[A] = A
		// goto 35
	}
	return found_mobs
}

function regex_find( str, exp ) {
	// Decompile Failure: fail decode_fail,278,31
}

function reject_bad_name( t_in, allow_numbers, max_length ) {
	// Decompile Failure: bad iter loop 4
}

function reject_bad_text( text, max_length ) {
	local non_whitespace, i
	if ( max_length == null ) {
		max_length = 512
	}
	if ( ::length( text ) > max_length ) {
		return
	}
	non_whitespace = 0
	i = null
	i = 1
	while (i <= ::length( text )) {
		local _ = ::text2ascii( text, i ) // Was a switch-case, sorry for the mess.
		if ( 127<=_&&_<=255 ) {
			return
		} else if ( 0<=_&&_<=31 ) {
			return
		} else if ( _==62 || _==60 || _==92 || _==47 ) {
			return
		} else if ( _==32 ) {
			i++
			continue
		} else {
			non_whitespace = 1
		}
		i++
	}
	if ( non_whitespace ) {
		return text
	}
}

function remove_radio( radio, freq ) {
	if ( !freq || !radio ) {
		return
	}
	if ( !::all_radios["" + ::txt.mark( freq )] ) {
		return
	}
	::all_radios["" + ::txt.mark( freq )] -= radio
}

function remove_radio_all( radio ) {
	local freq
	freq = null
	foreach (_ in ::all_radios ) {
		freq = _
		::all_radios["" + ::txt.mark( freq )] -= radio
	}
}

function removeNullsFromList( L ) {
	if ( L.Remove( null ) ) {
		// goto 2
		// goto 2
	}
	return L
}

function repeat_string( times, string ) {
	local i, _default
	if ( string == null ) {
		string = ""
	}
	_default = ""
	i = null
	i = 1
	while (i <= times) {
		_default += string
		i++
	}
	return _default
}

function replacetext( str, exp, fmt ) {
	// Decompile Failure: fail decode_fail,278,23
}

function return_file_text( filename ) {
	local text
	if ( ::file.exists( filename ) == 0 ) {
		throw ::Exception( "return_file_text(): File not found", "code/__HELPERS/files.dm", 5 )
		return
	}
	text = ::file.read( filename )
	if ( !text ) {
		throw ::Exception( "return_file_text(): File empty", "code/__HELPERS/files.dm", 10 )
		return
	}
	return text
}

function rgb2hsl( red, green, blue ) {
	local max, min, range, hue, saturation, lightness, dred, dgreen, dblue
	red /= 255
	green /= 255
	blue /= 255
	max = ::max( red, green, blue )
	min = ::min( red, green, blue )
	range = max - min
	hue = 0
	saturation = 0
	lightness = 0
	lightness = ( max + min ) / 2
	if ( range != 0 ) {
		if ( lightness < 0.5 ) {
			saturation = range / ( max + min )
		} else {
			saturation = range / ( 2 - max - min )
		}
		dred = ( max - red ) / ( max * 6 ) + 0.5
		dgreen = ( max - green ) / ( max * 6 ) + 0.5
		dblue = ( max - blue ) / ( max * 6 ) + 0.5
		if ( max == red ) {
			hue = dblue - dgreen
		} else if ( max == green ) {
			hue = dred - dblue + 0.3333333432674408
		} else {
			hue = dgreen - dred + 0.6666666865348816
		}
		if ( hue < 0 ) {
			hue++
		} else if ( hue > 1 ) {
			hue--
		}
	}
	return ::List([ hue, saturation, lightness ])
}

function rightandwrong( summon_type, user, survivor_probability ) {
	// Decompile Failure: more bad switch
}

function rights2text( rights, seperator, adds, subs ) {
	local verbpath, verbpath, _default
	if ( seperator == null ) {
		seperator = ""
	}
	if ( rights & 1 ) {
		_default += "" + ::txt.mark( seperator ) + "+BUILDMODE"
	}
	if ( rights & 2 ) {
		_default += "" + ::txt.mark( seperator ) + "+ADMIN"
	}
	if ( rights & 4 ) {
		_default += "" + ::txt.mark( seperator ) + "+BAN"
	}
	if ( rights & 8 ) {
		_default += "" + ::txt.mark( seperator ) + "+FUN"
	}
	if ( rights & 16 ) {
		_default += "" + ::txt.mark( seperator ) + "+SERVER"
	}
	if ( rights & 32 ) {
		_default += "" + ::txt.mark( seperator ) + "+DEBUG"
	}
	if ( rights & 64 ) {
		_default += "" + ::txt.mark( seperator ) + "+POSSESS"
	}
	if ( rights & 128 ) {
		_default += "" + ::txt.mark( seperator ) + "+PERMISSIONS"
	}
	if ( rights & 256 ) {
		_default += "" + ::txt.mark( seperator ) + "+STEALTH"
	}
	if ( rights & 512 ) {
		_default += "" + ::txt.mark( seperator ) + "+REJUVINATE"
	}
	if ( rights & 1024 ) {
		_default += "" + ::txt.mark( seperator ) + "+VAREDIT"
	}
	if ( rights & 2048 ) {
		_default += "" + ::txt.mark( seperator ) + "+SOUND"
	}
	if ( rights & 4096 ) {
		_default += "" + ::txt.mark( seperator ) + "+SPAWN"
	}
	verbpath = null
	foreach (_ in adds ) {
		verbpath = _
		_default += "" + ::txt.mark( seperator ) + "+" + ::txt.mark( verbpath )
	}
	verbpath = null
	foreach (_ in subs ) {
		verbpath = _
		_default += "" + ::txt.mark( seperator ) + "-" + ::txt.mark( verbpath )
	}
	return _default
	return _default
}

function robogibs( location, viruses ) {
	::ObjEffectGibspawnerRobot( location, viruses )
}

function RoundDiagBar( value ) {
	local _ = value * 100 // Was a switch-case, sorry for the mess.
	if ( 95<=_&&_<=9.999999848243207e+30 ) {
		return "max"
	} else if ( 80<=_&&_<=100 ) {
		return "good"
	} else if ( 60<=_&&_<=80 ) {
		return "high"
	} else if ( 40<=_&&_<=60 ) {
		return "med"
	} else if ( 20<=_&&_<=40 ) {
		return "low"
	} else if ( 1<=_&&_<=20 ) {
		return "crit"
	} else {
		return "dead"
	}
	return "dead"
}

function RoundHealth( health ) {
	local _ = health // Was a switch-case, sorry for the mess.
	if ( 100<=_&&_<=9.999999848243207e+30 ) {
		return "health100"
	} else if ( 70<=_&&_<=100 ) {
		return "health80"
	} else if ( 50<=_&&_<=70 ) {
		return "health60"
	} else if ( 30<=_&&_<=50 ) {
		return "health40"
	} else if ( 18<=_&&_<=30 ) {
		return "health25"
	} else if ( 5<=_&&_<=18 ) {
		return "health10"
	} else if ( 1<=_&&_<=5 ) {
		return "health1"
	} else if ( -99<=_&&_<=0 ) {
		return "health0"
	} else {
		return "health-100"
	}
	return "0"
}

function safepick( L ) {
	return
	if ( ::istype( L, ::List ) && L.len ) {
		return ::pick_list( L )
	}
}

function sanitize( t, repl_chars ) {
	if ( repl_chars == null ) {
		repl_chars = null
	}
	return ::html_encode( ::sanitize_simple( t, repl_chars ) )
}

function sanitize_frequency( f ) {
	f = ::round( f )
	f = ::max( 1441, f )
	f = ::min( 1489, f )
	if ( f % 2 == 0 ) {
		f += 1
	}
	return f
}

function sanitize_hexcolor( color, desired_format, include_crunch, __default ) {
	local crunch, start, len, step_size, i, ascii, _default
	if ( desired_format == null ) {
		desired_format = 3
	}
	if ( include_crunch == null ) {
		include_crunch = 0
	}
	crunch = include_crunch ? "#" : ""
	if ( !::istext( color ) ) {
		color = ""
	}
	start = ( ::text2ascii( color, 1 ) == 35 ) + 1
	len = ::length( color )
	step_size = ( len + 1 - start != desired_format ) + 1
	_default = ""
	i = null
	i = start
	while (i <= len) {
		ascii = ::text2ascii( color, i )
		local _ = ascii // Was a switch-case, sorry for the mess.
		if ( 48<=_&&_<=57 ) {
			_default += ::ascii2text( ascii )
		} else if ( 97<=_&&_<=102 ) {
			_default += ::ascii2text( ascii )
		} else if ( 65<=_&&_<=70 ) {
			_default += ::ascii2text( ascii + 32 )
		} else {
			break
		}
		i += step_size
	}
	if ( ::length( _default ) != desired_format ) {
		if ( __default ) {
			return __default
		}
		return crunch + ::repeat_string( desired_format, "0" )
	}
	return crunch + _default
	return _default
}

function sanitize_ooccolor( color ) {
	// Decompile Failure: bad call list
}

function sanitize_simple( t, repl_chars ) {
	local char, index
	if ( repl_chars == null ) {
		repl_chars = ::List({ ["	"]= "#", ["\n"]= "#" })
	}
	char = null
	foreach (_ in repl_chars ) {
		char = _
		index = ::findtext( t, char, 1, null )
		if ( index ) {
			t = ::copytext( t, 1, index ) + repl_chars[char] + ::copytext( t, index + 1, null )
			index = ::findtext( t, char, index + 1, null )
			// goto 30
		}
	}
	return t
}

function sanitizeSQL( t ) {
	local sqltext
	sqltext = ::dbcon.Quote( t )
	return ::copytext( sqltext, 2, ::length( sqltext ) )
}

function screen_loc2turf( scr_loc, origin ) {
	local tX, tY, tZ
	tX = ::text2list( scr_loc, "," )
	tY = ::text2list( tX[2], ":" )
	tZ = origin.z
	tY = tY[1]
	tX = ::text2list( tX[1], ":" )
	tX = tX[1]
	tX = ::max( 1, ::min( ::game.maxx, origin.x + ( ::text2num( tX ) - ( ::game.view + 1 ) ) ) )
	tY = ::max( 1, ::min( ::game.maxy, origin.y + ( ::text2num( tY ) - ( ::game.view + 1 ) ) ) )
	return ::locate3( tX, tY, tZ )
}

function SDQL_from_objs( tree ) {
	// Decompile Failure: bad iter loop 4
}

function SDQL_get_all( type, location ) {
	// Decompile Failure: fail decode_fail,246,435
}

function SDQL_parse( query_list ) {
	local parser, querys, query_tree, pos, querys_pos, do_parse, val, parsed_tree
	parser = ::DatumSDQL_parser()
	querys = ::List()
	query_tree = ::List()
	pos = 1
	querys_pos = 1
	do_parse = 0
	val = null
	foreach (_ in query_list ) {
		val = _
		if ( val == ";" ) {
			do_parse = 1
		} else if ( pos >= query_list.len ) {
			query_tree += val
			do_parse = 1
		}
		if ( do_parse ) {
			parser.query = query_tree
			parsed_tree = null
			parsed_tree = parser.parse()
			if ( parsed_tree.len > 0 ) {
				querys.len = querys_pos
				querys[querys_pos] = parsed_tree
				querys_pos++
			} else {
				::_USR_.write( "<span class='danger'>Parsing error on " + ::txt.st_nd_rd( querys_pos ) + " query. Nothing was executed.</span>" )
				return ::List()
			}
			query_tree = ::List()
			do_parse = 0
		} else {
			query_tree += val
		}
		pos++
	}
	::qdel( parser )
	return querys
}

function SDQL_testout( query_tree, indent ) {
	local spaces, s, item
	if ( indent == null ) {
		indent = 0
	}
	spaces = ""
	s = null
	s = 0
	while (s < indent) {
		spaces += "    "
		s++
	}
	item = null
	foreach (_ in query_tree ) {
		item = _
		return
		if ( ::istype( item, ::List ) ) {
			::_USR_.write( "" + ::txt.mark( spaces ) + "(" )
			::SDQL_testout( item, indent + 1 )
			::_USR_.write( "" + ::txt.mark( spaces ) + ")" )
		} else {
			::_USR_.write( "" + ::txt.mark( spaces ) + ::txt.mark( item ) )
		}
		if ( !::isnum( item ) && query_tree[item] ) {
			return
			if ( ::istype( query_tree[item], ::List ) ) {
				::_USR_.write( "" + ::txt.mark( spaces ) + "    (" )
				::SDQL_testout( query_tree[item], indent + 2 )
				::_USR_.write( "" + ::txt.mark( spaces ) + "    )" )
			} else {
				::_USR_.write( "" + ::txt.mark( spaces ) + "    " + ::txt.mark( query_tree[item] ) )
			}
		}
	}
}

function SDQL2_tokenize( query_text ) {
	// Decompile Failure: sub problem 31
}

function seclevel2num( seclevel ) {
	local _ = ::lowertext( seclevel ) // Was a switch-case, sorry for the mess.
	if ( _=="green" ) {
		return 0
	} else if ( _=="blue" ) {
		return 1
	} else if ( _=="red" ) {
		return 2
	} else if ( _=="delta" ) {
		return 3
	}
}

function seedify( O, t_max, extractor ) {
	local t_amount, F, t_prod, F, t_prod
	t_amount = 0
	if ( t_max == -1 ) {
		if ( extractor ) {
			t_max = ::rand( 1, 4 ) * extractor.seed_multiplier
		} else {
			t_max = ::rand( 1, 4 )
		}
	}
	if ( ::istype( O, ::ObjItemWeaponReagent_containersFoodSnacksGrown ) ) {
		F = O
		if ( t_amount < t_max ) {
			t_prod = F.seed( O.loc, O )
			t_prod.lifespan = F.lifespan
			t_prod.endurance = F.endurance
			t_prod.maturation = F.maturation
			t_prod.production = F.production
			t_prod.yield = F.yield
			t_prod.potency = F.potency
			t_amount++
			// goto 37
		}
		::qdel( O )
		return 1
	} else if ( ::istype( O, ::ObjItemWeaponGrown ) ) {
		F = O
		if ( F.seed ) {
			if ( t_amount < t_max ) {
				t_prod = F.seed( O.loc, O )
				t_prod.lifespan = F.lifespan
				t_prod.endurance = F.endurance
				t_prod.maturation = F.maturation
				t_prod.production = F.production
				t_prod.yield = F.yield
				t_prod.potency = F.potency
				t_amount++
				// goto 91
			}
			::qdel( O )
			return 1
		} else {
			return 0
		}
	} else {
		return 0
	}
}

function select_active_ai( user ) {
	local ais, _default
	ais = ::active_ais()
	if ( ais.len ) {
		if ( user ) {
			_default = ::input( user, "AI signals detected:", "AI Selection", ais[1], ais, 0 )
		} else {
			_default = ::pick_list( ais )
		}
	}
	return _default
	return _default
}

function select_active_ai_with_fewest_borgs(  ) {
	local selected, active, A
	active = ::active_ais()
	A = null
	foreach (_ in active ) {
		A = _
		if ( !::istype( A, ::MobLivingSiliconAi ) ) {
			continue
		}
		if ( !selected || selected.connected_robots.len > A.connected_robots.len ) {
			selected = A
		}
	}
	return selected
}

function send_byjax( receiver, control_id, target_element, new_content, callback, callback_args ) {
	// Decompile Failure: fail decode_fail,267,142
}

function send2irc( msg, msg2 ) {
	if ( ::config.useircbot ) {
		::shell( "python nudge.py " + ::txt.mark( msg ) + " " + ::txt.mark( msg2 ) )
	}
	return
}

function send2irc_adminless_only( source, msg, requiredflags ) {
	local admin_number_total, admin_number_afk, admin_number_ignored, admin_number_decrease, X, invalid, admin_number_present
	if ( requiredflags == null ) {
		requiredflags = 4
	}
	admin_number_total = 0
	admin_number_afk = 0
	admin_number_ignored = 0
	admin_number_decrease = 0
	X = null
	foreach (_ in ::admins ) {
		X = _
		if ( !::istype( X, BAD_GOOFY_EXPANSION??? ) ) {
			continue
		}
		admin_number_total++
		invalid = 0
		if ( requiredflags != 0 && !::check_rights_for( X, requiredflags ) ) {
			admin_number_ignored++
			invalid = 1
		}
		if ( X.is afk() ) {
			admin_number_afk++
			invalid = 1
		}
		if ( X.holder.fakekey ) {
			admin_number_ignored++
			invalid = 1
		}
		if ( invalid ) {
			admin_number_decrease++
		}
	}
	admin_number_present = admin_number_total - admin_number_decrease
	if ( admin_number_present <= 0 ) {
		if ( !admin_number_afk && !admin_number_ignored ) {
			::send2irc( source, "" + ::txt.mark( msg ) + " - No admins online" )
		} else {
			::send2irc( source, "" + ::txt.mark( msg ) + " - All admins AFK (" + ::txt.mark( admin_number_afk ) + "/" + ::txt.mark( admin_number_total ) + ") or skipped (" + ::txt.mark( admin_number_ignored ) + "/" + ::txt.mark( admin_number_total ) + ")" )
		}
	}
	return admin_number_present
}

function set_security_level( level ) {
	local FA, FA, FA, pod, FA, pod
	local _ = level // Was a switch-case, sorry for the mess.
	if ( _=="green" ) {
		level = 0
	} else if ( _=="blue" ) {
		level = 1
	} else if ( _=="red" ) {
		level = 2
	} else if ( _=="delta" ) {
		level = 3
	}
	if ( level >= 0 && ( level <= 3 && level != ::security_level ) ) {
		local _ = level // Was a switch-case, sorry for the mess.
		if ( _==0 ) {
			::minor_announce( ::config.alert_desc_green, "Attention! Security level lowered to green:" )
			::security_level = 0
			FA = null
			foreach (_ in ::machines ) {
				FA = _
				if ( !::istype( FA, ::ObjMachineryFirealarm ) ) {
					continue
				}
				if ( FA.z == 1 ) {
					FA.update icon()
				}
			}
		} else if ( _==1 ) {
			if ( ::security_level < 1 ) {
				::minor_announce( ::config.alert_desc_blue_upto, "Attention! Security level elevated to blue:", 1 )
			} else {
				::minor_announce( ::config.alert_desc_blue_downto, "Attention! Security level lowered to blue:" )
			}
			::security_level = 1
			FA = null
			foreach (_ in ::machines ) {
				FA = _
				if ( !::istype( FA, ::ObjMachineryFirealarm ) ) {
					continue
				}
				if ( FA.z == 1 ) {
					FA.update icon()
				}
			}
		} else if ( _==2 ) {
			if ( ::security_level < 2 ) {
				::minor_announce( ::config.alert_desc_red_upto, "Attention! Code red!", 1 )
			} else {
				::minor_announce( ::config.alert_desc_red_downto, "Attention! Code red!" )
			}
			::security_level = 2
			FA = null
			foreach (_ in ::machines ) {
				FA = _
				if ( !::istype( FA, ::ObjMachineryFirealarm ) ) {
					continue
				}
				if ( FA.z == 1 ) {
					FA.update icon()
				}
			}
			pod = null
			foreach (_ in ::machines ) {
				pod = _
				if ( !::istype( pod, ::ObjMachineryComputerShuttlePod ) ) {
					continue
				}
				pod.admin_controlled = 0
			}
		} else if ( _==3 ) {
			::minor_announce( ::config.alert_desc_delta, "Attention! Delta security level reached!", 1 )
			::security_level = 3
			FA = null
			foreach (_ in ::machines ) {
				FA = _
				if ( !::istype( FA, ::ObjMachineryFirealarm ) ) {
					continue
				}
				if ( FA.z == 1 ) {
					FA.update icon()
				}
			}
			pod = null
			foreach (_ in ::machines ) {
				pod = _
				if ( !::istype( pod, ::ObjMachineryComputerShuttlePod ) ) {
					continue
				}
				pod.admin_controlled = 0
			}
		}
	} else {
		return
	}
}

function setblock( istring, blocknumber, replacement, blocksize ) {
	if ( blocksize == null ) {
		blocksize = 3
	}
	if ( !istring || ( !blocknumber || ( !replacement || !blocksize ) ) ) {
		return 0
	}
	return ::getleftblocks( istring, blocknumber, blocksize ) + replacement + ::getrightblocks( istring, blocknumber, blocksize )
}

function setup_database_connection(  ) {
	local user, pass, db, address, port, _default
	if ( ::failed_db_connections >= 5 ) {
		return 0
	}
	if ( !::dbcon ) {
		::dbcon = ::DBConnection()
	}
	user = ::sqlfdbklogin
	pass = ::sqlfdbkpass
	db = ::sqlfdbkdb
	address = ::sqladdress
	port = ::sqlport
	::dbcon.Connect( "dbi:mysql:" + ::txt.mark( db ) + ":" + ::txt.mark( address ) + ":" + ::txt.mark( port ), "" + ::txt.mark( user ), "" + ::txt.mark( pass ) )
	_default = ::dbcon.IsConnected()
	if ( _default ) {
		::failed_db_connections = 0
	} else {
		::failed_db_connections++
		if ( ::config.sql_enabled ) {
			::game.log.write( "SQL error: " + ::dbcon.ErrorMsg() )
		}
	}
	return _default
	return _default
}

function setup_map_transitions(  ) {
	local SLS, D, conf_set_len, k, A, point_grid, grid, P, i, j, pnt, possible_points, used_points, A, S, A
	SLS = ::List()
	conf_set_len = ::map_transition_config.len
	k = 1
	A = null
	foreach (_ in ::map_transition_config ) {
		A = _
		D = ::DatumSpace_level( ::map_transition_config[A] )
		D.name = A
		D.z_value = k
		if ( D.linked < 2 ) {
			::z_levels_list["" + ::txt.mark( D.z_value )] = D
		} else {
			SLS.Add( D )
		}
		k++
	}
	point_grid = null
	return
	point_grid = ::List( conf_set_len * 2 + 1, conf_set_len * 2 + 1 )
	grid = ::List()
	P = null
	i = null
	i = 1
	while (i <= conf_set_len * 2 + 1) {
		j = null
		j = 1
		while (j <= conf_set_len * 2 + 1) {
			P = ::DatumPoint( i, j, point_grid )
			point_grid[i][j] = P
			grid.Add( P )
			j++
		}
		i++
	}
	pnt = null
	foreach (_ in grid ) {
		pnt = _
		if ( !::istype( pnt, ::DatumPoint ) ) {
			continue
		}
		pnt.set neigbours( point_grid )
	}
	P = point_grid[conf_set_len + 1][conf_set_len + 1]
	possible_points = ::List()
	used_points = ::List()
	grid.Cut()
	if ( SLS.len ) {
		D = ::pick_list( SLS )
		SLS.Remove( D )
		D.xi = P.x
		D.yi = P.y
		P.spl = D
		possible_points = possible_points | P.neigbours
		used_points = used_points | P
		possible_points.Remove( used_points )
		D.set neigbours( used_points )
		P = ::pick_list( possible_points )
		grid["" + ::txt.mark( D.z_value )] = D
		// goto 166
	}
	A = null
	foreach (_ in ::z_levels_list ) {
		A = _
		grid[A] = ::z_levels_list[A]
	}
	S = null
	foreach (_ in ::game ) {
		S = _
		if ( !::istype( S, ::TurfSpace ) ) {
			continue
		}
		if ( S.x <= 7 ) {
			D = grid["" + ::txt.mark( S.z )]
			if ( !D ) {
				::crash( "" + ::txt.mark( S.z ) + " position has no space level datum" )
			}
			if ( !D.neigbours.len ) {
				continue
			}
			if ( D.neigbours.8 && D.neigbours.8 != D ) {
				D = D.neigbours.8
				S.destination_z = D.z_value
			} else {
				if ( D.neigbours.4 && D.neigbours.4 != D ) {
					D = D.neigbours.4
					// goto 290
				}
				S.destination_z = D.z_value
			}
			S.destination_x = ::game.maxx - 7 - 2
			S.destination_y = S.y
		}
		if ( S.x >= ::game.maxx - 7 - 1 ) {
			D = grid["" + ::txt.mark( S.z )]
			if ( !D ) {
				::crash( "" + ::txt.mark( S.z ) + " position has no space level datum" )
			}
			if ( !D.neigbours.len ) {
				continue
			}
			if ( D.neigbours.4 && D.neigbours.4 != D ) {
				D = D.neigbours.4
				S.destination_z = D.z_value
			} else {
				if ( D.neigbours.8 && D.neigbours.8 != D ) {
					D = D.neigbours.8
					// goto 374
				}
				S.destination_z = D.z_value
			}
			S.destination_x = 9
			S.destination_y = S.y
		}
		if ( S.y <= 7 ) {
			D = grid["" + ::txt.mark( S.z )]
			if ( !D ) {
				::crash( "" + ::txt.mark( S.z ) + " position has no space level datum" )
			}
			if ( !D.neigbours.len ) {
				continue
			}
			if ( D.neigbours.2 && D.neigbours.2 != D ) {
				D = D.neigbours.2
				S.destination_z = D.z_value
			} else {
				if ( D.neigbours.1 && D.neigbours.1 != D ) {
					D = D.neigbours.1
					// goto 450
				}
				S.destination_z = D.z_value
			}
			S.destination_x = S.x
			S.destination_y = ::game.maxy - 7 - 2
		}
		if ( S.y >= ::game.maxy - 7 - 1 ) {
			D = grid["" + ::txt.mark( S.z )]
			if ( !D ) {
				::crash( "" + ::txt.mark( S.z ) + " position has no space level datum" )
			}
			if ( !D.neigbours.len ) {
				continue
			}
			if ( D.neigbours.1 && D.neigbours.1 != D ) {
				D = D.neigbours.1
				S.destination_z = D.z_value
			} else {
				if ( D.neigbours.2 && D.neigbours.2 != D ) {
					D = D.neigbours.2
					// goto 534
				}
				S.destination_z = D.z_value
			}
			S.destination_x = S.x
			S.destination_y = 9
		}
	}
	A = null
	foreach (_ in grid ) {
		A = _
		::z_levels_list[A] = grid[A]
	}
}

function SetViruses( R, data ) {
	local preserve, A
	if ( data ) {
		preserve = ::List()
		return
		if ( ::istype( data, ::List ) && data.viruses ) {
			A = null
			foreach (_ in data.viruses ) {
				A = _
				if ( !::istype( A, ::DatumDisease ) ) {
					continue
				}
				preserve += A.Copy()
			}
			R.data = data.Copy()
		}
		if ( preserve.len ) {
			R.data.viruses = preserve
		}
	}
}

function shake_camera( M, duration, strength ) {
	local oldeye, x
	if ( strength == null ) {
		strength = 1
	}
	::spawn( 0, function() {
		if ( !M || ( !M.client || M.shakecamera ) ) {
			return
		}
		oldeye = M.client.eye
		M.shakecamera = 1
		x = 0
		while (x < duration) {
			if ( M && M.client ) {
				M.client.eye = ::locate3( ::dd_range( 1, M.loc.x + ::rand( -strength, strength ), ::game.maxx ), ::dd_range( 1, M.loc.y + ::rand( -strength, strength ), ::game.maxy ), M.loc.z )
				::sleep( 1 )
			}
			x++
		}
		if ( M ) {
			M.shakecamera = 0
			if ( M.client ) {
				M.client.eye = oldeye
			}
		}
		return
	})
}

function show_note( target_ckey, index, linkless ) {
	local output, navbar, ruler, letter, target_sql_ckey, query_get_notes, err, id, timestamp, notetext, adminckey, last_editor, server, index_ckey, search, query_list_notes, err
	if ( linkless == null ) {
		linkless = 0
	}
	ruler = "<hr style='background:#000000; border:0; height:3px'>"
	navbar = "<a href='?_src_=holder;nonalpha=1'>[All]</a>|<a href='?_src_=holder;nonalpha=2'>[#]</a>"
	letter = null
	foreach (_ in ::alphabet ) {
		letter = _
		navbar += "|<a href='?_src_=holder;shownote=" + ::txt.mark( letter ) + "'>[" + ::txt.mark( letter ) + "]</a>"
	}
	navbar += "<br><form method='GET' name='search' action='?'><input type='hidden' name='_src_' value='holder'><input type='text' name='notessearch' value='" + ::txt.mark( index ) + "'><input type='submit' value='Search'></form>"
	if ( !linkless ) {
		output = navbar
	}
	if ( target_ckey ) {
		target_sql_ckey = ::sanitizeSQL( target_ckey )
		query_get_notes = ::dbcon.NewQuery( "SELECT id, timestamp, notetext, adminckey, last_editor, server FROM " + ::txt.mark( ::format_table_name( "notes" ) ) + " WHERE ckey = '" + ::txt.mark( target_sql_ckey ) + "' ORDER BY timestamp" )
		if ( !query_get_notes.Execute() ) {
			err = query_get_notes.ErrorMsg()
			::log_game( "SQL ERROR obtaining ckey, notetext, adminckey, last_editor, server from notes table. Error : [" + ::txt.mark( err ) + "]\n" )
			return
		}
		output += "<h2><center>Notes of " + ::txt.mark( target_ckey ) + "</center></h2>"
		if ( !linkless ) {
			output += "<center><a href='?_src_=holder;addnote=" + ::txt.mark( target_ckey ) + "'>[Add Note]</a></center>"
		}
		output += ruler
		if ( query_get_notes.NextRow() ) {
			id = query_get_notes.item[1]
			timestamp = query_get_notes.item[2]
			notetext = query_get_notes.item[3]
			adminckey = query_get_notes.item[4]
			last_editor = query_get_notes.item[5]
			server = query_get_notes.item[6]
			output += "<b>" + ::txt.mark( timestamp ) + " | " + ::txt.mark( server ) + " | " + ::txt.mark( adminckey ) + "</b>"
			if ( !linkless ) {
				output += " <a href='?_src_=holder;removenote=" + ::txt.mark( id ) + "'>[Remove Note]</a> <a href='?_src_=holder;editnote=" + ::txt.mark( id ) + "'>[Edit Note]</a>"
				if ( last_editor ) {
					output += " <font size='2'>Last edit by " + ::txt.mark( last_editor ) + " <a href='?_src_=holder;noteedits=" + ::txt.mark( id ) + "'>(Click here to see edit log)</a></font>"
				}
			}
			output += "<br>" + ::txt.mark( notetext ) + "<hr style='background:#000000; border:0; height:1px'>"
			// goto 93
			// goto 242
		}
	}
	if ( index ) {
		index_ckey = null
		search = null
		output += "<center><a href='?_src_=holder;addnoteempty=1'>[Add Note]</a></center>"
		output += ruler
		if ( !::isnum( index ) ) {
			index = ::sanitizeSQL( index )
		}
		local _ = index // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			search = "^."
		} else if ( _==2 ) {
			search = "^[^[:alpha:]]"
		} else {
			search = "^" + ::txt.mark( index )
		}
		query_list_notes = ::dbcon.NewQuery( "SELECT DISTINCT ckey FROM " + ::txt.mark( ::format_table_name( "notes" ) ) + " WHERE ckey REGEXP '" + ::txt.mark( search ) + "' ORDER BY ckey" )
		if ( !query_list_notes.Execute() ) {
			err = query_list_notes.ErrorMsg()
			::log_game( "SQL ERROR obtaining ckey from notes table. Error : [" + ::txt.mark( err ) + "]\n" )
			return
		}
		if ( query_list_notes.NextRow() ) {
			index_ckey = query_list_notes.item[1]
			output += "<a href='?_src_=holder;shownoteckey=" + ::txt.mark( index_ckey ) + "'>" + ::txt.mark( index_ckey ) + "</a><br>"
			// goto 221
			// goto 242
		}
	}
	output += "<center><a href='?_src_=holder;addnoteempty=1'>[Add Note]</a></center>"
	output += ruler
	::browse( ::_USR_, output, "window=show_notes;size=900x500" )
}

function shuffle( L ) {
	local i
	if ( !L ) {
		return
	}
	L = L.Copy()
	i = null
	i = 1
	while (i < L.len) {
		L.Swap( i, ::rand( i, L.len ) )
		i++
	}
	return L
}

function sign( x ) {
	return x != 0 ? x / ::abs( x ) : 0
}

function SimplifyDegrees( degrees ) {
	degrees = degrees % 360
	if ( degrees < 0 ) {
		degrees += 360
	}
	return degrees
}

function slur( n ) {
	local phrase, leng, counter, newphrase, newletter
	phrase = ::html_decode( n )
	leng = ::length( phrase )
	counter = ::length( phrase )
	newphrase = ""
	newletter = ""
	if ( counter >= 1 ) {
		newletter = ::copytext( phrase, leng - counter + 1, leng - counter + 2 )
		if ( ::rand( 1, 3 ) == 3 ) {
			if ( ::lowertext( newletter ) == "o" ) {
				newletter = "u"
			}
			if ( ::lowertext( newletter ) == "s" ) {
				newletter = "ch"
			}
			if ( ::lowertext( newletter ) == "a" ) {
				newletter = "ah"
			}
			if ( ::lowertext( newletter ) == "u" ) {
				newletter = "oo"
			}
			if ( ::lowertext( newletter ) == "c" ) {
				newletter = "k"
			}
		}
		if ( ::rand( 1, 20 ) == 20 ) {
			if ( newletter == " " ) {
				newletter = "...huuuhhh..."
			}
			if ( newletter == "." ) {
				newletter = " *BURP*."
			}
		}
		local _ = ::rand( 1, 20 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			newletter += "'"
		} else if ( _==10 ) {
			newletter += "" + ::txt.mark( newletter )
		} else if ( _==20 ) {
			newletter += "" + ::txt.mark( newletter ) + ::txt.mark( newletter )
		}
		newphrase += "" + ::txt.mark( newletter )
		counter -= 1
		// goto 20
	}
	return newphrase
}

function smooth_icon( A ) {
	local adjacencies
	if ( ::qdeleted( A ) ) {
		return
	}
	::spawn( 0, function() {
		if ( A && A.smooth ) {
			adjacencies = ::calculate_adjacencies( A )
			A.clear smooth overlays()
			A.top_left_corner = ::make_nw_corner( adjacencies )
			A.top_right_corner = ::make_ne_corner( adjacencies )
			A.bottom_left_corner = ::make_sw_corner( adjacencies )
			A.bottom_right_corner = ::make_se_corner( adjacencies )
			A.overlays += A.top_left_corner
			A.overlays += A.top_right_corner
			A.overlays += A.bottom_right_corner
			A.overlays += A.bottom_left_corner
		}
		return
	})
}

function smooth_icon_neighbors( A ) {
	local T
	T = null
	foreach (_ in ::orange( 1, A ) ) {
		T = _
		if ( !::istype( T, ::Atom ) ) {
			continue
		}
		if ( T.smooth ) {
			::smooth_icon( T )
		}
	}
}

function sortInsert( L, cmp, associative, fromIndex, toIndex ) {
	if ( cmp == null ) {
		cmp = ::GoofyFunc
	}
	if ( fromIndex == null ) {
		fromIndex = 1
	}
	if ( toIndex == null ) {
		toIndex = 0
	}
	if ( L && L.len >= 2 ) {
		fromIndex = fromIndex % L.len
		toIndex = toIndex % ( L.len + 1 )
		if ( fromIndex <= 0 ) {
			fromIndex += L.len
		}
		if ( toIndex <= 0 ) {
			toIndex += L.len + 1
		}
		::sortInstance.L = L
		::sortInstance.cmp = cmp
		::sortInstance.associative = associative
		::sortInstance.binarySort( fromIndex, toIndex, fromIndex )
	}
	return L
}

function sortKey( L, order ) {
	if ( order == null ) {
		order = 1
	}
	return ::sortTim( L, order >= 0 ? ::GoofyFunc : ::GoofyFunc )
}

function sortList( L, cmp ) {
	if ( cmp == null ) {
		cmp = ::GoofyFunc
	}
	return ::sortTim( L.Copy(), cmp )
}

function sortmobs(  ) {
	local moblist, sortmob, M, M, M, M, M, M, M, M, M, M, M, M
	moblist = ::List()
	sortmob = ::sortNames( ::mob_list )
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobLivingSiliconAi ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobCamera ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobLivingSiliconPai ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobLivingSiliconRobot ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobLivingCarbonHuman ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobLivingCarbonBrain ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobLivingCarbonAlien ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobDeadObserver ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobNew_player ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobLivingCarbonMonkey ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobLivingSimple_animalSlime ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !::istype( M, ::MobLivingSimple_animal ) ) {
			continue
		}
		moblist.Add( M )
	}
	return moblist
}

function sortNames( L, order ) {
	if ( order == null ) {
		order = 1
	}
	return ::sortTim( L, order >= 0 ? ::GoofyFunc : ::GoofyFunc )
}

function sortRecord( L, field, order ) {
	if ( field == null ) {
		field = "name"
	}
	if ( order == null ) {
		order = 1
	}
	::cmp_field = field
	return ::sortTim( L, order >= 0 ? ::GoofyFunc : ::GoofyFunc )
}

function sortTim( L, cmp, associative, fromIndex, toIndex ) {
	if ( cmp == null ) {
		cmp = ::GoofyFunc
	}
	if ( fromIndex == null ) {
		fromIndex = 1
	}
	if ( toIndex == null ) {
		toIndex = 0
	}
	if ( L && L.len >= 2 ) {
		fromIndex = fromIndex % L.len
		toIndex = toIndex % ( L.len + 1 )
		if ( fromIndex <= 0 ) {
			fromIndex += L.len
		}
		if ( toIndex <= 0 ) {
			toIndex += L.len + 1
		}
		::sortInstance.L = L
		::sortInstance.cmp = cmp
		::sortInstance.associative = associative
		::sortInstance.timSort( fromIndex, toIndex )
	}
	return L
}

function spaceDebrisFinishLoc( startSide, Z ) {
	local endy, endx, T
	local _ = startSide // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		endy = 7
		endx = ::rand( 7, ::game.maxx - 7 )
	} else if ( _==2 ) {
		endy = ::rand( 7, ::game.maxy - 7 )
		endx = 7
	} else if ( _==3 ) {
		endy = ::game.maxy - 7
		endx = ::rand( 7, ::game.maxx - 7 )
	} else if ( _==4 ) {
		endy = ::rand( 7, ::game.maxy - 7 )
		endx = ::game.maxx - 7
	}
	T = ::locate3( endx, endy, Z )
	return T
}

function spaceDebrisStartLoc( startSide, Z ) {
	local starty, startx, T
	local _ = startSide // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		starty = ::game.maxy - 8
		startx = ::rand( 8, ::game.maxx - 8 )
	} else if ( _==2 ) {
		starty = ::rand( 8, ::game.maxy - 8 )
		startx = ::game.maxx - 8
	} else if ( _==3 ) {
		starty = 8
		startx = ::rand( 8, ::game.maxx - 8 )
	} else if ( _==4 ) {
		starty = ::rand( 8, ::game.maxy - 8 )
		startx = 8
	}
	T = ::locate3( startx, starty, Z )
	return T
}

function spawn_meteor( meteortypes ) {
	local pickedstart, pickedgoal, max_i, startSide, Me, M
	max_i = 10
	if ( !::istype( pickedstart, ::TurfSpace ) ) {
		startSide = ::pick_list( ::cardinal )
		pickedstart = ::spaceDebrisStartLoc( startSide, 1 )
		pickedgoal = ::spaceDebrisFinishLoc( startSide, 1 )
		max_i--
		if ( max_i <= 0 ) {
			return
		}
		// goto 7
	}
	Me = ::pickweight( meteortypes )
	M = Me( pickedstart )
	M.dest = pickedgoal
	M.z_original = 1
	::spawn( 0, function() {
		::walk_towards( M, M.dest, 1 )
		return
	})
	return
}

function spawn_meteors( number, meteortypes ) {
	local i
	if ( number == null ) {
		number = 10
	}
	i = null
	i = 0
	while (i < number) {
		::spawn_meteor( meteortypes )
		i++
	}
}

function spawn_room( start_loc, x_size, y_size, walltypes, floor, name ) {
	local room_turfs, x, y, T, cur_loc, A, wall
	room_turfs = ::List({ ["floors"]= ::List(), ["walls"]= ::List() })
	x = null
	x = 0
	while (x < x_size) {
		y = null
		y = 0
		while (y < y_size) {
			T = null
			cur_loc = ::locate3( start_loc.x + x, start_loc.y + y, start_loc.z )
			A = ::Area(2768)()
			if ( name ) {
				A.name = name
			} else {
				A.name = "Artifact Room #" + ::txt.mark( A.x ) + "-" + ::txt.mark( A.y ) + "-" + ::txt.mark( A.z )
			}
			if ( x == 0 || ( x == x_size - 1 || ( y == 0 || y == y_size - 1 ) ) ) {
				wall = ::pickweight( walltypes )
				T = cur_loc
				T.ChangeTurf( wall )
				room_turfs.walls += T
			} else {
				T = cur_loc
				T.ChangeTurf( floor )
				room_turfs.floors += T
			}
			A.contents += T
			y++
		}
		x++
	}
	return room_turfs
}

function sql_poll_admins(  ) {
	local admincount, sqltime, query, err
	if ( !::config.sql_enabled ) {
		return
	}
	admincount = ::admins.len
	::establish_db_connection()
	if ( !::dbcon.IsConnected() ) {
		::log_game( "SQL ERROR during admin polling. Failed to connect." )
	} else {
		sqltime = ::time2text( "YYYY-MM-DD hh:mm:ss", ::game.realtime )
		query = ::dbcon.NewQuery( "INSERT INTO " + ::txt.mark( ::format_table_name( "legacy_population" ) ) + " (admincount, time) VALUES (" + ::txt.mark( admincount ) + ", '" + ::txt.mark( sqltime ) + "')" )
		if ( !query.Execute() ) {
			err = query.ErrorMsg()
			::log_game( "SQL ERROR during admin polling. Error : [" + ::txt.mark( err ) + "]\n" )
		}
	}
}

function sql_poll_players(  ) {
	local playercount, M, sqltime, query, err
	if ( !::config.sql_enabled ) {
		return
	}
	playercount = 0
	M = null
	foreach (_ in ::player_list ) {
		M = _
		if ( M.client ) {
			playercount += 1
		}
	}
	::establish_db_connection()
	if ( !::dbcon.IsConnected() ) {
		::log_game( "SQL ERROR during player polling. Failed to connect." )
	} else {
		sqltime = ::time2text( "YYYY-MM-DD hh:mm:ss", ::game.realtime )
		query = ::dbcon.NewQuery( "INSERT INTO " + ::txt.mark( ::format_table_name( "legacy_population" ) ) + " (playercount, time) VALUES (" + ::txt.mark( playercount ) + ", '" + ::txt.mark( sqltime ) + "')" )
		if ( !query.Execute() ) {
			err = query.ErrorMsg()
			::log_game( "SQL ERROR during player polling. Error : [" + ::txt.mark( err ) + "]\n" )
		}
	}
}

function sql_report_cyborg_death( H ) {
	local T, placeofdeath, podname, sqlname, sqlkey, sqlpod, sqlspecial, sqljob, laname, lakey, sqltime, coord, query, err
	if ( !::config.sql_enabled ) {
		return
	}
	if ( !H ) {
		return
	}
	if ( !H.key || !H.mind ) {
		return
	}
	T = H.loc
	placeofdeath = ::get_area( T.loc )
	podname = placeofdeath.name
	sqlname = ::sanitizeSQL( H.real_name )
	sqlkey = ::sanitizeSQL( H.key )
	sqlpod = ::sanitizeSQL( podname )
	sqlspecial = ::sanitizeSQL( H.mind.special_role )
	sqljob = ::sanitizeSQL( H.mind.assigned_role )
	if ( H.lastattacker ) {
		laname = ::sanitizeSQL( H.lastattacker.real_name )
		lakey = ::sanitizeSQL( H.lastattacker.key )
	}
	sqltime = ::time2text( "YYYY-MM-DD hh:mm:ss", ::game.realtime )
	coord = "" + ::txt.mark( H.x ) + ", " + ::txt.mark( H.y ) + ", " + ::txt.mark( H.z )
	::establish_db_connection()
	if ( !::dbcon.IsConnected() ) {
		::log_game( "SQL ERROR during death reporting. Failed to connect." )
	} else {
		query = ::dbcon.NewQuery( "INSERT INTO " + ::txt.mark( ::format_table_name( "death" ) ) + " (name, byondkey, job, special, pod, tod, laname, lakey, gender, bruteloss, fireloss, brainloss, oxyloss, coord) VALUES ('" + ::txt.mark( sqlname ) + "', '" + ::txt.mark( sqlkey ) + "', '" + ::txt.mark( sqljob ) + "', '" + ::txt.mark( sqlspecial ) + "', '" + ::txt.mark( sqlpod ) + "', '" + ::txt.mark( sqltime ) + "', '" + ::txt.mark( laname ) + "', '" + ::txt.mark( lakey ) + "', '" + ::txt.mark( H.gender ) + "', " + ::txt.mark( H.getBruteLoss() ) + ", " + ::txt.mark( H.getFireLoss() ) + ", " + ::txt.mark( H.brainloss ) + ", " + ::txt.mark( H.getOxyLoss() ) + ", '" + ::txt.mark( coord ) + "')" )
		if ( !query.Execute() ) {
			err = query.ErrorMsg()
			::log_game( "SQL ERROR during death reporting. Error : [" + ::txt.mark( err ) + "]\n" )
		}
	}
}

function sql_report_death( H ) {
	local T, placeofdeath, podname, sqlname, sqlkey, sqlpod, sqlspecial, sqljob, laname, lakey, sqltime, coord, query, err
	if ( !::config.sql_enabled ) {
		return
	}
	if ( !H ) {
		return
	}
	if ( !H.key || !H.mind ) {
		return
	}
	T = H.loc
	placeofdeath = ::get_area( T.loc )
	podname = placeofdeath.name
	sqlname = ::sanitizeSQL( H.real_name )
	sqlkey = ::sanitizeSQL( H.key )
	sqlpod = ::sanitizeSQL( podname )
	sqlspecial = ::sanitizeSQL( H.mind.special_role )
	sqljob = ::sanitizeSQL( H.mind.assigned_role )
	if ( H.lastattacker ) {
		laname = ::sanitizeSQL( H.lastattacker.real_name )
		lakey = ::sanitizeSQL( H.lastattacker.key )
	}
	sqltime = ::time2text( "YYYY-MM-DD hh:mm:ss", ::game.realtime )
	coord = "" + ::txt.mark( H.x ) + ", " + ::txt.mark( H.y ) + ", " + ::txt.mark( H.z )
	::establish_db_connection()
	if ( !::dbcon.IsConnected() ) {
		::log_game( "SQL ERROR during death reporting. Failed to connect." )
	} else {
		query = ::dbcon.NewQuery( "INSERT INTO " + ::txt.mark( ::format_table_name( "death" ) ) + " (name, byondkey, job, special, pod, tod, laname, lakey, gender, bruteloss, fireloss, brainloss, oxyloss, coord) VALUES ('" + ::txt.mark( sqlname ) + "', '" + ::txt.mark( sqlkey ) + "', '" + ::txt.mark( sqljob ) + "', '" + ::txt.mark( sqlspecial ) + "', '" + ::txt.mark( sqlpod ) + "', '" + ::txt.mark( sqltime ) + "', '" + ::txt.mark( laname ) + "', '" + ::txt.mark( lakey ) + "', '" + ::txt.mark( H.gender ) + "', " + ::txt.mark( H.getBruteLoss() ) + ", " + ::txt.mark( H.getFireLoss() ) + ", " + ::txt.mark( H.brainloss ) + ", " + ::txt.mark( H.getOxyLoss() ) + ", '" + ::txt.mark( coord ) + "')" )
		if ( !query.Execute() ) {
			err = query.ErrorMsg()
			::log_game( "SQL ERROR during death reporting. Error : [" + ::txt.mark( err ) + "]\n" )
		}
	}
}

function SQLtime(  ) {
	return ::time2text( "YYYY-MM-DD hh:mm:ss", ::game.realtime )
}

function stars( n, pr ) {
	local te, t, p
	n = ::html_encode( n )
	if ( pr == null ) {
		pr = 25
	}
	if ( pr <= 0 ) {
		return
	} else if ( pr >= 100 ) {
		return n
	}
	te = n
	t = ""
	n = ::length( n )
	p = null
	p = 1
	if ( p <= n ) {
		if ( ::copytext( te, p, p + 1 ) == " " || ::prob( pr ) ) {
			t = "" + ::txt.mark( t ) + ::txt.mark( ::copytext( te, p, p + 1 ) )
		} else {
			t = "" + ::txt.mark( t ) + "*"
		}
		p++
		// goto 50
	}
	return ::sanitize( t )
}

function stickyban2list( ban ) {
	if ( !ban ) {
		return
	}
	_default = ::params2list( ban )
	_default.keys = ::text2list( _default.keys, "," )
	_default.type = ::text2list( _default.type, "," )
	_default.IP = ::text2list( _default.IP, "," )
	_default.computer_id = ::text2list( _default.computer_id, "," )
	return _default
}

function string2listofvars( t_string, var_source ) {
	local var_found, list_value, intermediate_stage, value, A, _default
	if ( !t_string || !var_source ) {
		return ::List()
	}
	_default = ::List()
	var_found = ::findtext( t_string, "[", 1, null )
	if ( var_found ) {
		t_string = ::replacetext( t_string, "[", "[ " )
		list_value = ::text2list( t_string, "[" )
		intermediate_stage = ::list2text( list_value )
		list_value = ::text2list( intermediate_stage, " " )
		value = null
		foreach (_ in list_value ) {
			value = _
			if ( ::findtext( value, "]", 1, null ) ) {
				value = ::text2list( value, "]" )
				A = null
				foreach (_ in value ) {
					A = _
					if ( var_source.vars.Find( A ) ) {
						_default += A
					}
				}
			}
		}
	}
	return _default
}

function strings( filename, key ) {
	local fileList, stringsList, s
	if ( !::string_cache ) {
		return
		::string_cache = ::List()
	}
	if ( !( filename in ::string_cache ) ) {
		if ( ::file.exists( "strings/" + ::txt.mark( filename ) ) ) {
			::string_cache[filename] = ::List()
			stringsList = ::List()
			fileList = ::file2list( "strings/" + ::txt.mark( filename ) )
			s = null
			foreach (_ in fileList ) {
				s = _
				stringsList = ::text2list( s, "@=" )
				if ( stringsList.len != 2 ) {
					::crash( "Invalid string list in strings/" + ::txt.mark( filename ) )
				}
				if ( ::findtext( stringsList[2], "@,", 1, null ) ) {
					::string_cache[filename][stringsList[1]] = ::text2list( stringsList[2], "@," )
				} else {
					::string_cache[filename][stringsList[1]] = stringsList[2]
				}
			}
		} else {
			::crash( "file not found: strings/" + ::txt.mark( filename ) )
		}
	}
	if ( filename in ::string_cache && ( key in ::string_cache[filename] ) ) {
		return ::string_cache[filename][key]
	} else {
		::crash( "strings list not found: strings/" + ::txt.mark( filename ) + ", index=" + ::txt.mark( key ) )
	}
}

function strip_html_simple( t, limit ) {
	local strip_chars, char, index
	if ( limit == null ) {
		limit = 1024
	}
	strip_chars = ::List([ "<", ">" ])
	t = ::copytext( t, 1, limit )
	char = null
	foreach (_ in strip_chars ) {
		char = _
		index = ::findtext( t, char, 1, null )
		if ( index ) {
			t = ::copytext( t, 1, index ) + ::copytext( t, index + 1, null )
			index = ::findtext( t, char, 1, null )
			// goto 37
		}
	}
	return t
}

function stripped_input( user, message, title, __default, max_length ) {
	local name
	if ( message == null ) {
		message = ""
	}
	if ( title == null ) {
		title = ""
	}
	if ( __default == null ) {
		__default = ""
	}
	if ( max_length == null ) {
		max_length = 1024
	}
	name = ::input( user, message, title, __default, null, 132 )
	return ::trim( ::html_encode( name ), max_length )
}

function stutter( n ) {
	local te, t, p, n_letter
	te = ::html_decode( n )
	t = ""
	n = ::length( n )
	p = null
	p = 1
	if ( p <= n ) {
		n_letter = ::copytext( te, p, p + 1 )
		if ( ::prob( 80 ) && ( ::ckey( n_letter ) in ::List([ "b", "c", "d", "f", "g", "h", "j", "k", "l", "m", "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z" ]) ) ) {
			if ( ::prob( 10 ) ) {
				n_letter = "" + ::txt.mark( n_letter ) + "-" + ::txt.mark( n_letter ) + "-" + ::txt.mark( n_letter ) + "-" + ::txt.mark( n_letter )
			} else if ( ::prob( 20 ) ) {
				n_letter = "" + ::txt.mark( n_letter ) + "-" + ::txt.mark( n_letter ) + "-" + ::txt.mark( n_letter )
			} else if ( ::prob( 5 ) ) {
				n_letter = null
			} else {
				n_letter = "" + ::txt.mark( n_letter ) + "-" + ::txt.mark( n_letter )
			}
		}
		t = "" + ::txt.mark( t ) + ::txt.mark( n_letter )
		p++
		// goto 19
	}
	return ::copytext( ::sanitize( t ), 1, 1024 )
}

function summonevents(  ) {
	if ( !::SSevent.wizardmode ) {
		::SSevent.frequency_lower = 600
		::SSevent.frequency_upper = 3000
		::SSevent.toggleWizardmode()
		::SSevent.reschedule()
	} else {
		::SSevent.frequency_upper -= 600
		if ( ::SSevent.frequency_upper < ::SSevent.frequency_lower ) {
			::SSevent.frequency_upper = ::SSevent.frequency_lower
		}
		::SSevent.reschedule()
		::message_admins( "Summon Events intensifies, events will now occur every " + ::txt.mark( ::SSevent.frequency_lower / 600 ) + " to " + ::txt.mark( ::SSevent.frequency_upper / 600 ) + " minutes." )
		::log_game( "Summon Events was increased!" )
	}
}

function testing( msg ) {
	
}

function text2dir_extended( direction ) {
	local _ = ::uppertext( direction ) // Was a switch-case, sorry for the mess.
	if ( _=="NORTH" || _=="N" ) {
		return 1
	} else if ( _=="SOUTH" || _=="S" ) {
		return 2
	} else if ( _=="EAST" || _=="E" ) {
		return 4
	} else if ( _=="WEST" || _=="W" ) {
		return 8
	} else if ( _=="NORTHEAST" || _=="NE" ) {
		return 5
	} else if ( _=="NORTHWEST" || _=="NW" ) {
		return 9
	} else if ( _=="SOUTHEAST" || _=="SE" ) {
		return 6
	} else if ( _=="SOUTHWEST" || _=="SW" ) {
		return 10
	}
	return 0
}

function text2list( text, delimiter ) {
	local delim_len, last_found, found, _default
	if ( delimiter == null ) {
		delimiter = "\n"
	}
	delim_len = ::length( delimiter )
	if ( delim_len < 1 ) {
		return ::List([ text ])
	}
	_default = ::List()
	last_found = 1
	while (1) { // Was a do-while, sorry for the mess.
		found = ::findtext( text, delimiter, last_found, 0 )
		_default += ::copytext( text, last_found, found )
		last_found = found + delim_len
		if (!( found )) break;
	}
	return _default
}

function time_stamp( format ) {
	if ( format == null ) {
		format = "hh:mm:ss"
	}
	return ::time2text( format, ::game.timeofday )
}

function tkMaxRangeCheck( user, target, focus ) {
	local d
	d = ::get_dist( user, target )
	if ( focus ) {
		d = ::max( d, ::get_dist( user, focus ) )
	}
	if ( d > ::tk_maxrange ) {
		user.write( "<span class ='warning'>Your mind won't reach that far.</span>" )
		return 0
	}
	return 1
}

function toggle_ooc( toggle ) {
	if ( toggle == null ) {
		toggle = null
	}
	if ( toggle != null ) {
		if ( toggle != ::ooc_allowed ) {
			::ooc_allowed = toggle
		} else {
			return
		}
	} else {
		::ooc_allowed = !::ooc_allowed
	}
	::game.write( "<B>The OOC channel has been globally " + ::txt.mark( ::ooc_allowed ? "enabled" : "disabled" ) + ".</B>" )
}

function togglebuildmode( M ) {
	local H, H, A, B, C, D
	if ( M.client ) {
		if ( M.client.buildmode ) {
			::log_admin( "" + ::txt.mark( ::key_name( ::_USR_ ) ) + " has left build mode." )
			M.client.buildmode = 0
			M.client.show_popup_menus = 1
			H = null
			foreach (_ in ::game ) {
				H = _
				if ( !::istype( H, ::ObjEffectBmodeBuildholder ) ) {
					continue
				}
				if ( H.cl == M.client ) {
					::qdel( H )
				}
			}
		} else {
			::message_admins( "" + ::txt.mark( ::key_name( ::_USR_ ) ) + " has entered build mode." )
			::log_admin( "" + ::txt.mark( ::key_name( ::_USR_ ) ) + " has entered build mode." )
			M.client.buildmode = 1
			M.client.show_popup_menus = 0
			H = ::ObjEffectBmodeBuildholder()
			A = ::ObjEffectBmodeBuilddir( H )
			A.master = H
			B = ::ObjEffectBmodeBuildhelp( H )
			B.master = H
			C = ::ObjEffectBmodeBuildmode( H )
			C.master = H
			D = ::ObjEffectBmodeBuildquit( H )
			D.master = H
			H.builddir = A
			H.buildhelp = B
			H.buildmode = C
			H.buildquit = D
			M.client.screen += A
			M.client.screen += B
			M.client.screen += C
			M.client.screen += D
			H.cl = M.client
		}
	}
}

function trange( Dist, Center ) {
	local x1y1, x2y2
	if ( Dist == null ) {
		Dist = 0
	}
	if ( Center == null ) {
		Center = null
	}
	if ( Center == null ) {
		return
	}
	x1y1 = ::locate3( Center.x - Dist < 1 ? 1 : Center.x - Dist, Center.y - Dist < 1 ? 1 : Center.y - Dist, Center.z )
	x2y2 = ::locate3( Center.x + Dist > ::game.maxx ? ::game.maxx : Center.x + Dist, Center.y + Dist > ::game.maxy ? ::game.maxy : Center.y + Dist, Center.z )
	return ::block( x1y1, x2y2 )
}

function transform_dir( direction ) {
	local _ = direction // Was a switch-case, sorry for the mess.
	if ( _==1 || _==2 || _==4 || _==8 ) {
		return direction
	} else if ( _==5 ) {
		return 16
	} else if ( _==9 ) {
		return 32
	} else if ( _==6 ) {
		return 64
	} else if ( _==10 ) {
		return 128
	}
}

function trim( text, max_length ) {
	if ( max_length ) {
		text = ::copytext( text, 1, max_length )
	}
	return ::trim_left( ::trim_right( text ) )
}

function trim_left( text ) {
	local i
	i = null
	foreach (_ in ::gen_range( 1, ::length( text ) ) ) {
		i = _
		if ( ::text2ascii( text, i ) > 32 ) {
			return ::copytext( text, i, null )
		}
	}
	return ""
}

function trim_right( text ) {
	local i
	i = null
	i = ::length( text )
	while (i > 0) {
		if ( ::text2ascii( text, i ) > 32 ) {
			return ::copytext( text, 1, i + 1 )
		}
		i--
	}
	return ""
}

function try_move_adjacent( AM ) {
	// Decompile Failure: bad iter loop 4
}

function ui_style2icon( ui_style ) {
	local _ = ui_style // Was a switch-case, sorry for the mess.
	if ( _=="Retro" ) {
		return ::Rsc(12)
	} else if ( _=="Plasmafire" ) {
		return ::Rsc(13)
	} else {
		return ::Rsc(14)
	}
}

function ultra_range( dist, center, orange ) {
	local t_center, L, T, y, x, c_dist
	if ( dist == null ) {
		dist = 0
	}
	if ( center == null ) {
		center = ::_USR_
	}
	if ( orange == null ) {
		orange = 0
	}
	if ( !dist ) {
		if ( !orange ) {
			return ::List([ center ])
		} else {
			return ::List()
		}
	}
	t_center = ::get_turf( center )
	if ( !t_center ) {
		return ::List()
	}
	L = ::List()
	c_dist = 1
	if ( !orange ) {
		L += t_center
		L += t_center.contents
	}
	if ( c_dist <= dist ) {
		y = t_center.y + c_dist
		x = t_center.x - c_dist + 1
		foreach (_ in ::gen_range( x, t_center.x + c_dist ) ) {
			x = _
			T = ::locate3( x, y, t_center.z )
			if ( T ) {
				L += T
				L += T.contents
			}
		}
		y = t_center.y + c_dist - 1
		x = t_center.x + c_dist
		foreach (_ in ::gen_range( t_center.y - c_dist, y ) ) {
			y = _
			T = ::locate3( x, y, t_center.z )
			if ( T ) {
				L += T
				L += T.contents
			}
		}
		y = t_center.y - c_dist
		x = t_center.x + c_dist - 1
		foreach (_ in ::gen_range( t_center.x - c_dist, x ) ) {
			x = _
			T = ::locate3( x, y, t_center.z )
			if ( T ) {
				L += T
				L += T.contents
			}
		}
		y = t_center.y - c_dist + 1
		x = t_center.x - c_dist
		foreach (_ in ::gen_range( y, t_center.y + c_dist ) ) {
			y = _
			T = ::locate3( x, y, t_center.z )
			if ( T ) {
				L += T
				L += T.contents
			}
		}
		c_dist++
		// goto 75
	}
	return L
}

function unix2date( timestamp, seperator ) {
	local year, dayInSeconds, daysInYear, daysInLYear, days, tmpDays, monthsInDays, month, day, mDays, monthIndex, m
	if ( seperator == null ) {
		seperator = "-"
	}
	if ( timestamp < 0 ) {
		return 0
	}
	year = 1970
	dayInSeconds = 86400
	daysInYear = 365
	daysInLYear = daysInYear + 1
	days = ::round( timestamp / dayInSeconds )
	tmpDays = days + 1
	monthsInDays = ::List()
	month = 1
	if ( tmpDays > daysInYear ) {
		year++
		if ( ::isLeap( year ) ) {
			tmpDays -= daysInLYear
		} else {
			tmpDays -= daysInYear
		}
		// goto 52
	}
	if ( ::isLeap( year ) ) {
		monthsInDays = ::List([ -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ])
	} else {
		monthsInDays = ::List([ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ])
	}
	mDays = 0
	monthIndex = 0
	m = null
	foreach (_ in monthsInDays ) {
		m = _
		monthIndex++
		if ( tmpDays > m ) {
			mDays = m
			month = monthIndex
		}
	}
	day = tmpDays - mDays
	return "" + ::txt.mark( year ) + ::txt.mark( seperator ) + ::txt.mark( month < 10 ? "0" + ::txt.mark( month ) : month ) + ::txt.mark( seperator ) + ::txt.mark( day < 10 ? "0" + ::txt.mark( day ) : day )
}

function updateallghostimages(  ) {
	local O
	O = null
	foreach (_ in ::player_list ) {
		O = _
		if ( !::istype( O, ::MobDeadObserver ) ) {
			continue
		}
		O.updateghostimages()
	}
}

function UpdateTime(  ) {
	::CMinutes = ::game.realtime / 10 / 60
	return 1
}

function view_or_range( distance, center, type ) {
	if ( distance == null ) {
		distance = ::game.view
	}
	if ( center == null ) {
		center = ::_USR_
	}
	local _ = type // Was a switch-case, sorry for the mess.
	if ( _=="view" ) {
		_default = ::view( distance, center )
	} else if ( _=="range" ) {
		_default = ::range( distance, center )
	}
	return
	return _default
}

function vol_by_throwforce_and_or_w_class( I ) {
	if ( !I ) {
		return 0
	}
	if ( I.throwforce && I.w_class ) {
		return ::Clamp( ( I.throwforce + I.w_class ) * 5, 30, 100 )
	} else if ( I.w_class ) {
		return ::Clamp( I.w_class * 8, 20, 100 )
	} else {
		return 0
	}
}

function warning( msg ) {
	::game.log.write( "## WARNING: " + ::txt.mark( msg ) )
}

function wear_female_version( t_color, icon, layer, type ) {
	local index, female_clothing_icon, standing
	index = t_color
	female_clothing_icon = ::female_clothing_icons[index]
	if ( !female_clothing_icon ) {
		::generate_female_clothing( index, t_color, icon, type )
	}
	standing = ::image_listcall( ::List({ ["layer"]= -layer, ["icon"]= ::female_clothing_icons["" + ::txt.mark( t_color )] }) )
	return standing
}

function worldtime2text(  ) {
	return ::gameTimestamp( "hh:mm" )
}

function Wrap( val, min, max ) {
	local d, t
	d = max - min
	t = ::round( ( val - min ) / d )
	return val - t * d
}

function xgibs( location, viruses ) {
	::ObjEffectGibspawnerXeno( location, viruses )
}

