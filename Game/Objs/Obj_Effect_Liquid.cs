// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Obj_Effect_Liquid : Obj_Effect {

		public dynamic volume = 0;
		public double new_volume = 0;
		public Puddle controller = null;

		protected override void __FieldInit() {
			base.__FieldInit();

			this.icon = "icons/effects/liquid.dmi";
			this.icon_state = "0";
		}

		// Function from file: splash_simulation.dm
		public Obj_Effect_Liquid ( dynamic loc = null ) : base( (object)(loc) ) {
			Obj_Effect_Liquid L = null;

			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;

			if ( !( this.loc is Tile ) ) {
				GlobalFuncs.qdel( this );
				return;
			}

			foreach (dynamic _a in Lang13.Enumerate( this.loc, typeof(Obj_Effect_Liquid) )) {
				L = _a;
				

				if ( L != this ) {
					GlobalFuncs.qdel( L );
					L = null;
				}
			}
			return;
		}

		// Function from file: splash_simulation.dm
		public override dynamic Destroy( dynamic brokenup = null ) {
			this.controller.liquid_objects.Remove( this );
			base.Destroy( (object)(brokenup) );
			return null;
		}

		// Function from file: splash_simulation.dm
		public override bool Move( dynamic NewLoc = null, int? Dir = null, int step_x = 0, int step_y = 0 ) {
			return false;
		}

		// Function from file: splash_simulation.dm
		public void update_icon2(  ) {
			
			dynamic _a = this.volume; // Was a switch-case, sorry for the mess.
			if ( 0<=_a&&_a<=0.1 ) {
				GlobalFuncs.qdel( this );
			} else if ( 0.1<=_a&&_a<=5 ) {
				this.icon_state = "1";
			} else if ( 5<=_a&&_a<=10 ) {
				this.icon_state = "2";
			} else if ( 10<=_a&&_a<=20 ) {
				this.icon_state = "3";
			} else if ( 20<=_a&&_a<=30 ) {
				this.icon_state = "4";
			} else if ( 30<=_a&&_a<=40 ) {
				this.icon_state = "5";
			} else if ( 40<=_a&&_a<=50 ) {
				this.icon_state = "6";
			} else if ( 50<=_a&&_a<=Double.PositiveInfinity ) {
				this.icon_state = "7";
			}
			return;
		}

		// Function from file: splash_simulation.dm
		public void apply_calculated_effect(  ) {
			this.volume += this.new_volume;

			if ( Convert.ToDouble( this.volume ) < 0.05 ) {
				GlobalFuncs.qdel( this );
				return;
			}
			this.new_volume = 0;
			this.update_icon2();
			return;
		}

		// Function from file: splash_simulation.dm
		public void spread(  ) {
			double surrounding_volume = 0;
			ByTable spread_directions = null;
			Ent_Static loc_turf = null;
			dynamic direction = null;
			Tile T = null;
			dynamic L = null;
			Obj_Effect_Liquid NL = null;
			dynamic average_volume = null;
			dynamic volume_difference = null;
			dynamic volume_per_tile = null;
			dynamic direction2 = null;
			Tile T2 = null;
			dynamic L2 = null;

			surrounding_volume = 0;
			spread_directions = GlobalVars.cardinal;
			loc_turf = this.loc;

			foreach (dynamic _a in Lang13.Enumerate( spread_directions )) {
				direction = _a;
				
				T = Map13.GetStep( this, Convert.ToInt32( direction ) );

				if ( !( T != null ) ) {
					spread_directions.Remove( direction );
					continue;
				}

				if ( !Lang13.Bool( ((dynamic)loc_turf).can_leave_liquid( direction ) ) ) {
					spread_directions.Remove( direction );
					continue;
				}

				if ( !T.can_accept_liquid( Num13.Rotate( direction, 180 ) ) ) {
					spread_directions.Remove( direction );
					continue;
				}
				L = Lang13.FindIn( typeof(Obj_Effect_Liquid), T );

				if ( Lang13.Bool( L ) ) {
					
					if ( Convert.ToDouble( L.volume ) >= Convert.ToDouble( this.volume ) ) {
						spread_directions.Remove( direction );
						continue;
					}
					surrounding_volume += Convert.ToDouble( L.volume );
				} else {
					NL = new Obj_Effect_Liquid( T );
					NL.controller = this.controller;
					this.controller.liquid_objects.Add( NL );
				}
			}

			if ( !( spread_directions.len != 0 ) ) {
				return;
			}
			average_volume = ( this.volume + surrounding_volume ) / ( spread_directions.len + 1 );
			volume_difference = this.volume - average_volume;

			if ( Convert.ToDouble( volume_difference ) <= spread_directions.len * 0.05 ) {
				return;
			}
			volume_per_tile = volume_difference / spread_directions.len;

			foreach (dynamic _b in Lang13.Enumerate( spread_directions )) {
				direction2 = _b;
				
				T2 = Map13.GetStep( this, Convert.ToInt32( direction2 ) );

				if ( !( T2 != null ) ) {
					continue;
				}
				L2 = Lang13.FindIn( typeof(Obj_Effect_Liquid), T2 );

				if ( Lang13.Bool( L2 ) ) {
					this.volume -= volume_per_tile;
					L2.new_volume = L2.new_volume + Convert.ToDouble( volume_per_tile );
				}
			}
			return;
		}

	}

}