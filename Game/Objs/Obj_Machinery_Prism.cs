// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Obj_Machinery_Prism : Obj_Machinery {

		public Obj_Effect_Beam_Emitter beam = null;
		public ByTable powerchange_hooks = new ByTable();

		protected override void __FieldInit() {
			base.__FieldInit();

			this.use_power = 0;
			this.machine_flags = 14;
			this.icon = "icons/obj/machines/optical/prism.dmi";
			this.icon_state = "prism_off";
		}

		// Function from file: prism.dm
		public Obj_Machinery_Prism ( dynamic loc = null ) : base( (object)(loc) ) {
			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;
			this.component_parts = new ByTable(new object [] { new Obj_Item_Weapon_Circuitboard_Prism() });
			GlobalVars.prism_list.Add( this );
			return;
		}

		// Function from file: prism.dm
		public override void beam_disconnect( Obj_Effect_Beam B = null ) {
			
			if ( B is Obj_Effect_Beam_Emitter ) {
				
				if ( Lang13.Bool( B.HasSource( this ) ) ) {
					return;
				}
				base.beam_disconnect( B );
				((dynamic)B).power_change.Remove( this.powerchange_hooks[B] );
				this.powerchange_hooks.Remove( B );
				this.update_beams( B );
			}
			return;
		}

		// Function from file: prism.dm
		public override bool beam_connect( Obj_Effect_Beam B = null ) {
			
			if ( B is Obj_Effect_Beam_Emitter ) {
				
				if ( Lang13.Bool( B.HasSource( this ) ) ) {
					return false;
				}
				base.beam_connect( B );
				this.powerchange_hooks[B] = ((dynamic)B).power_change.Add( this, "on_power_change" );
				this.update_beams( B );
			}
			return false;
		}

		// Function from file: prism.dm
		public override int wrenchAnchor( dynamic user = null ) {
			int _default = 0;

			_default = base.wrenchAnchor( (object)(user) );

			if ( _default == 1 ) {
				
				if ( this.beams != null && this.beams.len != 0 ) {
					this.update_beams();
				}
			}
			return _default;
		}

		// Function from file: prism.dm
		public bool update_beams( Obj_Effect_Beam touching_beam = null ) {
			bool newbeam = false;
			ByTable spawners = null;
			Obj_Effect_Beam_Emitter B = null;
			int beamdir = 0;

			this.overlays.len = 0;

			if ( Map13.GetDistance( this, touching_beam ) == this.dir ) {
				return false;
			}

			if ( !( this.beams != null ) ) {
				
				if ( this.loc != null || !Lang13.Bool( this.gcDestroyed ) ) {
					this.beams = new ByTable();
				} else {
					return false;
				}
			}

			if ( this.beams.len > 0 && Lang13.Bool( this.anchored ) ) {
				newbeam = false;

				if ( !( this.beam != null ) ) {
					this.beam = new Obj_Effect_Beam_Emitter( this.loc );
					this.beam.dir = this.dir;
					newbeam = true;
				}
				this.beam.power = 0;
				spawners = new ByTable(new object [] { this });

				foreach (dynamic _a in Lang13.Enumerate( this.beams, typeof(Obj_Effect_Beam_Emitter) )) {
					B = _a;
					

					if ( Map13.GetDistance( this, B ) == this.dir ) {
						continue;
					}

					if ( Lang13.Bool( B.HasSource( this ) ) ) {
						Game13.log.WriteMsg( "## WARNING: " + ( "Ignoring beam " + B + " due to recursion." ) );
						continue;
					}
					spawners.Or( B.sources );
					this.beam.power += B.power ??0;

					if ( this.beam.steps < B.steps + 1 ) {
						this.beam.steps = B.steps + 1;
					}
					beamdir = Map13.GetDistance( B.loc, this );
					this.overlays.Add( new Image( this.icon, null, "beam_arrow", null, beamdir ) );
				}

				if ( newbeam ) {
					this.beam.emit( spawners );
				} else {
					this.beam.set_power( this.beam.power );
				}
				this.icon_state = "prism_on";
			} else {
				this.icon_state = "prism_off";
				GlobalFuncs.qdel( this.beam );
				this.beam = null;
			}
			return false;
		}

		// Function from file: prism.dm
		public void on_power_change( dynamic args = null ) {
			this.update_beams();
			return;
		}

		// Function from file: prism.dm
		public bool check_rotation(  ) {
			Obj_Effect_Beam_Emitter B = null;

			
			foreach (dynamic _a in Lang13.Enumerate( this.beams, typeof(Obj_Effect_Beam_Emitter) )) {
				B = _a;
				
				GlobalFuncs.to_chat( typeof(Game13), new Txt().item( this ).str( " " ).Ref( this ).str( " found " ).item( Map13.GetDistance( this, B ) ).str( " its dir is " ).item( this.dir ).ToString() );

				if ( Map13.GetDistance( this, B ) != this.dir ) {
					return true;
				}
			}
			return false;
		}

		// Function from file: prism.dm
		public override dynamic Destroy( dynamic brokenup = null ) {
			GlobalFuncs.qdel( this.beam );
			this.beam = null;
			GlobalVars.prism_list.Remove( this );
			base.Destroy( (object)(brokenup) );
			return null;
		}

		// Function from file: prism.dm
		[Verb]
		[VerbInfo( name: "Rotate (Counter-Clockwise)", group: "Object", access: VerbAccess.InViewExcludeThis, range: 1 )]
		public bool rotate_ccw(  ) {
			
			if ( Lang13.Bool( this.anchored ) ) {
				GlobalFuncs.to_chat( Task13.User, "It is fastened to the floor!" );
				return false;
			}
			this.dir = Num13.Rotate( this.dir, 90 );
			GlobalFuncs.qdel( this.beam );
			this.beam = null;
			this.update_beams();
			return true;
		}

		// Function from file: prism.dm
		[Verb]
		[VerbInfo( name: "Rotate (Clockwise)", group: "Object", access: VerbAccess.InViewExcludeThis, range: 1 )]
		public bool rotate_cw(  ) {
			
			if ( Lang13.Bool( this.anchored ) ) {
				GlobalFuncs.to_chat( Task13.User, "It is fastened to the floor!" );
				return false;
			}
			this.dir = Num13.Rotate( this.dir, -90 );
			GlobalFuncs.qdel( this.beam );
			this.beam = null;
			this.update_beams();
			return true;
		}

	}

}