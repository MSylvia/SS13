// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Obj_Effect_Decal_Cleanable_Blood_Tracks : Obj_Effect_Decal_Cleanable_Blood {

		public int dirs = 0;
		public string coming_state = "blood1";
		public string going_state = "blood2";
		public int updatedtracks = 0;
		public ByTable setdirs = new ByTable().Set( "1", 0 ).Set( "2", 0 ).Set( "4", 0 ).Set( "8", 0 ).Set( "16", 0 ).Set( "32", 0 ).Set( "64", 0 ).Set( "128", 0 );
		public ByTable stack = new ByTable();

		protected override void __FieldInit() {
			base.__FieldInit();

			this.random_icon_states = null;
			this.icon = "icons/effects/fluidtracks.dmi";
		}

		public Obj_Effect_Decal_Cleanable_Blood_Tracks ( dynamic loc = null ) : base( (object)(loc) ) {
			
		}

		// Function from file: tracks.dm
		public override bool? update_icon( dynamic location = null, dynamic target = null ) {
			dynamic truedir = null;
			Icon flat = null;
			Fluidtrack track = null;
			dynamic stack_idx = null;
			string state = null;
			Icon add = null;

			truedir = 0;
			flat = new Icon( "icons/effects/fluidtracks.dmi" );

			foreach (dynamic _a in Lang13.Enumerate( this.stack, typeof(Fluidtrack) )) {
				track = _a;
				
				stack_idx = this.setdirs["" + track.direction];
				state = this.coming_state;
				truedir = track.direction;

				if ( Lang13.Bool( truedir & 240 ) ) {
					state = this.going_state;
					truedir = truedir >> 4;
				}
				add = new Icon( "icons/effects/fluidtracks.dmi", state, truedir );
				add.SwapColor( "#FFFFFF", track.basecolor );
				this.overlays.Add( add );
				track.fresh = false;
				this.stack[stack_idx] = track;
			}
			this.icon = flat;
			this.updatedtracks = 0;
			return null;
		}

		// Function from file: tracks.dm
		public void AddTracks( ByTable DNA = null, int comingdir = 0, bool goingdir = false, string bloodcolor = null ) {
			bloodcolor = bloodcolor ?? "#A10808";

			bool updated = false;
			int realgoing = 0;
			int t = 0;
			Fluidtrack track = null;
			dynamic b = null;
			dynamic sid = null;
			dynamic key = null;
			dynamic sid2 = null;
			dynamic key2 = null;

			updated = false;
			realgoing = ( goingdir ?1:0) << 4;
			t = Game13.time + 50;

			foreach (dynamic _c in Lang13.Enumerate( GlobalVars.cardinal )) {
				b = _c;
				

				if ( ( comingdir & Convert.ToInt32( b ) ) != 0 ) {
					
					if ( ( this.dirs & Convert.ToInt32( b ) ) != 0 ) {
						sid = this.setdirs["" + b];
						track = this.stack[sid];

						if ( track.wet == t && track.basecolor == bloodcolor ) {
							continue;
						}
						this.stack.Remove( track );
					}
					track = new Fluidtrack( b, bloodcolor, t );

					if ( !( this.stack is ByTable ) ) {
						this.stack = new ByTable();
					}
					this.stack.Add( track );

					if ( !( this.setdirs != null ) || !( this.setdirs is ByTable ) || this.setdirs.len < 8 || this.setdirs["" + b] == null ) {
						Game13.log.WriteMsg( "## WARNING: " + ( "" + this + " had a bad directional " + b + " or bad list " + this.setdirs.len ) );
						Game13.log.WriteMsg( "## WARNING: " + "Setdirs keys:" );

						foreach (dynamic _a in Lang13.Enumerate( this.setdirs )) {
							key = _a;
							
							Game13.log.WriteMsg( "## WARNING: " + key );
						}
						this.setdirs = new ByTable().Set( "1", 0 ).Set( "2", 0 ).Set( "4", 0 ).Set( "8", 0 ).Set( "16", 0 ).Set( "32", 0 ).Set( "64", 0 ).Set( "128", 0 );
					}
					this.setdirs["" + b] = this.stack.Find( track );
					this.updatedtracks |= Convert.ToInt32( b );
					updated = true;
				}
				b = b << 4;

				if ( ( realgoing & Convert.ToInt32( b ) ) != 0 ) {
					
					if ( ( this.dirs & Convert.ToInt32( b ) ) != 0 ) {
						sid2 = this.setdirs["" + b];
						track = this.stack[sid2];

						if ( track.wet == t && track.basecolor == bloodcolor ) {
							continue;
						}
						this.stack.Remove( track );
					}
					track = new Fluidtrack( b, bloodcolor, t );

					if ( !( this.stack is ByTable ) ) {
						this.stack = new ByTable();
					}
					this.stack.Add( track );

					if ( !( this.setdirs != null ) || !( this.setdirs is ByTable ) || this.setdirs.len < 8 || this.setdirs["" + b] == null ) {
						Game13.log.WriteMsg( "## WARNING: " + ( "" + this + " had a bad directional " + b + " or bad list " + this.setdirs.len ) );
						Game13.log.WriteMsg( "## WARNING: " + "Setdirs keys:" );

						foreach (dynamic _b in Lang13.Enumerate( this.setdirs )) {
							key2 = _b;
							
							Game13.log.WriteMsg( "## WARNING: " + key2 );
						}
						this.setdirs = new ByTable().Set( "1", 0 ).Set( "2", 0 ).Set( "4", 0 ).Set( "8", 0 ).Set( "16", 0 ).Set( "32", 0 ).Set( "64", 0 ).Set( "128", 0 );
					}
					this.setdirs["" + b] = this.stack.Find( track );
					this.updatedtracks |= Convert.ToInt32( b );
					updated = true;
				}
			}
			this.dirs |= comingdir | realgoing;

			if ( DNA is ByTable ) {
				this.blood_DNA.Or( DNA.Copy() );
			}

			if ( updated ) {
				this.update_icon();
			}
			return;
		}

		// Function from file: tracks.dm
		public override dynamic resetVariables( string args = null, params object[] _ ) {
			ByTable _args = new ByTable( new object[] { args } ).Extend(_);

			this.stack = new ByTable();
			base.resetVariables( "stack", "setdirs" );
			this.setdirs = new ByTable().Set( "1", 0 ).Set( "2", 0 ).Set( "4", 0 ).Set( "8", 0 ).Set( "16", 0 ).Set( "32", 0 ).Set( "64", 0 ).Set( "128", 0 );
			return null;
		}

		// Function from file: tracks.dm
		public override dynamic process(  ) {
			return 26;
		}

	}

}