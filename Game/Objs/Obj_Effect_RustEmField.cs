// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Obj_Effect_RustEmField : Obj_Effect {

		public double major_radius = 0;
		public double minor_radius = 0;
		public int size = 1;
		public double volume_covered = 0;
		public Obj_Machinery_Power_RustCore owned_core = null;
		public ByTable dormant_reactant_quantities = new ByTable();
		public double energy = 0;
		public double mega_energy = 0;
		public double radiation = 0;
		public int? frequency = 1;
		public double field_strength = 0.01;
		public Obj_Machinery_Rust_RadSource radiator = null;
		public GasMixture held_plasma = new GasMixture();
		public ByTable particle_catchers = new ByTable( 13 );
		public bool emp_overload = false;

		protected override void __FieldInit() {
			base.__FieldInit();

			this.alpha = 50;
			this.icon = "code/WorkInProgress/Cael_Aislinn/Rust/rust.dmi";
			this.icon_state = "emfield_s1";
			this.layer = 3.1;
		}

		// Function from file: core_field.dm
		public Obj_Effect_RustEmField ( dynamic loc = null, Obj_Machinery_Power_RustCore new_owned_core = null ) : base( (object)(loc) ) {
			Obj_Machinery_Rust_RadSource rad = null;
			Obj_Effect_RustParticleCatcher catcher = null;

			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;

			foreach (dynamic _a in Lang13.Enumerate( Map13.FetchInRange( null, 0 ), typeof(Obj_Machinery_Rust_RadSource) )) {
				rad = _a;
				
				this.radiator = rad;
			}

			if ( !( this.radiator != null ) ) {
				this.radiator = new Obj_Machinery_Rust_RadSource();
			}
			this.owned_core = new_owned_core;

			if ( !( this.owned_core != null ) ) {
				GlobalFuncs.qdel( this );
			}
			catcher = null;
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x, this.y, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 1 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x - 1, this.y, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 3 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x + 1, this.y, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 3 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x, this.y + 1, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 3 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x, this.y - 1, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 3 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x - 2, this.y, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 5 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x + 2, this.y, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 5 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x, this.y + 2, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 5 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x, this.y - 2, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 5 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x - 3, this.y, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 7 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x + 3, this.y, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 7 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x, this.y + 3, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 7 );
			this.particle_catchers.Add( catcher );
			catcher = new Obj_Effect_RustParticleCatcher( Map13.GetTile( this.x, this.y - 3, this.z ) );
			catcher.parent = this;
			catcher.SetSize( 7 );
			this.particle_catchers.Add( catcher );
			this.major_radius = this.field_strength * 0.21875;
			this.minor_radius = this.field_strength * 0.2125;
			this.volume_covered = this.major_radius * this.minor_radius * 19634.376953125;
			GlobalVars.processing_objects.Add( this );
			return;
		}

		// Function from file: core_field.dm
		public override int? bullet_act( dynamic Proj = null, dynamic def_zone = null ) {
			
			if ( Proj.flag != "bullet" ) {
				this.AddEnergy( Convert.ToInt32( Proj.damage * 20 ), false, 1 );
				this.update_icon();
			}
			return 0;
		}

		// Function from file: core_field.dm
		public override dynamic Destroy( dynamic brokenup = null ) {
			dynamic _default = null;

			Obj_Effect_RustParticleCatcher catcher = null;

			
			foreach (dynamic _a in Lang13.Enumerate( this.particle_catchers, typeof(Obj_Effect_RustParticleCatcher) )) {
				catcher = _a;
				
				GlobalFuncs.qdel( catcher );
			}
			this.owned_core.owned_field = null;
			this.owned_core = null;
			this.RadiateAll();
			GlobalVars.processing_objects.Remove( this );
			_default = base.Destroy( (object)(brokenup) );
			return _default;
		}

		// Function from file: core_field.dm
		public void React(  ) {
			ByTable reactants_reacting_pool = null;
			dynamic reactant = null;
			ByTable produced_reactants = null;
			ByTable primary_reactant_pool = null;
			dynamic cur_primary_reactant = null;
			ByTable possible_secondary_reactants = null;
			ByTable possible_reactions = null;
			dynamic cur_secondary_reactant = null;
			dynamic cur_reaction = null;
			dynamic cur_reaction2 = null;
			int max_num_reactants = 0;
			int amount_reacting = 0;
			dynamic reactant2 = null;
			bool success = false;
			dynamic check_reactant = null;
			dynamic reactant3 = null;
			dynamic reactant4 = null;

			reactants_reacting_pool = this.dormant_reactant_quantities.Copy();

			if ( reactants_reacting_pool.len != 0 ) {
				
				foreach (dynamic _a in Lang13.Enumerate( reactants_reacting_pool )) {
					reactant = _a;
					
					reactants_reacting_pool[reactant] = Rand13.Int( 0, Convert.ToInt32( reactants_reacting_pool[reactant] ) );
					this.dormant_reactant_quantities[reactant] -= reactants_reacting_pool[reactant];

					if ( !Lang13.Bool( reactants_reacting_pool[reactant] ) ) {
						reactants_reacting_pool.Remove( reactant );
					}
				}
				produced_reactants = new ByTable();
				primary_reactant_pool = reactants_reacting_pool.Copy();

				while (primary_reactant_pool.len != 0) {
					cur_primary_reactant = Rand13.PickFromTable( primary_reactant_pool );
					primary_reactant_pool.Remove( cur_primary_reactant );
					possible_secondary_reactants = reactants_reacting_pool.Copy();
					possible_secondary_reactants[cur_primary_reactant] -= 1;

					if ( Convert.ToDouble( possible_secondary_reactants[cur_primary_reactant] ) < 1 ) {
						possible_secondary_reactants.Remove( cur_primary_reactant );
					}
					possible_reactions = new ByTable();

					foreach (dynamic _b in Lang13.Enumerate( possible_secondary_reactants )) {
						cur_secondary_reactant = _b;
						

						if ( Convert.ToDouble( possible_secondary_reactants[cur_secondary_reactant] ) < 1 ) {
							continue;
						}
						cur_reaction = GlobalFuncs.get_fusion_reaction( cur_primary_reactant, cur_secondary_reactant );

						if ( Lang13.Bool( cur_reaction ) ) {
							possible_reactions.Add( cur_reaction );
						}
					}

					if ( !( possible_reactions.len != 0 ) ) {
						continue;
					}

					while (possible_reactions.len != 0) {
						cur_reaction2 = Rand13.PickFromTable( possible_reactions );
						possible_reactions.Remove( cur_reaction2 );
						max_num_reactants = Convert.ToInt32( ( Convert.ToDouble( reactants_reacting_pool[cur_reaction2.primary_reactant] ) > Convert.ToDouble( reactants_reacting_pool[cur_reaction2.secondary_reactant] ) ? reactants_reacting_pool[cur_reaction2.secondary_reactant] : reactants_reacting_pool[cur_reaction2.primary_reactant] ) );

						if ( max_num_reactants < 1 ) {
							continue;
						}

						if ( this.mega_energy < max_num_reactants * Convert.ToDouble( cur_reaction2.energy_consumption ) ) {
							max_num_reactants = Num13.Floor( this.mega_energy / Convert.ToDouble( cur_reaction2.energy_consumption ) );

							if ( max_num_reactants < 1 ) {
								continue;
							}
						}
						amount_reacting = Rand13.Int( 1, max_num_reactants );

						if ( Convert.ToDouble( reactants_reacting_pool[cur_reaction2.primary_reactant] - amount_reacting ) >= 0 ) {
							reactants_reacting_pool[cur_reaction2.primary_reactant] -= amount_reacting;
						} else {
							amount_reacting = Convert.ToInt32( reactants_reacting_pool[cur_reaction2.primary_reactant] );
							reactants_reacting_pool[cur_reaction2.primary_reactant] = 0;
						}

						if ( Convert.ToDouble( reactants_reacting_pool[cur_reaction2.secondary_reactant] - amount_reacting ) >= 0 ) {
							reactants_reacting_pool[cur_reaction2.secondary_reactant] -= amount_reacting;
						} else {
							reactants_reacting_pool[cur_reaction2.primary_reactant] += amount_reacting - Convert.ToDouble( reactants_reacting_pool[cur_reaction2.primary_reactant] );
							amount_reacting = Convert.ToInt32( reactants_reacting_pool[cur_reaction2.secondary_reactant] );
							reactants_reacting_pool[cur_reaction2.secondary_reactant] = 0;
						}
						this.mega_energy -= max_num_reactants * Convert.ToDouble( cur_reaction2.energy_consumption );
						this.mega_energy += max_num_reactants * cur_reaction2.energy_production;
						this.radiation += max_num_reactants * Convert.ToDouble( cur_reaction2.radiation );

						foreach (dynamic _d in Lang13.Enumerate( cur_reaction2.products )) {
							reactant2 = _d;
							
							success = false;

							foreach (dynamic _c in Lang13.Enumerate( produced_reactants )) {
								check_reactant = _c;
								

								if ( check_reactant == reactant2 ) {
									produced_reactants[reactant2] += cur_reaction2.products[reactant2] * amount_reacting;
									success = true;
									break;
								}
							}

							if ( !success ) {
								produced_reactants[reactant2] = cur_reaction2.products[reactant2] * amount_reacting;
							}
						}
						possible_reactions.Remove( cur_reaction2.secondary_reactant );
					}
				}

				foreach (dynamic _e in Lang13.Enumerate( produced_reactants )) {
					reactant3 = _e;
					
					this.AddParticles( reactant3, Lang13.BoolNullable( produced_reactants[reactant3] ) );
				}

				foreach (dynamic _f in Lang13.Enumerate( reactants_reacting_pool )) {
					reactant4 = _f;
					
					this.AddParticles( reactant4, Lang13.BoolNullable( reactants_reacting_pool[reactant4] ) );
				}
			}
			return;
		}

		// Function from file: core_field.dm
		public int change_size( int? newsize = null ) {
			newsize = newsize ?? 1;

			int changed = 0;
			Obj_Effect_RustParticleCatcher catcher = null;

			changed = 0;

			switch ((int?)( newsize )) {
				case 1:
					this.size = 1;
					this.icon = "code/WorkInProgress/Cael_Aislinn/Rust/rust.dmi";
					this.icon_state = "emfield_s1";
					this.pixel_x = 0;
					this.pixel_y = 0;
					changed = 1;
					break;
				case 3:
					this.size = 3;
					this.icon = "icons/effects/96x96.dmi";
					this.icon_state = "emfield_s3";
					this.pixel_x = -32;
					this.pixel_y = -32;
					changed = 3;
					break;
				case 5:
					this.size = 5;
					this.icon = "icons/effects/160x160.dmi";
					this.icon_state = "emfield_s5";
					this.pixel_x = -64;
					this.pixel_y = -64;
					changed = 5;
					break;
				case 7:
					this.size = 7;
					this.icon = "icons/effects/224x224.dmi";
					this.icon_state = "emfield_s7";
					this.pixel_x = -96;
					this.pixel_y = -96;
					changed = 7;
					break;
			}

			foreach (dynamic _b in Lang13.Enumerate( this.particle_catchers, typeof(Obj_Effect_RustParticleCatcher) )) {
				catcher = _b;
				
				catcher.UpdateSize();
			}
			return changed;
		}

		// Function from file: core_field.dm
		public void RadiateAll( bool? ratio_lost = null ) {
			ratio_lost = ratio_lost ?? true;

			dynamic particle = null;
			GasMixture environment = null;

			
			foreach (dynamic _a in Lang13.Enumerate( this.dormant_reactant_quantities )) {
				particle = _a;
				
				this.radiation += Convert.ToDouble( this.dormant_reactant_quantities[particle] );
				this.dormant_reactant_quantities.Remove( particle );
			}
			this.radiation += this.mega_energy;
			this.mega_energy = 0;
			environment = this.loc.return_air();
			environment.merge( this.held_plasma );
			return;
		}

		// Function from file: core_field.dm
		public void AddParticles( dynamic name = null, bool? quantity = null ) {
			quantity = quantity ?? true;

			
			if ( this.dormant_reactant_quantities.Contains( name ) ) {
				this.dormant_reactant_quantities[name] += quantity;
			} else if ( name != "proton" && name != "electron" && name != "neutron" ) {
				this.dormant_reactant_quantities.Add( name );
				this.dormant_reactant_quantities[name] = quantity;
			}
			return;
		}

		// Function from file: core_field.dm
		public void AddEnergy( int a_energy = 0, bool a_mega_energy = false, int? a_frequency = null ) {
			double energy_loss_ratio = 0;

			energy_loss_ratio = 0;

			if ( a_frequency != this.frequency ) {
				energy_loss_ratio = 1 / Math.Abs( ( a_frequency ??0) - ( this.frequency ??0) );
			}
			this.energy += a_energy - a_energy * energy_loss_ratio;
			this.mega_energy += ( a_mega_energy ?1:0) - ( a_mega_energy ?1:0) * energy_loss_ratio;

			while (this.energy > 100000) {
				this.energy -= 100000;
				this.mega_energy += 0.1;
			}
			return;
		}

		// Function from file: core_field.dm
		public void ChangeFieldFrequency( int new_frequency = 0 ) {
			this.frequency = new_frequency;
			return;
		}

		// Function from file: core_field.dm
		public void ChangeFieldStrength( int new_strength = 0 ) {
			int? calc_size = null;

			calc_size = 1;
			this.emp_overload = false;

			if ( new_strength <= 50 ) {
				calc_size = 1;
			} else if ( new_strength <= 200 ) {
				calc_size = 3;
			} else if ( new_strength <= 500 ) {
				calc_size = 5;
			} else {
				calc_size = 7;

				if ( new_strength > 900 ) {
					this.emp_overload = true;
				}
			}
			this.field_strength = new_strength;
			this.change_size( calc_size );
			return;
		}

		// Function from file: core_field.dm
		public override dynamic process(  ) {
			double transfer_ratio = 0;
			GasMixture environment = null;
			dynamic moles_covered = null;
			GasMixture gas_covered = null;
			GasMixture plasma_captured = null;
			double heat_capacity = 0;
			double loss_ratio = 0;
			GasMixture plasma_lost = null;
			dynamic reactant = null;
			int amount = 0;
			int radiate = 0;

			
			if ( !( this.owned_core != null ) ) {
				GlobalFuncs.qdel( this );
			}

			if ( !( this.radiator != null ) ) {
				this.radiator = new Obj_Machinery_Rust_RadSource();
			}
			this.radiator.mega_energy += this.radiation;
			this.radiator.source_alive++;
			this.radiation = 0;
			transfer_ratio = this.field_strength / 50;
			this.major_radius = this.field_strength * 0.21875;
			this.minor_radius = this.field_strength * 0.2125;
			this.volume_covered = this.major_radius * this.minor_radius * transfer_ratio * 2405.211181640625;
			environment = this.loc.return_air();

			if ( Convert.ToDouble( this.held_plasma.toxins ) < transfer_ratio * 1000 ) {
				moles_covered = environment.return_pressure() * this.volume_covered / ( ( environment.temperature ??0) * 8.314 );
				gas_covered = environment.remove( moles_covered );
				plasma_captured = new GasMixture();
				plasma_captured.toxins = Num13.Floor( Convert.ToDouble( gas_covered.toxins * transfer_ratio ) );
				plasma_captured.temperature = gas_covered.temperature;
				plasma_captured.update_values();
				gas_covered.toxins -= plasma_captured.toxins;
				gas_covered.update_values();
				this.held_plasma.merge( plasma_captured );
				environment.merge( gas_covered );
			}
			this.React();

			if ( this.mega_energy > 0 && Lang13.Bool( this.held_plasma.toxins ) ) {
				heat_capacity = this.held_plasma.heat_capacity();

				if ( heat_capacity > 0.0003 ) {
					this.held_plasma.temperature = ( heat_capacity + this.mega_energy * 35000 ) / heat_capacity;
				}
			}

			if ( Convert.ToDouble( this.held_plasma.toxins ) > 1 ) {
				loss_ratio = Rand13.Float() * ( 2.5 / this.field_strength + 0.05 );
				plasma_lost = new GasMixture();
				plasma_lost.temperature = this.held_plasma.temperature;
				plasma_lost.toxins = this.held_plasma.toxins * loss_ratio;
				this.held_plasma.toxins -= this.held_plasma.toxins * loss_ratio;
				environment.merge( plasma_lost );
				this.radiation += loss_ratio * this.mega_energy * 0.1;
				this.mega_energy -= loss_ratio * this.mega_energy * 0.1;
			} else {
				this.held_plasma.toxins = 0;
			}

			foreach (dynamic _a in Lang13.Enumerate( this.dormant_reactant_quantities )) {
				reactant = _a;
				
				amount = Convert.ToInt32( this.dormant_reactant_quantities[reactant] );

				if ( amount < 1 ) {
					this.dormant_reactant_quantities.Remove( reactant );
				} else if ( amount >= 1000000 ) {
					radiate = Rand13.Int( ((int)( amount * 3 / 4 )), ((int)( amount / 4 )) );
					this.dormant_reactant_quantities[reactant] -= radiate;
					this.radiation += radiate;
				}
			}
			return 1;
		}

	}

}