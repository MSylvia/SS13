// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Obj_Effect_AcceleratedParticle : Obj_Effect {

		public int movement_range = 10;
		public int energy = 10;
		public bool mega_energy = false;
		public bool frequency = true;
		public bool ionizing = false;
		public dynamic particle_type = null;
		public int additional_particles = 0;
		public Ent_Static target = null;
		public Ent_Static source = null;
		public bool movetotarget = true;

		protected override void __FieldInit() {
			base.__FieldInit();

			this.anchored = 1;
			this.icon = "icons/obj/machines/particle_accelerator2.dmi";
			this.icon_state = "particle1";
		}

		// Function from file: particle.dm
		public Obj_Effect_AcceleratedParticle ( dynamic loc = null, int? dir = null, bool? move = null ) : base( (object)(loc) ) {
			dir = dir ?? 2;
			move = move ?? false;

			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;
			this.loc = loc;
			this.dir = dir ??0;
			return;
		}

		// Function from file: particle.dm
		public override bool ex_act( double? severity = null, dynamic child = null ) {
			GlobalFuncs.returnToPool( this );
			return false;
		}

		// Function from file: particle.dm
		public override bool Bumped( Ent_Static AM = null, dynamic yes = null ) {
			
			if ( AM is Mob ) {
				this.Bump( AM );
			}
			return false;
		}

		// Function from file: particle.dm
		public override dynamic Bump( Obj Obstacle = null, dynamic yes = null ) {
			Obj collided_catcher = null;
			Obj collided_core = null;
			double energy_loss_ratio = 0;

			
			if ( Obstacle != null ) {
				
				if ( Obstacle is Mob ) {
					this.toxmob( Obstacle );
				}

				if ( Obstacle is Obj_Machinery_TheSingularitygen || Obstacle is Obj_Machinery_Singularity ) {
					((dynamic)Obstacle).energy += this.energy;
				} else if ( Obstacle is Obj_Effect_RustParticleCatcher ) {
					collided_catcher = Obstacle;

					if ( Lang13.Bool( this.particle_type ) && this.particle_type != "neutron" ) {
						
						if ( Lang13.Bool( ((dynamic)collided_catcher).AddParticles( this.particle_type, this.additional_particles + 1 ) ) ) {
							((Obj_Effect_RustEmField)((dynamic)collided_catcher).parent).AddEnergy( this.energy, this.mega_energy );
							this.loc = null;
						}
					}
				} else if ( Obstacle is Obj_Machinery_Power_RustCore ) {
					collided_core = Obstacle;

					if ( Lang13.Bool( this.particle_type ) && this.particle_type != "neutron" ) {
						
						if ( Lang13.Bool( ((dynamic)collided_core).AddParticles( this.particle_type, this.additional_particles + 1 ) ) ) {
							energy_loss_ratio = Math.Abs( Convert.ToDouble( ((dynamic)collided_core).owned_field.frequency - this.frequency ) ) / 1000000000;
							((dynamic)collided_core).owned_field.mega_energy += ( this.mega_energy ?1:0) - ( this.mega_energy ?1:0) * energy_loss_ratio;
							((dynamic)collided_core).owned_field.energy += this.energy - this.energy * energy_loss_ratio;
							this.loc = null;
						}
					}
				}
			}
			return null;
		}

		// Function from file: particle.dm
		public bool move( int lag = 0 ) {
			
			if ( !( this.loc != null ) ) {
				return false;
			}

			if ( this.target != null ) {
				
				if ( this.movetotarget ) {
					Map13.StepTowardsSimple( this, this.target );

					if ( !false ) {
						this.loc = Map13.GetStep( this, Map13.GetDistance( this, this.target ) );
					}

					if ( Map13.GetDistance( this, this.target ) < 1 ) {
						this.movetotarget = false;
					}
				} else {
					Map13.Step( this, /*[I CANNOT CONVERT SOME RANDOM SHIT TO AN INT: Tile]*/ 0 );

					if ( !this.movetotarget ) {
						this.loc = Map13.GetStep( this, /*[I CANNOT CONVERT SOME RANDOM SHIT TO AN INT: Tile]*/ 0 );
					}
				}
			} else {
				Map13.Step( this, this.dir );

				if ( !( this.target != null ) ) {
					this.loc = Map13.GetStep( this, this.dir );
				}
			}
			this.movement_range--;

			if ( this.movement_range <= 0 ) {
				GlobalFuncs.returnToPool( this );
				this.loc = null;
				return false;
			} else {
				Task13.Sleep( lag );
				this.move( lag );
			}
			return false;
		}

		// Function from file: particle.dm
		public void toxmob( Obj M = null ) {
			int radiation = 0;

			radiation = this.energy * 2;
			((Mob_Living)M).apply_effect( radiation * 3, "irradiate", 0 );
			((Mob_Living)M).updatehealth();
			return;
		}

		// Function from file: particle.dm
		public void startMove( bool? move = null ) {
			move = move ?? false;

			
			if ( this.movement_range > 20 ) {
				this.movement_range = 20;
			}

			if ( move == true ) {
				Task13.Schedule( 0, (Task13.Closure)(() => {
					this.move( 1 );
					return;
				}));
			}
			return;
		}

		// Function from file: particle.dm
		public override dynamic resetVariables( string args = null, params object[] _ ) {
			ByTable _args = new ByTable( new object[] { args } ).Extend(_);

			base.resetVariables( "movement_range", "target", "ionizing", "particle_type", "source", "movetotarget", (object)(_args) );
			this.movement_range = 10;
			this.target = null;
			this.ionizing = false;
			this.particle_type = null;
			this.source = null;
			this.movetotarget = true;
			return null;
		}

	}

}