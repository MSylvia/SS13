// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Obj_Effect_ProcHolder_Spell_Targeted_Projectile : Obj_Effect_ProcHolder_Spell_Targeted {

		public string proj_icon = "icons/obj/projectiles.dmi";
		public string proj_icon_state = "spell";
		public string proj_name = "a spell projectile";
		public bool proj_trail = false;
		public int proj_trail_lifespan = 0;
		public string proj_trail_icon = "icons/obj/wizard.dmi";
		public string proj_trail_icon_state = "trail";
		public string proj_type = "/obj/effect/proc_holder/spell/targeted";
		public bool proj_lingering = false;
		public bool proj_homing = true;
		public bool proj_insubstantial = false;
		public bool proj_trigger_range = false;
		public int? proj_lifespan = 15;
		public int proj_step_delay = 1;

		public Obj_Effect_ProcHolder_Spell_Targeted_Projectile ( dynamic loc = null ) : base( (object)(loc) ) {
			
		}

		// Function from file: projectile.dm
		public override bool cast( dynamic targets = null, dynamic thearea = null, dynamic user = null ) {
			thearea = thearea ?? Task13.User;

			Mob_Living target = null;
			dynamic projectile = null;
			Type projectile_type = null;
			Ent_Static current_loc = null;
			int? i = null;
			Obj_Effect_Overlay trail = null;

			this.playMagSound();

			foreach (dynamic _a in Lang13.Enumerate( targets, typeof(Mob_Living) )) {
				target = _a;
				
				Task13.Schedule( 0, (Task13.Closure)(() => {
					projectile = null;

					if ( this.proj_type is string ) {
						projectile_type = Lang13.FindClass( this.proj_type );
						projectile = Lang13.Call( projectile_type, thearea );
					}

					if ( this.proj_type is Obj_Effect_ProcHolder_Spell ) {
						projectile = new Obj_Effect_ProcHolder_Spell_Targeted_Trigger( thearea );
						projectile.linked_spells.Add( this.proj_type );
					}
					projectile.icon = this.proj_icon;
					projectile.icon_state = this.proj_icon_state;
					projectile.dir = Map13.GetDistance( target, projectile );
					projectile.name = this.proj_name;
					current_loc = thearea.loc;
					projectile.loc = current_loc;
					i = null;
					i = 0;

					while (( i ??0) < ( this.proj_lifespan ??0)) {
						
						if ( !Lang13.Bool( projectile ) ) {
							break;
						}

						if ( this.proj_homing ) {
							
							if ( this.proj_insubstantial ) {
								projectile.dir = Map13.GetDistance( projectile, target );
								projectile.loc = Map13.GetStepTowards( projectile, target, 0 );
							} else {
								Map13.StepTowards( projectile, target, 0 );
							}
						} else if ( this.proj_insubstantial ) {
							projectile.loc = Map13.GetStep( projectile, this.dir );
						} else {
							Map13.Step( projectile, this.dir );
						}

						if ( !Lang13.Bool( projectile ) ) {
							break;
						}

						if ( !( target != null ) || !this.proj_lingering && projectile.loc == current_loc ) {
							GlobalFuncs.qdel( projectile );
							break;
						}

						if ( this.proj_trail && Lang13.Bool( projectile ) ) {
							Task13.Schedule( 0, (Task13.Closure)(() => {
								
								if ( Lang13.Bool( projectile ) ) {
									trail = new Obj_Effect_Overlay( projectile.loc );
									trail.icon = this.proj_trail_icon;
									trail.icon_state = this.proj_trail_icon_state;
									trail.density = false;
									Task13.Schedule( this.proj_trail_lifespan, (Task13.Closure)(() => {
										GlobalFuncs.qdel( trail );
										return;
									}));
								}
								return;
							}));
						}

						if ( Map13.FetchInRange( this.proj_trigger_range, target.loc ).Contains( projectile.loc ) ) {
							((Obj_Effect_ProcHolder_Spell)projectile).perform( new ByTable(new object [] { target }), null, thearea );
							break;
						}
						current_loc = projectile.loc;
						Task13.Sleep( this.proj_step_delay );
						i++;
					}

					if ( Lang13.Bool( projectile ) ) {
						GlobalFuncs.qdel( projectile );
					}
					return;
				}));
			}
			return false;
		}

	}

}