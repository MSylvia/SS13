// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Obj_Item_Weapon_BeaconDispenser : Obj_Item_Weapon {

		public ByTable beacons = new ByTable();
		public ByTable areas = new ByTable();
		public int id = 1;

		protected override void __FieldInit() {
			base.__FieldInit();

			this.icon = "icons/obj/bluespace_beacon.dmi";
			this.icon_state = "dispenser";
		}

		public Obj_Item_Weapon_BeaconDispenser ( dynamic loc = null ) : base( (object)(loc) ) {
			
		}

		// Function from file: beacon_designator.dm
		public override bool afterattack( dynamic A = null, dynamic user = null, bool? flag = null, dynamic _params = null, bool? struggle = null ) {
			dynamic T = null;
			dynamic AR = null;
			Obj_Item_BluespaceBeacon B = null;

			T = GlobalFuncs.get_turf( A );

			if ( A is Obj_Item_BluespaceBeacon ) {
				this.beacons.Remove( A );
				GlobalFuncs.qdel( A );
				return false;
			}
			AR = GlobalFuncs.get_area( T );

			if ( !Lang13.Bool( AR ) ) {
				return false;
			}

			if ( AR.name == "Space" ) {
				B = new Obj_Item_BluespaceBeacon( T );
				B.id = this.id;
				B.icon_state = "" + this.id;
				this.beacons.Or( B );
			} else {
				GlobalFuncs.to_chat( Task13.User, "There is already an area there." );
			}
			return false;
		}

		// Function from file: beacon_designator.dm
		public override dynamic attack_self( dynamic user = null, dynamic flag = null, bool? emp = null ) {
			this.id++;

			if ( this.id > 4 ) {
				this.id = 1;
			}
			GlobalFuncs.to_chat( user, "Spawning beacons with ID: " + this.id );
			return null;
		}

		// Function from file: beacon_designator.dm
		[Verb]
		[VerbInfo( name: "Create an area" )]
		public void commit(  ) {
			ByTable turfs = null;
			bool conflict = false;
			Obj_Item_BluespaceBeacon B = null;
			dynamic AR = null;
			Zone_Shuttle newarea = null;
			dynamic oldarea = null;
			dynamic T = null;
			Ent_Static allthings = null;

			turfs = new ByTable();
			conflict = false;

			foreach (dynamic _a in Lang13.Enumerate( this.beacons, typeof(Obj_Item_BluespaceBeacon) )) {
				B = _a;
				

				if ( B.id == this.id ) {
					AR = GlobalFuncs.get_area( B );

					if ( !( AR.type == typeof(Zone) ) ) {
						
						if ( !conflict ) {
							GlobalFuncs.to_chat( Task13.User, "One or more beacons are conflicting with another area. The area will not be created, and conflicting beacons will be marked as such." );
							conflict = true;
						}
						B.overlays.Add( new Image( "icons/obj/bluespace_beacon.dmi", null, "bad" ) );
					}
					turfs.Or( GlobalFuncs.get_turf( B ) );
				}
			}

			if ( conflict ) {
				return;
			}
			newarea = new Zone_Shuttle();
			this.areas.Add( newarea );
			this.areas[newarea] = this.id;
			oldarea = GlobalFuncs.get_area( Task13.User );
			newarea.name = Interface13.Input( Task13.User, "Select a name for the new area.", null, null, null, InputType.Str );
			newarea.tag = "" + newarea.type + "/" + Num13.Md5( newarea.name );
			newarea.lighting_use_dynamic = false;
			newarea.contents.Add( turfs );

			foreach (dynamic _c in Lang13.Enumerate( turfs )) {
				T = _c;
				
				((Ent_Static)T).change_area( oldarea, newarea );

				foreach (dynamic _b in Lang13.Enumerate( T.contents, typeof(Ent_Static) )) {
					allthings = _b;
					
					allthings.change_area( oldarea, newarea );
				}
			}
			newarea.addSorted();
			return;
		}

	}

}