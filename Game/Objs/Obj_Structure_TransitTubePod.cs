// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Obj_Structure_TransitTubePod : Obj_Structure {

		public bool moving = false;
		public GasMixture air_contents = new GasMixture();

		protected override void __FieldInit() {
			base.__FieldInit();

			this.anchored = 1;
			this.icon = "icons/obj/pipes/transit_tube_pod.dmi";
			this.icon_state = "pod";
		}

		// Function from file: transit_tubes.dm
		public Obj_Structure_TransitTubePod ( dynamic loc = null ) : base( (object)(loc) ) {
			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;
			this.air_contents.oxygen = 43.652183532714844;
			this.air_contents.nitrogen = 82.1076889038086;
			this.air_contents.temperature = 293.41;
			Task13.Schedule( 5, (Task13.Closure)(() => {
				this.follow_tube();
				return;
			}));
			return;
		}

		// Function from file: transit_tubes.dm
		public override dynamic relaymove( Mob M = null, double? direction = null ) {
			Obj_Structure_TransitTube_Station station = null;
			Obj_Structure_TransitTube tube = null;

			
			if ( M is Mob && M.client != null ) {
				
				if ( !Lang13.Bool( Lang13.FindIn( typeof(Obj_Structure_TransitTube), this.loc ) ) ) {
					M.loc = this.loc;
					M.client.Move( Map13.GetStep( this.loc, ((int)( direction ??0 )) ), ((int)( direction ??0 )) );
				}

				if ( !this.moving ) {
					
					foreach (dynamic _a in Lang13.Enumerate( this.loc, typeof(Obj_Structure_TransitTube_Station) )) {
						station = _a;
						
						Interface13.Stat( null, station.directions().Contains( this.dir ) );

						if ( station is Obj_Structure_TransitTube_Station ) {
							
							if ( !station.pod_moving ) {
								
								if ( direction == station.dir ) {
									
									if ( station.icon_state == "open" ) {
										M.loc = this.loc;
										M.client.Move( Map13.GetStep( this.loc, ((int)( direction ??0 )) ), ((int)( direction ??0 )) );
									} else {
										station.open_animation();
									}
								} else {
									Interface13.Stat( null, station.directions().Contains( direction ) );

									if ( direction == station.dir ) {
										this.dir = ((int)( direction ??0 ));
										station.launch_pod();
									}
								}
							}
							return null;
						}
					}

					foreach (dynamic _b in Lang13.Enumerate( this.loc, typeof(Obj_Structure_TransitTube) )) {
						tube = _b;
						
						Interface13.Stat( null, tube.directions().Contains( this.dir ) );

						if ( tube is Obj_Structure_TransitTube ) {
							
							if ( tube.has_exit( direction ) ) {
								this.dir = ((int)( direction ??0 ));
								return null;
							}
						}
					}
				}
			}
			return null;
		}

		// Function from file: transit_tubes.dm
		public override dynamic remove_air( dynamic amount = null ) {
			return this.air_contents.remove( amount );
		}

		// Function from file: transit_tubes.dm
		public override bool? assume_air( dynamic giver = null ) {
			return this.air_contents.merge( giver );
		}

		// Function from file: transit_tubes.dm
		public override GasMixture return_air(  ) {
			GasMixture GM = null;

			GM = new GasMixture();
			GM.oxygen = this.air_contents.oxygen;
			GM.carbon_dioxide = this.air_contents.carbon_dioxide;
			GM.nitrogen = this.air_contents.nitrogen;
			GM.toxins = this.air_contents.toxins;
			GM.temperature = this.air_contents.temperature;
			return GM;
		}

		// Function from file: transit_tubes.dm
		public void mix_air(  ) {
			GasMixture environment = null;
			dynamic env_pressure = null;
			dynamic int_pressure = null;
			dynamic total_pressure = null;
			int transfer_in = 0;
			int transfer_out = 0;
			dynamic from_env = null;
			GasMixture from_int = null;

			environment = this.loc.return_air();
			env_pressure = environment.return_pressure();
			int_pressure = this.air_contents.return_pressure();
			total_pressure = env_pressure + int_pressure;

			if ( total_pressure == 0 ) {
				return;
			}
			transfer_in = Num13.MaxInt( ((int)( 0.1 )), Convert.ToInt32( ( env_pressure - int_pressure ) * 0.5 / total_pressure ) );
			transfer_out = Num13.MaxInt( ((int)( 0.1 )), Convert.ToInt32( ( int_pressure - env_pressure ) * 0.3 / total_pressure ) );
			from_env = this.loc.remove_air( environment.f_total_moles() * transfer_in );
			from_int = this.air_contents.remove( this.air_contents.f_total_moles() * transfer_out );
			this.loc.assume_air( from_int );
			this.air_contents.merge( from_env );
			return;
		}

		// Function from file: transit_tubes.dm
		public void follow_tube(  ) {
			Obj_Structure_TransitTube current_tube = null;
			dynamic next_dir = null;
			Tile next_loc = null;
			int last_delay = 0;
			int exit_delay = 0;
			Obj_Structure_TransitTube tube = null;
			Obj_Structure_TransitTube tube2 = null;

			
			if ( this.moving ) {
				return;
			}
			this.moving = true;
			Task13.Schedule( 0, (Task13.Closure)(() => {
				current_tube = null;
				last_delay = 0;

				foreach (dynamic _a in Lang13.Enumerate( this.loc, typeof(Obj_Structure_TransitTube) )) {
					tube = _a;
					

					if ( tube.has_exit( this.dir ) ) {
						current_tube = tube;
						break;
					}
				}

				while (current_tube != null) {
					next_dir = current_tube.get_exit( this.dir );

					if ( !Lang13.Bool( next_dir ) ) {
						break;
					}
					exit_delay = current_tube.f_exit_delay( this, this.dir );
					last_delay += exit_delay;
					Task13.Sleep( exit_delay );
					next_loc = Map13.GetStep( this.loc, Convert.ToInt32( next_dir ) );
					current_tube = null;

					foreach (dynamic _b in Lang13.Enumerate( next_loc, typeof(Obj_Structure_TransitTube) )) {
						tube2 = _b;
						

						if ( tube2.has_entrance( next_dir ) ) {
							current_tube = tube2;
							break;
						}
					}

					if ( current_tube == null ) {
						this.dir = Convert.ToInt32( next_dir );
						this.Move( Map13.GetStep( this.loc, this.dir ) );
						break;
					}
					last_delay = current_tube.f_enter_delay( this, next_dir );
					Task13.Sleep( last_delay );
					this.dir = Convert.ToInt32( next_dir );
					this.loc = next_loc;
					this.density = current_tube.density;

					if ( current_tube != null && current_tube.should_stop_pod( this, next_dir ) ) {
						current_tube.pod_stopped( this, this.dir );
						break;
					}
				}
				this.density = true;

				if ( !( current_tube != null ) && last_delay <= 10 ) {
					
					do {
						Task13.Sleep( last_delay );

						if ( !( this.loc is Tile_Space ) ) {
							last_delay++;
						}

						if ( last_delay > 10 ) {
							break;
						}
					} while ( this.loc is Tile && this.Move( Map13.GetStep( this.loc, this.dir ) ) );
				}
				this.moving = false;
				return;
			}));
			return;
		}

		// Function from file: transit_tubes.dm
		public override dynamic Destroy( dynamic brokenup = null ) {
			Ent_Dynamic AM = null;

			
			foreach (dynamic _a in Lang13.Enumerate( this.contents, typeof(Ent_Dynamic) )) {
				AM = _a;
				
				AM.loc = this.loc;
			}
			base.Destroy( (object)(brokenup) );
			return null;
		}

	}

}