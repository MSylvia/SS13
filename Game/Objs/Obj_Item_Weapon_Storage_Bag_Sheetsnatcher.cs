// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Obj_Item_Weapon_Storage_Bag_Sheetsnatcher : Obj_Item_Weapon_Storage_Bag {

		public double capacity = 300;

		protected override void __FieldInit() {
			base.__FieldInit();

			this.icon = "icons/obj/mining.dmi";
			this.icon_state = "sheetsnatcher";
		}

		// Function from file: bags.dm
		public Obj_Item_Weapon_Storage_Bag_Sheetsnatcher ( dynamic loc = null ) : base( (object)(loc) ) {
			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;
			return;
		}

		// Function from file: bags.dm
		public override bool remove_from_storage( dynamic W = null, dynamic new_location = null, bool? force = null ) {
			dynamic S = null;
			dynamic temp = null;

			S = W;

			if ( !( S is Obj_Item_Stack_Sheet ) ) {
				return false;
			}

			if ( Convert.ToDouble( S.amount ) > Convert.ToDouble( S.max_amount ) ) {
				temp = Lang13.Call( S.type, this );
				temp.amount = S.amount - S.max_amount;
				S.amount = S.max_amount;
			}
			return base.remove_from_storage( (object)(S), (object)(new_location), force );
		}

		// Function from file: bags.dm
		public override void orient2hud( dynamic user = null ) {
			int adjusted_contents = 0;
			ByTable numbered_contents = null;
			Obj_Item_Stack_Sheet I = null;
			NumberedDisplay D = null;
			int row_num = 0;
			int col_count = 0;

			adjusted_contents = this.contents.len;

			if ( this.display_contents_with_number ) {
				numbered_contents = new ByTable();
				adjusted_contents = 0;

				foreach (dynamic _a in Lang13.Enumerate( this.contents, typeof(Obj_Item_Stack_Sheet) )) {
					I = _a;
					
					adjusted_contents++;
					D = new NumberedDisplay( I );
					D.number = I.amount;
					numbered_contents.Add( D );
				}
			}
			row_num = 0;
			col_count = Num13.MinInt( 7, this.storage_slots ??0 ) - 1;

			if ( adjusted_contents > 7 ) {
				row_num = Num13.Floor( ( adjusted_contents - 1 ) / 7 );
			}
			this.standard_orient_objs( row_num, col_count, numbered_contents );
			return;
		}

		// Function from file: bags.dm
		public override bool handle_item_insertion( dynamic W = null, bool? prevent_warning = null ) {
			prevent_warning = prevent_warning ?? false;

			dynamic S = null;
			double amount = 0;
			bool inserted = false;
			double current = 0;
			Obj_Item_Stack_Sheet S2 = null;
			Obj_Item_Stack_Sheet sheet = null;

			S = W;

			if ( !( S is Obj_Item_Stack_Sheet ) ) {
				return false;
			}
			inserted = false;
			current = 0;

			foreach (dynamic _a in Lang13.Enumerate( this.contents, typeof(Obj_Item_Stack_Sheet) )) {
				S2 = _a;
				
				current += S2.amount ??0;
			}

			if ( this.capacity < current + Convert.ToDouble( S.amount ) ) {
				amount = this.capacity - current;
			} else {
				amount = Convert.ToDouble( S.amount );
			}

			foreach (dynamic _b in Lang13.Enumerate( this.contents, typeof(Obj_Item_Stack_Sheet) )) {
				sheet = _b;
				

				if ( S.type == sheet.type ) {
					sheet.amount += amount;
					S.amount -= amount;
					inserted = true;
					break;
				}
			}

			if ( !inserted || !Lang13.Bool( S.amount ) ) {
				Task13.User.u_equip( S, true );
				Task13.User.update_icons();

				if ( Task13.User.client != null && Task13.User.s_active != this ) {
					Task13.User.client.screen.Remove( S );
				}

				if ( !Lang13.Bool( S.amount ) ) {
					GlobalFuncs.qdel( S );
					S = null;
				} else {
					S.loc = this;
				}
			}
			this.orient2hud( Task13.User );

			if ( Task13.User.s_active != null ) {
				((dynamic)Task13.User.s_active).show_to( Task13.User );
			}
			this.update_icon();
			return true;
		}

		// Function from file: bags.dm
		public override bool can_be_inserted( dynamic W = null, bool? stop_messages = null ) {
			stop_messages = stop_messages ?? false;

			double current = 0;
			Obj_Item_Stack_Sheet S = null;

			
			if ( !( W is Obj_Item_Stack_Sheet ) || W is Obj_Item_Stack_Sheet_Mineral_Sandstone || W is Obj_Item_Stack_Sheet_Wood ) {
				
				if ( !( stop_messages == true ) ) {
					GlobalFuncs.to_chat( Task13.User, "The snatcher does not accept " + W + "." );
				}
				return false;
			}
			current = 0;

			foreach (dynamic _a in Lang13.Enumerate( this.contents, typeof(Obj_Item_Stack_Sheet) )) {
				S = _a;
				
				current += S.amount ??0;
			}

			if ( this.capacity == current ) {
				
				if ( !( stop_messages == true ) ) {
					GlobalFuncs.to_chat( Task13.User, "<span class='warning'>The snatcher is full.</span>" );
				}
				return false;
			}
			return true;
		}

		// Function from file: bags.dm
		[Verb]
		[VerbInfo( name: "Empty Contents", group: "Object" )]
		public override void quick_empty(  ) {
			dynamic location = null;
			Obj_Item_Stack_Sheet S = null;
			dynamic N = null;
			int stacksize = 0;

			location = GlobalFuncs.get_turf( this );

			foreach (dynamic _a in Lang13.Enumerate( this.contents, typeof(Obj_Item_Stack_Sheet) )) {
				S = _a;
				

				while (Lang13.Bool( S.amount )) {
					N = Lang13.Call( S.type, location );
					stacksize = Num13.MinInt( ((int)( S.amount ??0 )), Convert.ToInt32( N.max_amount ) );
					N.amount = stacksize;
					S.amount -= stacksize;
				}

				if ( !Lang13.Bool( S.amount ) ) {
					GlobalFuncs.qdel( S );
					S = null;
				}
			}
			this.orient2hud( Task13.User );

			if ( Task13.User.s_active != null ) {
				((dynamic)Task13.User.s_active).show_to( Task13.User );
			}
			this.update_icon();
			return;
		}

	}

}