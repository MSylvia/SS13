// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class GameMode_Nuclear : GameMode {

		public Obj_Item nuclear_uplink = null;
		public int agents_possible = 5;
		public int waittime_l = 600;
		public int waittime_h = 1800;
		public int nukes_left = 1;
		public int nuke_off_station = 0;
		public bool syndies_didnt_escape = false;

		protected override void __FieldInit() {
			base.__FieldInit();

			this.name = "nuclear emergency";
			this.config_tag = "nuclear";
			this.required_players = 6;
			this.required_players_secret = 25;
			this.required_enemies = 5;
			this.recommended_enemies = 5;
			this.uplink_welcome = "Corporate Backed Uplink Console:";
			this.uplink_uses = 40;
		}

		// Function from file: nuclear.dm
		public override bool declare_completion( bool? ragin = null ) {
			bool disk_rescued = false;
			Obj_Item_Weapon_Disk_Nuclear D = null;
			dynamic disk_area = null;
			bool crew_evacuated = false;

			disk_rescued = true;

			foreach (dynamic _a in Lang13.Enumerate( typeof(Game13), typeof(Obj_Item_Weapon_Disk_Nuclear) )) {
				D = _a;
				
				disk_area = GlobalFuncs.get_area( D );

				if ( !GlobalFuncs.is_type_in_list( disk_area, GlobalVars.centcom_areas ) ) {
					disk_rescued = false;
					break;
				}
			}
			crew_evacuated = GlobalVars.emergency_shuttle.location == 2;

			if ( !disk_rescued && this.station_was_nuked && !this.syndies_didnt_escape ) {
				GlobalFuncs.feedback_set_details( "round_end_result", "win - syndicate nuke" );
				this.completion_text += "<FONT size = 3><B>Syndicate Major Victory!</B></FONT>";
				this.completion_text += "<BR><B>" + GlobalFuncs.syndicate_name() + " operatives have destroyed " + GlobalFuncs.station_name() + "!</B>";
			} else if ( !disk_rescued && this.station_was_nuked && this.syndies_didnt_escape ) {
				GlobalFuncs.feedback_set_details( "round_end_result", "halfwin - syndicate nuke - did not evacuate in time" );
				this.completion_text += "<FONT size = 3><B>Total Annihilation</B></FONT>";
				this.completion_text += "<BR><B>" + GlobalFuncs.syndicate_name() + " operatives destroyed " + GlobalFuncs.station_name() + " but did not leave the area in time and got caught in the explosion.</B> Next time, don't lose the disk!";
			} else if ( !disk_rescued && !this.station_was_nuked && this.nuke_off_station != 0 && !this.syndies_didnt_escape ) {
				GlobalFuncs.feedback_set_details( "round_end_result", "halfwin - blew wrong station" );
				this.completion_text += "<FONT size = 3><B>Crew Minor Victory</B></FONT>";
				this.completion_text += "<BR><B>" + GlobalFuncs.syndicate_name() + " operatives secured the authentication disk but blew up something that wasn't " + GlobalFuncs.station_name() + ".</B> Next time, don't lose the disk!";
			} else if ( !disk_rescued && !this.station_was_nuked && this.nuke_off_station != 0 && this.syndies_didnt_escape ) {
				GlobalFuncs.feedback_set_details( "round_end_result", "halfwin - blew wrong station - did not evacuate in time" );
				this.completion_text += "<FONT size = 3><B>" + GlobalFuncs.syndicate_name() + " operatives have earned Darwin Award!</B></FONT>";
				this.completion_text += "<BR><B>" + GlobalFuncs.syndicate_name() + " operatives blew up something that wasn't " + GlobalFuncs.station_name() + " and got caught in the explosion.</B> Next time, don't lose the disk!";
			} else if ( disk_rescued && this.is_operatives_are_dead() ) {
				GlobalFuncs.feedback_set_details( "round_end_result", "loss - evacuation - disk secured - syndi team dead" );
				this.completion_text += "<FONT size = 3><B>Crew Major Victory!</B></FONT>";
				this.completion_text += "<BR><B>The Research Staff has saved the disc and killed the " + GlobalFuncs.syndicate_name() + " Operatives</B>";
			} else if ( disk_rescued ) {
				GlobalFuncs.feedback_set_details( "round_end_result", "loss - evacuation - disk secured" );
				this.completion_text += "<FONT size = 3><B>Crew Major Victory</B></FONT>";
				this.completion_text += "<BR><B>The Research Staff has saved the disc and stopped the " + GlobalFuncs.syndicate_name() + " Operatives!</B>";
			} else if ( !disk_rescued && this.is_operatives_are_dead() ) {
				GlobalFuncs.feedback_set_details( "round_end_result", "loss - evacuation - disk not secured" );
				this.completion_text += "<FONT size = 3><B>Syndicate Minor Victory!</B></FONT>";
				this.completion_text += "<BR><B>The Research Staff failed to secure the authentication disk but did manage to kill most of the " + GlobalFuncs.syndicate_name() + " Operatives!</B>";
			} else if ( !disk_rescued && crew_evacuated ) {
				GlobalFuncs.feedback_set_details( "round_end_result", "halfwin - detonation averted" );
				this.completion_text += "<FONT size = 3><B>Syndicate Minor Victory!</B></FONT>";
				this.completion_text += "<BR><B>" + GlobalFuncs.syndicate_name() + " operatives recovered the abandoned authentication disk but detonation of " + GlobalFuncs.station_name() + " was averted.</B> Next time, don't lose the disk!";
			} else if ( !disk_rescued && !crew_evacuated ) {
				GlobalFuncs.feedback_set_details( "round_end_result", "halfwin - interrupted" );
				this.completion_text += "<FONT size = 3><B>Neutral Victory</B></FONT>";
				this.completion_text += "<BR><B>Round was mysteriously interrupted!</B>";
			}
			base.declare_completion( ragin );
			return false;
		}

		// Function from file: nuclear.dm
		public override bool check_win(  ) {
			
			if ( this.nukes_left == 0 ) {
				return true;
			}
			return base.check_win();
		}

		// Function from file: nuclear.dm
		public override bool post_setup(  ) {
			ByTable synd_spawn = null;
			Obj_Effect_Landmark A = null;
			dynamic uplinklocker = null;
			dynamic nuke_spawn = null;
			string nuke_code = null;
			bool leader_selected = false;
			int agent_number = 0;
			int spawnpos = 0;
			Mind synd_mind = null;
			Obj_Structure_Closet_Syndicate_Nuclear C = null;
			Obj_Item thing = null;
			Obj_Machinery_Nuclearbomb the_bomb = null;

			synd_spawn = new ByTable();

			foreach (dynamic _a in Lang13.Enumerate( GlobalVars.landmarks_list, typeof(Obj_Effect_Landmark) )) {
				A = _a;
				

				if ( A.name == "Syndicate-Spawn" ) {
					synd_spawn.Add( GlobalFuncs.get_turf( A ) );
					GlobalFuncs.qdel( A );
					A = null;
					continue;
				}
			}
			uplinklocker = Lang13.FindObj( "landmark*Syndicate-Uplink" );
			nuke_spawn = Lang13.FindObj( "landmark*Nuclear-Bomb" );
			nuke_code = "" + Rand13.Int( 10000, 99999 );
			leader_selected = false;
			agent_number = 1;
			spawnpos = 1;

			foreach (dynamic _b in Lang13.Enumerate( this.syndicates, typeof(Mind) )) {
				synd_mind = _b;
				

				if ( spawnpos > synd_spawn.len ) {
					spawnpos = 1;
				}
				synd_mind.current.loc = synd_spawn[spawnpos];
				this.forge_syndicate_objectives( synd_mind );
				this.greet_syndicate( synd_mind );
				this.equip_syndicate( synd_mind.current );

				if ( !leader_selected ) {
					this.prepare_syndicate_leader( synd_mind, nuke_code );
					leader_selected = true;
				} else {
					synd_mind.current.real_name = "" + GlobalFuncs.syndicate_name() + " Operative #" + agent_number;
					agent_number++;
				}
				spawnpos++;
				this.update_synd_icons_added( synd_mind );
			}
			this.update_all_synd_icons();

			if ( Lang13.Bool( uplinklocker ) ) {
				C = new Obj_Structure_Closet_Syndicate_Nuclear( uplinklocker.loc );
				Task13.Schedule( 10, (Task13.Closure)(() => {
					
					foreach (dynamic _c in Lang13.Enumerate( C, typeof(Obj_Item) )) {
						thing = _c;
						

						if ( thing.hidden_uplink != null ) {
							this.nuclear_uplink = thing;
							break;
						}
					}
					return;
				}));
			}

			if ( Lang13.Bool( nuke_spawn ) && synd_spawn.len > 0 ) {
				the_bomb = new Obj_Machinery_Nuclearbomb( nuke_spawn.loc );
				the_bomb.r_code = nuke_code;
			}
			Task13.Schedule( Rand13.Int( GlobalVars.waittime_l, GlobalVars.waittime_h ), (Task13.Closure)(() => {
				
				if ( !this.mixed ) {
					this.send_intercept();
				}
				return;
			}));
			return base.post_setup();
		}

		// Function from file: nuclear.dm
		public override bool pre_setup(  ) {
			return true;
		}

		// Function from file: nuclear.dm
		public override bool can_start(  ) {
			ByTable possible_syndicates = null;
			double agent_number = 0;
			double n_players = 0;
			dynamic new_syndicate = null;
			Mind synd_mind = null;

			
			if ( !base.can_start() ) {
				return false;
			}
			possible_syndicates = this.get_players_for_role( "operative" );
			agent_number = 0;

			if ( possible_syndicates.len < 1 ) {
				return false;
			}

			if ( possible_syndicates.len > GlobalVars.agents_possible ) {
				agent_number = GlobalVars.agents_possible;
			} else {
				agent_number = possible_syndicates.len;
			}
			n_players = this.num_players();

			if ( agent_number > n_players ) {
				agent_number = n_players / 2;
			}

			while (agent_number > 0) {
				new_syndicate = Rand13.PickFromTable( possible_syndicates );
				this.syndicates.Add( new_syndicate );
				possible_syndicates.Remove( new_syndicate );
				agent_number--;
			}

			foreach (dynamic _a in Lang13.Enumerate( this.syndicates, typeof(Mind) )) {
				synd_mind = _a;
				
				synd_mind.assigned_role = "MODE";
				synd_mind.special_role = "Syndicate";
			}
			return true;
		}

		// Function from file: nuclear.dm
		public override void announce(  ) {
			GlobalFuncs.to_chat( typeof(Game13), "<B>The current game mode is - Nuclear Emergency!</B>" );
			GlobalFuncs.to_chat( typeof(Game13), "<B>A " + GlobalFuncs.syndicate_name() + " Strike Force is approaching " + GlobalFuncs.station_name() + "!</B>" );
			GlobalFuncs.to_chat( typeof(Game13), "A nuclear explosive was being transported by Nanotrasen to a military base. The transport ship mysteriously lost contact with Space Traffic Control (STC). About that time a strange disk was discovered around " + GlobalFuncs.station_name() + ". It was identified by Nanotrasen as a nuclear auth. disk and now Syndicate Operatives have arrived to retake the disk and detonate SS13! Also, most likely Syndicate star ships are in the vicinity so take care not to lose the disk!\n<B>Syndicate</B>: Reclaim the disk and detonate the nuclear bomb anywhere on SS13.\n<B>Personnel</B>: Hold the disk and <B>escape with the disk</B> on the shuttle!" );
			return;
		}

	}

}