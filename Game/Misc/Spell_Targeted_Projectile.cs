// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Spell_Targeted_Projectile : Spell_Targeted {

		public dynamic proj_type = typeof(Obj_Item_Projectile_SpellProjectile);
		public int proj_step_delay = 1;
		public bool cast_prox_range = true;

		protected override void __FieldInit() {
			base.__FieldInit();

			this.name = "projectile spell";
		}

		// Function from file: projectile.dm
		public virtual ByTable prox_cast( ByTable targets = null, Obj_Item_Projectile_SpellProjectile spell_holder = null ) {
			return targets;
		}

		// Function from file: projectile.dm
		public ByTable choose_prox_targets( Ent_Dynamic user = null, Obj_Item_Projectile_SpellProjectile spell_holder = null ) {
			user = user ?? Task13.User;

			ByTable targets = null;
			Mob_Living M = null;

			targets = new ByTable();

			foreach (dynamic _a in Lang13.Enumerate( Map13.FetchInRange( this.cast_prox_range, spell_holder ), typeof(Mob_Living) )) {
				M = _a;
				

				if ( M == user && !( ( this.spell_flags & 64 ) != 0 ) ) {
					continue;
				}
				targets.Add( M );
			}
			return targets;
		}

		// Function from file: projectile.dm
		public override bool cast( ByTable targets = null, Mob user = null ) {
			user = user ?? Task13.User;

			Ent_Static target = null;
			dynamic projectile = null;
			dynamic SP = null;

			
			if ( this.proj_type is string ) {
				this.proj_type = Lang13.FindClass( this.proj_type );
			}

			foreach (dynamic _a in Lang13.Enumerate( targets, typeof(Ent_Static) )) {
				target = _a;
				
				projectile = Lang13.Call( this.proj_type, user.loc, user.dir );

				if ( !Lang13.Bool( projectile ) ) {
					return false;
				}
				projectile.original = target;
				projectile.starting = GlobalFuncs.get_turf( user );
				projectile.target = GlobalFuncs.get_turf( target );
				projectile.shot_from = user;
				projectile.current = projectile.original;
				projectile.yo = target.y - user.y;
				projectile.xo = target.x - user.x;
				projectile.kill_count = this.duration;
				projectile.step_delay = this.proj_step_delay;

				if ( projectile is Obj_Item_Projectile_SpellProjectile ) {
					SP = projectile;
					SP.carried = this;
				}
				Task13.Schedule( 0, (Task13.Closure)(() => {
					((Obj_Item_Projectile)projectile).OnFired();
					projectile.process();
					return;
				}));
			}
			return false;
		}

	}

}