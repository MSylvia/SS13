// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class MinesweeperGame : Game_Data {

		public ByTable tiles = new ByTable();
		public bool gameover = false;
		public dynamic columns = 8;
		public dynamic rows = 8;
		public dynamic initial_mines = 10;
		public dynamic current_difficulty = "beginner";
		public int mine_count = 0;
		public int timer = 0;
		public int end_timer = 0;
		public int holes = 0;
		public string face = "normal";

		// Function from file: minesweeper.dm
		public MinesweeperGame (  ) {
			int? y = null;
			int? x = null;
			MineTile T = null;

			this.end_timer = 0;
			this.timer = 0;
			this.mine_count = 0;
			this.holes = 0;
			this.tiles = new ByTable();
			y = null;
			y = 1;

			while (( y ??0) <= Convert.ToDouble( this.rows )) {
				x = null;
				x = 1;

				while (( x ??0) <= Convert.ToDouble( this.columns )) {
					T = new MineTile();
					this.tiles.Add( T );
					T.x = x;
					T.y = y;
					x++;
				}
				y++;
			}
			return;
		}

		// Function from file: minesweeper.dm
		public void reset_game(  ) {
			int? y = null;
			int? x = null;
			MineTile T = null;

			this.gameover = false;
			this.face = "normal";
			this.end_timer = 0;
			this.timer = 0;
			this.mine_count = 0;
			this.holes = 0;
			this.tiles = new ByTable();
			y = null;
			y = 1;

			while (( y ??0) <= Convert.ToDouble( this.rows )) {
				x = null;
				x = 1;

				while (( x ??0) <= Convert.ToDouble( this.columns )) {
					T = new MineTile();
					this.tiles.Add( T );
					T.x = x;
					T.y = y;
					x++;
				}
				y++;
			}
			return;
		}

		// Function from file: minesweeper.dm
		public void set_difficulty( dynamic choice = null ) {
			dynamic choiceX = null;
			dynamic choiceY = null;
			dynamic choiceM = null;

			
			dynamic _a = choice; // Was a switch-case, sorry for the mess.
			if ( _a=="beginner" ) {
				this.rows = 8;
				this.columns = 8;
				this.initial_mines = 10;
			} else if ( _a=="intermediate" ) {
				this.rows = 16;
				this.columns = 16;
				this.initial_mines = 40;
			} else if ( _a=="expert" ) {
				this.rows = 16;
				this.columns = 30;
				this.initial_mines = 99;
			} else if ( _a=="custom" ) {
				choiceX = Interface13.Input( "How many columns?", "Minesweeper Settings", null, null, null, InputType.Num );
				choiceY = Interface13.Input( "How many rows?", "Minesweeper Settings", null, null, null, InputType.Num );
				choiceM = Interface13.Input( "How many mines?", "Minesweeper Settings", null, null, null, InputType.Num );
				choiceX = Num13.MaxInt( 8, Num13.MinInt( 30, Convert.ToInt32( choiceX ) ) );
				choiceY = Num13.MaxInt( 8, Num13.MinInt( 24, Convert.ToInt32( choiceY ) ) );
				choiceM = Num13.MaxInt( 10, Num13.MinInt( Convert.ToInt32( ( choiceX - 1 ) * ( choiceY - 1 ) ), Convert.ToInt32( choiceM ) ) );
				this.columns = choiceX;
				this.rows = choiceY;
				this.initial_mines = choiceM;
			}
			this.current_difficulty = choice;
			this.reset_game();
			return;
		}

		// Function from file: minesweeper.dm
		public void dig_tile( dynamic T = null, bool? force = null ) {
			force = force ?? false;

			MineTile other_T = null;
			MineTile other_T2 = null;
			ByTable neighbors = null;
			MineTile near_T = null;
			MineTile near_T2 = null;

			
			if ( Lang13.Bool( T.dug ) ) {
				return;
			}

			if ( !Lang13.Bool( T.selected ) && !( force == true ) ) {
				
				foreach (dynamic _a in Lang13.Enumerate( this.tiles, typeof(MineTile) )) {
					other_T = _a;
					
					other_T.selected = false;
				}
				T.selected = 1;
				this.face = "fear";
				return;
			}

			if ( T.flagged == 1 ) {
				return;
			}
			T.selected = 0;
			this.face = "normal";
			T.dug = 1;

			if ( T.mined ) {
				this.face = "dead";
				this.end_timer = Num13.MinInt( 999, Num13.Floor( ( Game13.time - this.timer ) / 10 ) );
				this.gameover = true;
			} else {
				this.holes++;

				if ( this.mine_count + this.holes == this.tiles.len ) {
					
					foreach (dynamic _b in Lang13.Enumerate( this.tiles, typeof(MineTile) )) {
						other_T2 = _b;
						

						if ( other_T2.mined ) {
							other_T2.flagged = 1;
						}
					}
					this.face = "win";
					this.end_timer = Num13.MinInt( 999, Num13.Floor( ( Game13.time - this.timer ) / 10 ) );
					this.gameover = true;
				}
			}
			neighbors = new ByTable();

			foreach (dynamic _c in Lang13.Enumerate( this.tiles, typeof(MineTile) )) {
				near_T = _c;
				

				if ( ( ( near_T.x ??0) - Convert.ToDouble( T.x ) ) * ( ( near_T.x ??0) - Convert.ToDouble( T.x ) ) + ( ( near_T.y ??0) - Convert.ToDouble( T.y ) ) * ( ( near_T.y ??0) - Convert.ToDouble( T.y ) ) <= 2 ) {
					
					if ( near_T.mined ) {
						T.num++;
					} else {
						neighbors.Add( near_T );
					}
				}
			}

			if ( !Lang13.Bool( T.num ) ) {
				
				foreach (dynamic _d in Lang13.Enumerate( neighbors, typeof(MineTile) )) {
					near_T2 = _d;
					
					Task13.Schedule( 0, (Task13.Closure)(() => {
						this.dig_tile( near_T2, true );
						return;
					}));
				}
			}
			return;
		}

		// Function from file: minesweeper.dm
		public void game_start( dynamic first_T = null ) {
			dynamic T = null;

			first_T.selected = 1;
			this.timer = Game13.time;

			while (this.mine_count < Convert.ToDouble( this.initial_mines )) {
				T = Rand13.PickFromTable( this.tiles );

				if ( !T.mined && !Lang13.Bool( T.selected ) ) {
					T.mined = true;
					this.mine_count++;
				}
			}
			this.dig_tile( first_T );
			return;
		}

	}

}