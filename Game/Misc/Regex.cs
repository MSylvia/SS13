// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Regex : Game_Data {

		public Regex next = null;
		public bool? nextup = null;
		public Regex child = null;
		public Regex option = null;
		public Regex replace = null;
		public double? lastgroup = 0;
		public ByTable groups = null;
		public ByTable namedvars = null;
		public string error = null;
		public dynamic replacing = null;
		public int? patternchar = null;
		public int flags = 0;
		public dynamic pattern = null;
		public dynamic start = null;
		public dynamic end = null;
		public int ptype = 0;
		public dynamic n = 1;
		public dynamic m = 1;
		public bool greedy = true;
		public dynamic premodend = 0;
		public dynamic match = null;
		public dynamic index = null;

		// Function from file: Regex.dm
		public Regex ( dynamic p = null, dynamic s = null, Regex first = null, Regex last = null ) {
			s = s ?? 1;

			int? endchar = null;
			dynamic i = null;
			int? ch = null;
			dynamic ch2 = null;
			int modify = 0;
			dynamic bogusflag = null;

			endchar = 0;
			this.start = s;

			if ( !( first != null ) ) {
				this.pattern = p;
				this.end = Lang13.Length( this.pattern ) + 1;
				first = this;
			} else {
				this.pattern = first.pattern;

				if ( p is Regex ) {
					first.lastgroup++;
					endchar = ( String13.GetCharCode( this.pattern, Lang13.IntNullable( p.start ) ) == 91 ? 93 : 41 );
					this.end = p.end;
				} else if ( !( last != null ) ) {
					this.end = first.replacing;
				}

				if ( last != null ) {
					this.end = last.end;
					last.end = this.start;
				}
			}
			modify = 0;

			if ( this.start == 1 ) {
				this.patternchar = String13.GetCharCode( this.pattern, null );

				if ( this.patternchar == 92 ) {
					return; // Warning! Attempt to return some other value!
				}
				this.start++;

				while (Convert.ToDouble( this.end ) >= Convert.ToDouble( this.start )) {
					ch = String13.GetCharCode( this.pattern, Lang13.IntNullable( --this.end ) );

					if ( ch == this.patternchar ) {
						
						if ( Lang13.Bool( bogusflag ) ) {
							this.MarkError( first, bogusflag, "Illegal pattern flag: ", ch ); return;
						}
						break;
					}

					switch ((int?)( ch )) {
						case 73:
						case 105:
							first.flags |= 1;
							break;
						case 83:
						case 115:
							first.flags |= 2;
							break;
						case 71:
						case 103:
							first.flags |= 4;
							break;
						case 69:
						case 101:
							first.flags |= 8;
							break;
						default:
							bogusflag = this.end + 1;
							break;
					}
				}

				if ( Convert.ToDouble( this.end ) < Convert.ToDouble( this.start ) ) {
					this.start--;
					this.patternchar = 0;
					this.end = Lang13.Length( this.pattern ) + 1;
				}
			}
			this.index = this.start;

			while (Convert.ToDouble( this.index ) < Convert.ToDouble( this.end ) && !Lang13.Bool( first.error )) {
				ch = String13.GetCharCode( this.pattern, Lang13.IntNullable( this.index++ ) );

				if ( ch == first.patternchar ) {
					
					if ( !Lang13.Bool( first.replacing ) ) {
						first.replacing = this.end;
						first.replace = new Regex( this.pattern, this.index, first );
					} else if ( ( first.flags & 8 ) != 0 && endchar == 41 ) {
						continue;
					}
					this.end = --this.index;
					break;
				}

				if ( ch == endchar ) {
					
					if ( Convert.ToDouble( this.index ) <= Convert.ToDouble( this.start + 1 ) ) {
						
						if ( !( last != null ) ) {
							this.MarkError( first, this.index, "Unexpected char:", ch ); return;
						}

						if ( last.start == this.start - 1 && String13.GetCharCode( this.pattern, Lang13.IntNullable( last.start ) ) == 124 ) {
							this.MarkError( first, this.index, "Unexpected char:", ch ); return;
						}
					}
					p.index = this.index;
					this.end = this.index - 1;
					return;
				}

				switch ((int?)( ch )) {
					case 92:
						
						if ( modify != 0 || Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 1 ) ) {
							this.BreakOff( p, first ); return;
						}
						ch2 = this.Advance();

						if ( !Lang13.Bool( ch2 ) ) {
							this.MarkError( first, this.index, "Unexpected char:", ch ); return;
						}

						if ( ch2 == 48 ) {
							this.NumAdvance();
						} else if ( Convert.ToDouble( ch2 ) >= 49 && Convert.ToDouble( ch2 ) <= 57 ) {
							
							if ( Lang13.Bool( first.replacing ) ) {
								this.MarkError( first, this.index, "Unexpected char:", ch ); return;
							}
							this.NumAdvance();
							i = String13.ParseNumber( String13.SubStr( this.pattern, Convert.ToInt32( this.start + 1 ), Convert.ToInt32( this.index ) ) );

							if ( Convert.ToDouble( i ) <= 0 || Convert.ToDouble( i ) > ( first.lastgroup ??0) ) {
								this.MarkError( first, this.index, "Illegal backref: \\" + i ); return;
							}
						} else if ( ch2 == 120 || ch2 == 88 ) {
							
							if ( !this.NumAdvance( 16 ) ) {
								this.MarkError( first, this.index, "Unexpected char:", ch2 ); return;
							}
						} else {
							
							if ( Lang13.Bool( first.replacing ) ) {
								continue;
							}

							if ( ch2 == 97 || ch2 == 65 ) {
								
								if ( modify != 0 || Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 2 ) ) {
									this.MarkError( first, this.index, "Unexpected char:", ch2 );
								}
								throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
							}

							if ( ch2 == 122 || ch2 == 90 ) {
								
								if ( Convert.ToDouble( this.index ) < Convert.ToDouble( this.end ) ) {
									this.MarkError( first, this.index, "Unexpected char:", ch2 );
								}
								throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
							}

							if ( ch2 == 98 || ch2 == 66 ) {
								throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
							}
						}
						modify = 1;
						break;
					case 94:
						
						if ( Lang13.Bool( first.replacing ) ) {
							continue;
						}

						if ( modify != 0 || Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 1 ) ) {
							this.MarkError( first, this.index, "Unexpected char:", ch ); return;
						}
						throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						break;
					case 36:
						
						if ( Lang13.Bool( first.replacing ) && Convert.ToDouble( this.index ) >= Convert.ToDouble( this.end ) ) {
							continue;
						}

						if ( modify != 0 || Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 1 ) ) {
							this.BreakOff( p, first ); return;
						}

						if ( Convert.ToDouble( this.index ) >= Convert.ToDouble( this.end ) ) {
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}
						ch2 = this.Advance();

						if ( Convert.ToDouble( ch2 ) >= 48 && Convert.ToDouble( ch2 ) <= 57 ) {
							
							if ( !Lang13.Bool( first.replacing ) ) {
								this.MarkError( first, this.index, "Unexpected char:", ch ); return;
							}
							this.NumAdvance();
						} else if ( Convert.ToDouble( ch2 ) >= 65 && Convert.ToDouble( ch2 ) <= 90 || Convert.ToDouble( ch2 ) >= 97 && Convert.ToDouble( ch2 ) <= 122 || ch2 == 95 ) {
							
							do {
								ch2 = this.Advance();
							} while ( Convert.ToDouble( ch2 ) >= 48 && ( Convert.ToDouble( ch2 ) <= 57 || Convert.ToDouble( ch2 ) >= 65 && Convert.ToDouble( ch2 ) <= 90 || ch2 == 95 || Convert.ToDouble( ch2 ) >= 97 ) && Convert.ToDouble( ch2 ) <= 122 );

							if ( Convert.ToDouble( this.index ) < Convert.ToDouble( this.end ) ) {
								this.index--;
							}
						} else {
							this.MarkError( first, this.index - 1, "Unexpected char:", 36 ); return;
						}
						throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						break;
					case 46:
						
						if ( Lang13.Bool( first.replacing ) ) {
							continue;
						}

						if ( Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 1 ) ) {
							this.BreakOff( p, first ); return;
						}
						modify = 1;
						break;
					case 42:
					case 43:
					case 63:
						
						if ( Lang13.Bool( first.replacing ) ) {
							continue;
						}

						if ( !( modify != 0 ) && Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 2 ) ) {
							this.index--;
							this.BreakOff( p, first ); return;
						}

						if ( modify > 1 && ch != 63 || Convert.ToDouble( this.index ) <= Convert.ToDouble( this.start + 1 ) ) {
							this.MarkError( first, this.index, "Unexpected char:", ch ); return;
						}

						if ( !Lang13.Bool( this.premodend ) ) {
							this.premodend = this.index - 1;
						}

						if ( ch == 63 ) {
							
							if ( modify > 1 ) {
								this.greedy = false;
								throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
							}
							this.n = 0;
							this.m = 1;
						} else {
							this.n = ( ch ??0) - 42;
							this.m = -1;
						}
						modify = 2;
						break;
					case 123:
						
						if ( Lang13.Bool( first.replacing ) ) {
							continue;
						}

						if ( !( modify != 0 ) && Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 2 ) ) {
							this.index--;
							this.BreakOff( p, first ); return;
						}

						if ( modify > 1 ) {
							this.BreakOff( p, first ); return;
						}

						if ( Convert.ToDouble( this.index ) <= Convert.ToDouble( this.start + 1 ) ) {
							this.MarkError( first, this.index, "Unexpected char:", ch ); return;
						}
						this.premodend = this.index - 1;
						i = this.index;
						this.NumAdvance();

						if ( Convert.ToDouble( this.index ) > Convert.ToDouble( i ) ) {
							this.n = String13.ParseNumber( String13.SubStr( this.pattern, Convert.ToInt32( i ), Convert.ToInt32( this.index ) ) );
							ch2 = this.Advance();
						} else {
							ch2 = this.Advance();

							if ( !Lang13.Bool( ch2 ) ) {
								this.MarkError( first, this.index, "Unexpected char:", ch ); return;
							}

							if ( ch2 != 44 ) {
								this.MarkError( first, this.index, "Expected number or ," ); return;
							}
							this.n = 0;
						}
						this.m = this.n;

						if ( ch2 == 44 ) {
							i = this.index;
							this.NumAdvance();

							if ( Convert.ToDouble( this.index ) > Convert.ToDouble( i ) ) {
								this.m = String13.ParseNumber( String13.SubStr( this.pattern, Convert.ToInt32( i ), Convert.ToInt32( this.index ) ) );

								if ( Convert.ToDouble( this.m ) < Convert.ToDouble( this.n ) ) {
									i = this.n;
									this.n = this.m;
									this.m = i;
								}
							} else {
								this.m = -1;
							}
							ch2 = this.Advance();
						}

						if ( ch2 != 125 ) {
							this.MarkError( first, this.index, "Unexpected char:", ch2 ); return;
						}
						modify = 2;
						break;
					case 40:
						
						if ( Lang13.Bool( first.replacing ) ) {
							
							if ( !( ( first.flags & 8 ) != 0 ) || endchar != 93 ) {
								continue;
							}

							if ( Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 1 ) ) {
								this.BreakOff( p, first ); return;
							}
							this.child = new Regex( this, this.index, first );
							ch2 = this.LookAhead();

							if ( this.LookAhead() != endchar ) {
								this.MarkError( first, ( Lang13.Bool( ch2 ) ? this.index + 1 : this.index ), "Expected", endchar ); return;
							}
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}

						if ( modify != 0 || Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 1 ) ) {
							this.BreakOff( p, first ); return;
						}
						this.child = new Regex( this, this.index, first );
						modify = 1;
						break;
					case 91:
						
						if ( Lang13.Bool( first.replacing ) ) {
							
							if ( !( ( first.flags & 8 ) != 0 ) ) {
								continue;
							}

							if ( Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 1 ) ) {
								this.BreakOff( p, first ); return;
							}
							ch2 = this.LookAhead();

							if ( !Lang13.Bool( ch2 ) ) {
								this.MarkError( first, this.index, "Unexpected char:", ch ); return;
							}

							if ( Convert.ToDouble( ch2 ) < 65 || Convert.ToDouble( ch2 ) > 90 && Convert.ToDouble( ch2 ) < 97 && ch2 != 95 || Convert.ToDouble( ch2 ) > 122 ) {
								this.MarkError( first, this.index + 1, "Unexpected char in proc name:", ch2 ); return;
							}
							i = this.index + 2;

							while (Convert.ToDouble( i ) < Convert.ToDouble( this.end )) {
								ch2 = String13.GetCharCode( this.pattern, Lang13.IntNullable( i ) );

								if ( ch2 == 40 || ch2 == 93 ) {
									break;
								}
								i++;

								if ( Convert.ToDouble( ch2 ) < 48 || Convert.ToDouble( ch2 ) > 57 && Convert.ToDouble( ch2 ) < 65 || Convert.ToDouble( ch2 ) > 90 && Convert.ToDouble( ch2 ) < 97 && ch2 != 95 || Convert.ToDouble( ch2 ) > 122 ) {
									this.MarkError( first, i, "Unexpected char in proc name:", ch2 ); return;
								}
							}
							ch2 = "/proc/" + String13.SubStr( this.pattern, Convert.ToInt32( this.index ), Convert.ToInt32( i ) );

							if ( !( Lang13.FindClass( ch2 ) != null ) ) {
								this.MarkError( first, i, "" + ch2 + " does not exist" ); return;
							}
							this.child = new Regex( this, this.index, first );
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}

						if ( modify != 0 || Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 1 ) ) {
							this.BreakOff( p, first ); return;
						}

						if ( this.ParseCharClass( first ) != null ) {
							return;
						}
						modify = 1;
						break;
					case 124:
						
						if ( Lang13.Bool( first.replacing ) ) {
							continue;
						}

						if ( modify != 0 || Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 1 ) ) {
							this.BreakOff( p, first ); return;
						}

						if ( !( last != null ) ) {
							this.MarkError( first, this.index, "Unexpected char:", ch ); return;
						}
						throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						break;
					case 44:
						
						if ( Lang13.Bool( first.replacing ) ) {
							
							if ( ( first.flags & 8 ) != 0 ) {
								
								if ( endchar == 93 ) {
									this.MarkError( first, this.index, "Unexpected char:", ch ); return;
								}

								if ( endchar == 41 ) {
									
									if ( Convert.ToDouble( this.index ) > Convert.ToDouble( this.start + 1 ) ) {
										this.BreakOff( p, first ); return;
									}
									throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
								}
							}
							continue;
						}

						if ( modify != 0 ) {
							this.BreakOff( p, first ); return;
						}
						break;
					case 41:
					case 93:
						
						if ( Lang13.Bool( first.replacing ) ) {
							continue;
						}
						this.MarkError( first, this.index, "Unexpected char:", ch ); return;
						break;
					default:
						
						if ( modify != 0 ) {
							this.BreakOff( p, first ); return;
						}
						break;
				}
			}

			if ( Lang13.Bool( first.error ) ) {
				return;
			}

			if ( Convert.ToDouble( this.index ) < Convert.ToDouble( this.end ) ) {
				this.index++;
				this.BreakOff( p, first );
			} else if ( Lang13.Bool( endchar ) ) {
				return; // Warning! Attempt to return some other value!
			}

			if ( first == this ) {
				this.CompileBlocks();
			}
			return;
		}

		// Function from file: Regex.dm
		public ByTable Split( string txt = null, dynamic inclusive = null ) {
			ByTable _default = null;

			dynamic lastindex = null;

			_default = new ByTable();
			lastindex = 1;

			if ( Lang13.Bool( this.Find( txt ) ) ) {
				
				do {
					_default.Add( String13.SubStr( txt, Convert.ToInt32( lastindex ), Convert.ToInt32( this.match ) ) );

					if ( Lang13.Bool( inclusive ) ) {
						_default.Add( String13.SubStr( txt, Convert.ToInt32( this.match ), Convert.ToInt32( this.index ) ) );
					}
					lastindex = this.index;

					if ( this.match == this.index ) {
						this.index++;
					}
				} while ( Lang13.Bool( this.FindNext( txt ) ) );
			}
			_default.Add( String13.SubStr( txt, Convert.ToInt32( lastindex ), 0 ) );
			return _default;
		}

		// Function from file: Regex.dm
		public string ReplaceNext( string txt = null ) {
			string _default = null;

			string rtxt = null;

			
			if ( !Lang13.Bool( this.match ) ) {
				this.index = 1;
			}

			if ( Lang13.Bool( this.Find( txt, this.index ) ) ) {
				rtxt = this.ReplacementText( txt );
				txt = String13.SubStr( txt, 1, Convert.ToInt32( this.match ) ) + rtxt + String13.SubStr( txt, Convert.ToInt32( this.index ), 0 );
				this.index = this.match + Lang13.Length( rtxt );
				_default = txt;
			}
			return _default;
		}

		// Function from file: Regex.dm
		public dynamic FindNext( string txt = null ) {
			
			if ( !Lang13.Bool( this.match ) ) {
				this.index = 1;
			}
			return this.Find( txt, this.index );
		}

		// Function from file: Regex.dm
		public dynamic FoundTo(  ) {
			Regex p = null;

			
			while (!Lang13.Bool( this.start ) && this.option != null) {
				Task13.Source = this.option;
			}

			if ( !Lang13.Bool( this.start ) ) {
				return 0;
			}
			p = this;

			while (p != null) {
				this.end = p.end;
				p = p.next;
			}
			return this.end;
		}

		// Function from file: Regex.dm
		public dynamic NonSpan( string txt = null, dynamic s = null, dynamic e = null ) {
			dynamic _default = null;

			int ch = 0;

			_default = s;

			while (Convert.ToDouble( _default ) < Convert.ToDouble( e )) {
				ch = String13.GetCharCode( txt, Lang13.IntNullable( _default ) ) + 15;

				if ( Lang13.Bool( this.pattern[ch >> 4] & 1 << ( ch & 15 ) ) ) {
					return _default;
				}
				_default++;
			}
			return _default;
		}

		// Function from file: Regex.dm
		public dynamic Span( string txt = null, dynamic s = null, dynamic e = null ) {
			dynamic _default = null;

			int ch = 0;

			_default = s;

			while (Convert.ToDouble( _default ) < Convert.ToDouble( e )) {
				ch = String13.GetCharCode( txt, Lang13.IntNullable( _default ) ) + 15;

				if ( !Lang13.Bool( this.pattern[ch >> 4] & 1 << ( ch & 15 ) ) ) {
					return _default;
				}
				_default++;
			}
			return _default;
		}

		// Function from file: Regex.dm
		public string ReplacementText( string txt = null, Regex first = null ) {
			string _default = null;

			dynamic p = null;
			dynamic procname = null;
			ByTable procargs = null;
			Regex q = null;

			_default = "";

			if ( !( first != null ) ) {
				first = this;
			}
			p = this.replace != null || this != null;

			while (Lang13.Bool( p )) {
				
				dynamic _a = p.ptype; // Was a switch-case, sorry for the mess.
				if ( _a==1 ) {
					_default += p.pattern;
				} else if ( _a==5 ) {
					
					if ( !Lang13.Bool( p.child ) ) {
						p = p.next;
						continue;
					}
					procname = p.child.pattern;

					if ( Lang13.Bool( p.child.next ) && Lang13.Bool( p.child.next.child ) ) {
						procargs = new ByTable();
						q = null;
						q = p.child.next.child;

						while (q != null) {
							procargs.Add( q.ReplacementText( txt, first ) );
							q = q.option;
						}
						_default += "" + procargs.Apply( typeof(GlobalFuncs).GetMethod( Lang13.FindClass( "/proc/" + procname ) ) );
					} else {
						_default += "" + Lang13.Call( Lang13.FindClass( "/proc/" + procname ) );
					}
				} else if ( _a==12 ) {
					_default += first.GroupText( p.pattern );
				} else if ( _a==14 ) {
					
					if ( !Lang13.Bool( first.namedvars[p.pattern] ) ) {
						p = p.next;
						continue;
					}
					_default += first.namedvars[p.pattern];
				} else {
					Game13.log.WriteMsg( "Replacement block type " + p.ptype + " not handled yet" );
				}
				p = p.next;
			}
			return _default;
		}

		// Function from file: Regex.dm
		public dynamic GroupText( dynamic g = null ) {
			
			if ( Convert.ToDouble( g ) < 1 || Convert.ToDouble( g ) > this.groups.len ) {
				return null;
			}
			return this.groups[this.groups[g]];
		}

		// Function from file: Regex.dm
		public string Replace( string txt = null, bool? start = null ) {
			start = start ?? true;

			string _default = null;

			int times = 0;
			string rtxt = null;

			this.index = start;
			times = ( ( this.flags & 4 ) != 0 ? Lang13.Length( txt ) : 1 );

			while (times > 0 && Convert.ToDouble( this.index ) <= Lang13.Length( txt ) + 1) {
				
				if ( !Lang13.Bool( this.Find( txt, this.index ) ) ) {
					return _default;
				}

				if ( this.index == this.match ) {
					this.index++;
					times++;
				} else {
					rtxt = this.ReplacementText( txt );
					txt = String13.SubStr( txt, 1, Convert.ToInt32( this.match ) ) + rtxt + String13.SubStr( txt, Convert.ToInt32( this.index ), 0 );
					this.index = this.match + Lang13.Length( rtxt );
					_default = txt;
				}
				times--;
			}
			return _default;
		}

		// Function from file: Regex.dm
		public dynamic FirstPossible( string txt = null, dynamic start = null, Regex first = null, dynamic stop = null, bool? anyline = null ) {
			start = start ?? 1;

			dynamic _default = null;

			dynamic i = null;
			dynamic j = null;
			double? k = null;
			int ch = 0;
			int ch2 = 0;
			double? ee = null;
			double? e = null;
			dynamic after = null;
			Regex p = null;
			dynamic str = null;

			ee = Lang13.Length( txt ) + 1;
			e = ( Convert.ToDouble( start ) >= ( ee ??0) || ( first.flags & 2 ) != 0 ? ee : String13.Find( txt, "\n", Convert.ToInt32( start ), 0 ) != 0 || Lang13.Bool( ee ) ?1:0 );

			if ( !Lang13.Bool( stop ) ) {
				stop = ee;
			}
			_default = 0;
			p = null;
			p = this;

			while (p != null) {
				i = start;
				Task13.Sleep( 0 );

				switch ((int)( p.ptype )) {
					case 1:
					case 13:
					case 14:
						str = p.pattern;

						if ( p.ptype > 1 ) {
							
							switch ((int)( p.ptype )) {
								case 13:
									
									if ( Convert.ToDouble( p.pattern ) < 1 || Convert.ToDouble( p.pattern ) > first.groups.len ) {
										i = 0;
										throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
									}
									str = first.groups[first.groups[p.pattern]];

									if ( str == null ) {
										throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
									}
									break;
								case 14:
									
									if ( !first.namedvars.Contains( p.pattern ) ) {
										i = 0;
										throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
									}
									str = Lang13.Bool( first.namedvars[p.pattern] ) || Lang13.Bool( "" );
									break;
							}
						}

						if ( anyline == true ) {
							e = ee;
						}
						i = ( ( first.flags & 1 ) != 0 ? String13.FindIgnoreCase( txt, str, Convert.ToInt32( i ), 0 ) : String13.Find( txt, str, Convert.ToInt32( i ), 0 ) );

						if ( !Lang13.Bool( i ) || Convert.ToDouble( i ) > Convert.ToDouble( stop ) || Convert.ToDouble( i ) > ( e ??0) ) {
							i = 0;
						}
						break;
					case 2:
						
						while (Convert.ToDouble( i + p.n ) <= ( ee ??0)) {
							
							while (Convert.ToDouble( i + p.n ) <= ( e ??0)) {
								i = p.NonSpan( txt, i, ( e ??0) - Convert.ToDouble( p.n ) + 1 );

								if ( Convert.ToDouble( i ) > Convert.ToDouble( stop ) ) {
									i = 0;
									throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
								}

								if ( Convert.ToDouble( i + p.n ) > ( e ??0) ) {
									continue;
								}
								j = p.Span( txt, i + 1, i + p.n );

								if ( Convert.ToDouble( j ) >= Convert.ToDouble( i + p.n ) ) {
									throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
								}
								i = j + 1;
							}

							if ( anyline == true ) {
								i = ++e;
								e = String13.Find( txt, "\n", ((int)( e ??0 )), 0 ) != 0 || Lang13.Bool( ee ) ?1:0;
							}
						}
						i = 0;
						break;
					case 3:
						
						while (Convert.ToDouble( i + p.n ) <= ( ee ??0)) {
							
							while (Convert.ToDouble( i + p.n ) <= ( e ??0)) {
								i = p.Span( txt, i, ( e ??0) - Convert.ToDouble( p.n ) + 1 );

								if ( Convert.ToDouble( i ) > Convert.ToDouble( stop ) ) {
									i = 0;
									throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
								}

								if ( Convert.ToDouble( i + p.n ) > ( e ??0) ) {
									continue;
								}
								j = p.NonSpan( txt, i + 1, i + p.n );

								if ( Convert.ToDouble( j ) >= Convert.ToDouble( i + p.n ) ) {
									throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
								}
								i = j + 1;
							}

							if ( anyline == true ) {
								i = ++e;
								e = String13.Find( txt, "\n", ((int)( e ??0 )), 0 ) != 0 || Lang13.Bool( ee ) ?1:0;
							}
						}
						i = 0;
						break;
					case 4:
						i = ( p.child != null ? p.child.FirstPossible( txt, start, first, stop, anyline ) : ((dynamic)( 0 )) );
						break;
					case 8:
						after = p.next != null || p.nextup == true;

						while (Lang13.Bool( i ) && Convert.ToDouble( i + p.n ) <= ( ee ??0)) {
							
							if ( anyline == true ) {
								
								while (Convert.ToDouble( i + p.n ) > ( e ??0) && ( e ??0) < ( ee ??0)) {
									i = ++e;
									e = String13.Find( txt, "\n", ((int)( e ??0 )), 0 ) != 0 || Lang13.Bool( ee ) ?1:0;
								}
							}

							if ( Convert.ToDouble( i + p.n ) > ( e ??0) ) {
								i = 0;
								break;
							}

							if ( !Lang13.Bool( after ) ) {
								break;
							}
							k = ( Convert.ToDouble( p.m ) < 0 ? e : Num13.MinInt( ((int)( e ??0 )), Convert.ToInt32( i + p.m ) ) );
							j = after.Find( txt, i + p.n, first, k );

							if ( !Lang13.Bool( j ) ) {
								i = ++e;
								e = String13.Find( txt, "\n", ((int)( e ??0 )), 0 ) != 0 || Lang13.Bool( ee ) ?1:0;
							} else {
								
								if ( Convert.ToDouble( p.m ) > 0 ) {
									i = Num13.MaxInt( Convert.ToInt32( i ), Convert.ToInt32( j - p.m ) );
								}
								break;
							}
						}

						if ( Convert.ToDouble( i + p.n ) > ( ee ??0) ) {
							i = 0;
						}
						break;
					case 10:
					case 11:
						
						if ( anyline == true ) {
							e = ee;
						}
						ch = ( Convert.ToDouble( i ) > 1 ? String13.GetCharCode( txt, Lang13.IntNullable( i - 1 ) ) : 0 );
						ch = ( ch < 48 || ch > 122 || ch > 57 && ch < 65 || ch > 90 && ch < 95 || ch == 96 ? false : true ) ?1:0;
						j = p.ptype & 1;

						while (Convert.ToDouble( i ) <= ( e ??0)) {
							ch2 = ( Convert.ToDouble( i ) < ( e ??0) ? String13.GetCharCode( txt, Lang13.IntNullable( i ) ) : 0 );
							ch2 = ( ch2 < 48 || ch2 > 122 || ch2 > 57 && ch2 < 65 || ch2 > 90 && ch2 < 95 || ch2 == 96 ? false : true ) ?1:0;

							if ( ( ch ^ ch2 ^ Convert.ToInt32( j ) ) != 0 ) {
								throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
							}
							i++;
							ch = ch2;
						}
						i = 0;
						break;
					case 16:
					case 18:
						
						if ( Convert.ToDouble( i ) > 1 ) {
							
							if ( ( p.ptype & first.flags & 2 ) != 0 ) {
								i = 0;
							} else {
								i = String13.Find( txt, "\n", Convert.ToInt32( i - 1 ), 0 );

								if ( Lang13.Bool( i ) ) {
									i++;
								}
							}
						}
						break;
					case 17:
					case 19:
						
						if ( Convert.ToDouble( i ) < ( ee ??0) ) {
							
							if ( ( p.ptype & first.flags & 2 ) != 0 ) {
								i = ee;
							} else {
								i = String13.Find( txt, "\n", Convert.ToInt32( i ), 0 ) != 0 || Lang13.Bool( ee );
							}
						}
						break;
					case 0:
						
						if ( Lang13.Bool( first.error ) ) {
							Game13.log.WriteMsg( "Regex " + first.pattern + " did not compile:\n" + first.error );
						}
						break;
					default:
						Game13.log.WriteMsg( "Block type " + p.ptype + " not handled yet" );
						break;
				}

				if ( Lang13.Bool( i ) ) {
					_default = ( Lang13.Bool( _default ) ? ((dynamic)( Num13.MinInt( Convert.ToInt32( i ), Convert.ToInt32( _default ) ) )) : i );
				}
				p = p.option;
			}
			return _default;
		}

		// Function from file: Regex.dm
		public dynamic FindHere( string txt = null, dynamic start = null, Regex first = null, bool? nonzero = null ) {
			start = start ?? 1;

			dynamic _default = null;

			dynamic i = null;
			dynamic j = null;
			dynamic k = null;
			int ch = 0;
			int ch2 = 0;
			dynamic times = null;
			dynamic maxtimes = null;
			Regex o = null;
			double? ee = null;
			double? e = null;
			dynamic after = null;
			dynamic str = null;
			int? l = null;

			
			if ( !( first != null ) ) {
				first = this;
			}
			i = start;
			o = this.option;
			ee = Lang13.Length( txt ) + 1;
			e = ( Convert.ToDouble( start ) >= ( ee ??0) || ( first.flags & 2 ) != 0 ? ee : String13.Find( txt, "\n", Convert.ToInt32( start ), 0 ) != 0 || Lang13.Bool( ee ) ?1:0 );

			while (this != null) {
				Task13.Sleep( 0 );
				times = 0;
				after = this.next != null || this.nextup == true;
				this.start = i;
				this.end = e;

				switch ((int)( this.ptype )) {
					case 1:
					case 13:
					case 14:
						str = this.pattern;

						if ( this.ptype > 1 ) {
							
							switch ((int)( this.ptype )) {
								case 13:
									
									if ( Convert.ToDouble( this.pattern ) < 1 || Convert.ToDouble( this.pattern ) > first.groups.len ) {
										throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
									}
									str = first.groups[first.groups[this.pattern]];

									if ( str == null ) {
										throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
									}
									break;
								case 14:
									
									if ( !first.namedvars.Contains( this.pattern ) ) {
										throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
									}
									str = Lang13.Bool( first.namedvars[this.pattern] ) || Lang13.Bool( "" );
									break;
							}
						}
						k = i;
						l = Lang13.Length( str );

						do {
							
							if ( Convert.ToDouble( i + l ) > ( ee ??0) ) {
								break;
							}

							if ( ( first.flags & 1 ) != 0 ) {
								j = 1;
								string _loop_ctrl_1 = null;

								while (Convert.ToDouble( j ) <= ( l ??0)) {
									ch = String13.GetCharCode( txt, Lang13.IntNullable( k++ ) );
									ch2 = String13.GetCharCode( str, Lang13.IntNullable( j ) );

									if ( ch == ch2 ) {
										
									} else {
										ch |= 32;

										if ( ch != ( ch2 | 32 ) ) {
											_loop_ctrl_1 = "break";
											break;
										}

										if ( ch < 97 || ch > 122 && ( ch < 224 || ch == 243 ) ) {
											_loop_ctrl_1 = "break";
											break;
										}
									}
									j++;
								}

								if ( _loop_ctrl_1 == "break" ) {
									break;
								} else if ( _loop_ctrl_1 == "continue" ) {
									continue;
								}
							} else {
								j = 1;
								string _loop_ctrl_2 = null;

								while (Convert.ToDouble( j ) <= ( l ??0)) {
									
									if ( String13.GetCharCode( txt, Lang13.IntNullable( k++ ) ) != String13.GetCharCode( str, Lang13.IntNullable( j ) ) ) {
										_loop_ctrl_2 = "break";
										break;
									}
									j++;
								}

								if ( _loop_ctrl_2 == "break" ) {
									break;
								} else if ( _loop_ctrl_2 == "continue" ) {
									continue;
								}
							}
							i = k;

							if ( Convert.ToDouble( ++times ) >= Convert.ToDouble( this.n ) && !this.greedy && !Lang13.Bool( after ) ) {
								break;
							}
						} while ( Convert.ToDouble( times ) < Convert.ToDouble( this.m ) || Convert.ToDouble( this.m ) < 0 );

						if ( this.greedy || !Lang13.Bool( after ) || Convert.ToDouble( times ) <= Convert.ToDouble( this.n ) ) {
							
							if ( !this.greedy && !Lang13.Bool( after ) && Convert.ToDouble( times ) > Convert.ToDouble( this.n ) ) {
								times = this.n;
								i = this.start + this.n * l;
							}

							if ( Convert.ToDouble( times ) >= Convert.ToDouble( this.n ) && !( ( first.flags & 2 ) != 0 ) ) {
								e = String13.Find( txt, "\n", Convert.ToInt32( i ), 0 ) != 0 || Lang13.Bool( ee ) ?1:0;
							}
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}
						maxtimes = times;
						times = this.n;
						i = this.start + this.n * l;

						while (Convert.ToDouble( times ) < Convert.ToDouble( maxtimes )) {
							
							if ( Lang13.Bool( ((Regex)after).FindHere( txt, i, first ) ) ) {
								this.end = i;
								return this.start;
							}
							times++;
							i += l;
						}
						break;
					case 2:
						
						if ( Convert.ToDouble( i + this.n ) > ( e ??0) ) {
							times = -1;
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}
						times = this.Span( txt, i, i + this.n ) - i;

						if ( Convert.ToDouble( times ) < Convert.ToDouble( this.n ) ) {
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}

						if ( this.n == this.m ) {
							i += this.n;
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}
						maxtimes = ( Convert.ToDouble( this.m ) < 0 ? ( e ??0) - Convert.ToDouble( i ) : Num13.MinInt( Convert.ToInt32( this.m ), ((int)( ( e ??0) - Convert.ToDouble( i ) )) ) );
						times = this.Span( txt, i + this.n, i + maxtimes ) - i;
						maxtimes = times;
						throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						break;
					case 3:
						
						if ( Convert.ToDouble( i + this.n ) > ( e ??0) ) {
							times = -1;
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}
						times = this.NonSpan( txt, i, i + this.n ) - i;

						if ( Convert.ToDouble( times ) < Convert.ToDouble( this.n ) ) {
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}

						if ( this.n == this.m ) {
							i += this.n;
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}
						maxtimes = ( Convert.ToDouble( this.m ) < 0 ? ( e ??0) - Convert.ToDouble( i ) : Num13.MinInt( Convert.ToInt32( this.m ), ((int)( ( e ??0) - Convert.ToDouble( i ) )) ) );
						times = this.NonSpan( txt, i + this.n, i + maxtimes ) - i;
						maxtimes = times;
						throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						break;
					case 4:
						
						if ( this.child != null ) {
							
							do {
								
								if ( !Lang13.Bool( this.child.FindHere( txt, i, first ) ) ) {
									break;
								}
								i = this.child.FoundTo();
							} while ( Convert.ToDouble( ++times ) < Convert.ToDouble( this.n ) );

							if ( Convert.ToDouble( times ) >= Convert.ToDouble( this.n ) ) {
								
								if ( this.greedy ) {
									
									while (Convert.ToDouble( times ) < Convert.ToDouble( this.m ) || Convert.ToDouble( this.m ) < 0) {
										
										if ( !Lang13.Bool( this.child.FindHere( txt, i, first, Convert.ToDouble( this.m ) < 0 ) ) ) {
											break;
										}
										i = this.child.FoundTo();
										times++;
									}
								}
								first.groups[this] = String13.SubStr( txt, Convert.ToInt32( start ), Convert.ToInt32( i ) );
							}
						}
						break;
					case 8:
						
						if ( Convert.ToDouble( i + this.n ) > ( e ??0) ) {
							times = -1;
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}

						if ( this.n == this.m ) {
							i += this.n;
							times = this.n;
							throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						}
						maxtimes = ( Convert.ToDouble( this.m ) < 0 ? ( e ??0) - Convert.ToDouble( i ) : Num13.MinInt( Convert.ToInt32( this.m ), ((int)( ( e ??0) - Convert.ToDouble( i ) )) ) );
						throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
						break;
					case 10:
					case 11:
						ch = ( Convert.ToDouble( i ) > 1 ? String13.GetCharCode( txt, Lang13.IntNullable( i - 1 ) ) : 0 );
						ch = ( ch < 48 || ch > 122 || ch > 57 && ch < 65 || ch > 90 && ch < 95 || ch == 96 ? false : true ) ?1:0;
						ch2 = ( Convert.ToDouble( i ) < ( e ??0) ? String13.GetCharCode( txt, Lang13.IntNullable( i ) ) : 0 );
						ch2 = ( ch2 < 48 || ch2 > 122 || ch2 > 57 && ch2 < 65 || ch2 > 90 && ch2 < 95 || ch2 == 96 ? false : true ) ?1:0;
						times += ch ^ ch2 ^ this.ptype & 1;
						break;
					case 16:
					case 18:
						
						if ( Convert.ToDouble( i ) <= 1 ) {
							times++;
						} else if ( !( ( this.ptype & first.flags & 2 ) != 0 ) && String13.GetCharCode( txt, Lang13.IntNullable( i - 1 ) ) == 10 ) {
							times++;
						}
						break;
					case 17:
					case 19:
						
						if ( Convert.ToDouble( i ) >= ( ee ??0) ) {
							times++;
						} else if ( !( ( this.ptype & first.flags & 2 ) != 0 ) && String13.GetCharCode( txt, Lang13.IntNullable( i ) ) == 10 ) {
							times++;
						}
						break;
					case 0:
						
						if ( Lang13.Bool( first.error ) ) {
							Game13.log.WriteMsg( "Regex " + first.pattern + " did not compile:\n" + first.error );
						}
						break;
					default:
						Game13.log.WriteMsg( "Block type " + this.ptype + " not handled yet" );
						break;
				}

				if ( Convert.ToDouble( times ) < Convert.ToDouble( this.n ) || nonzero == true && start == i ) {
					this.start = 0;
					this.end = 0;

					if ( o != null ) {
						Task13.Source = o;
						o = this.option;
						i = start;

						if ( ( first.flags & 2 ) != 0 ) {
							e = String13.Find( txt, "\n", Convert.ToInt32( i ), 0 ) != 0 || Lang13.Bool( ee ) ?1:0;
						}
						continue;
					}
					return 0;
				}
				this.end = i;

				if ( !Lang13.Bool( _default ) ) {
					_default = this.start;
				}

				if ( !( this.next != null ) ) {
					return _default;
				}
				Task13.Source = this.next;
				start = i;
				continue;

				if ( !this.greedy ) {
					
					if ( Lang13.Bool( after ) ) {
						
						if ( Lang13.Bool( after.Find( txt, i + this.n, first, i + maxtimes ) ) ) {
							this.end = after.start;
							return i;
						} else {
							times = -1;
						}
					} else {
						i += this.n;
						times = this.n;
					}
				} else if ( !Lang13.Bool( after ) ) {
					i += maxtimes;
					times = maxtimes;
				} else {
					j = ((Regex)after).FindLast( txt, i + this.n, first, i + maxtimes );
					times = j - i;
					i = j;
				}
				throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
			}
			return _default;
		}

		// Function from file: Regex.dm
		public dynamic FindLast( string txt = null, dynamic start = null, Regex first = null, dynamic stop = null, bool? anyline = null ) {
			start = start ?? 1;

			dynamic i = null;
			double? e = null;
			double? ee = null;
			bool isfirst = false;
			ByTable stack = null;

			
			if ( !( first != null ) ) {
				first = this;
				this.match = 0;
				this.index = 0;
				isfirst = true;

				if ( !( ( first.flags & 2 ) != 0 ) ) {
					anyline = true;
				}

				foreach (dynamic _a in Lang13.Enumerate( this.groups )) {
					i = _a;
					
					this.groups[i] = null;
				}
			}
			ee = Lang13.Length( txt ) + 1;
			e = ( Convert.ToDouble( start ) >= ( ee ??0) || ( first.flags & 2 ) != 0 || anyline == true ? ee : String13.Find( txt, "\n", Convert.ToInt32( start ), 0 ) != 0 || Lang13.Bool( ee ) ?1:0 );
			Task13.Sleep( 0 );
			stack = new ByTable();
			i = this.FirstPossible( txt, start, first, stop, anyline );

			while (Lang13.Bool( i ) && Convert.ToDouble( i ) <= ( e ??0)) {
				stack.Add( i );
				i = this.FirstPossible( txt, i + 1, first, stop, anyline );
			}

			while (stack.len != 0) {
				i = stack[stack.len];
				stack.len--;

				if ( Lang13.Bool( this.FindHere( txt, i, first ) ) ) {
					break;
				}
				i = 0;
			}

			if ( Lang13.Bool( i ) && isfirst ) {
				first.match = i;
				first.index = this.FoundTo();
			}
			return i;
		}

		// Function from file: Regex.dm
		public dynamic Find( string txt = null, dynamic start = null, Regex first = null, double? stop = null, bool? anyline = null ) {
			start = start ?? 1;

			dynamic i = null;
			double? e = null;
			double? ee = null;
			bool isfirst = false;

			
			if ( !( first != null ) ) {
				first = this;
				this.match = 0;
				this.index = 0;
				isfirst = true;

				if ( !( ( first.flags & 2 ) != 0 ) ) {
					anyline = true;
				}

				foreach (dynamic _a in Lang13.Enumerate( this.groups )) {
					i = _a;
					
					this.groups[i] = null;
				}
			}
			ee = Lang13.Length( txt ) + 1;
			e = ( Convert.ToDouble( start ) >= ( ee ??0) || ( first.flags & 2 ) != 0 || anyline == true ? ee : String13.Find( txt, "\n", Convert.ToInt32( start ), 0 ) != 0 || Lang13.Bool( ee ) ?1:0 );
			Task13.Sleep( 0 );
			i = this.FirstPossible( txt, start, first, stop, anyline );

			while (Lang13.Bool( i ) && Convert.ToDouble( i ) <= ( e ??0)) {
				
				if ( Lang13.Bool( this.FindHere( txt, i, first ) ) ) {
					break;
				}
				i = this.FirstPossible( txt, i + 1, first, stop, anyline );
			}

			if ( Lang13.Bool( i ) && isfirst ) {
				first.match = i;
				first.index = this.FoundTo();
			}
			return i;
		}

		// Function from file: Regex.dm
		public dynamic TrueBlock(  ) {
			dynamic _default = null;

			Regex p = null;

			
			if ( !( this.ptype != 0 ) ) {
				return this.pattern;
			}

			switch ((int)( this.ptype )) {
				case 1:
					_default = this.pattern;
					break;
				case 2:
					_default = "[" + this.pattern + "]";
					break;
				case 3:
					_default = "[^" + this.pattern + "]";
					break;
				case 4:
					_default = "(";
					p = null;
					p = this.child;

					while (p != null) {
						_default += "" + p.TrueBlock();
						p = p.next;
					}
					_default += ")";
					break;
				case 8:
					_default = ".";
					break;
				case 10:
					_default = "\\b";
					break;
				case 11:
					_default = "\\B";
					break;
				case 12:
				case 14:
					_default = "$" + this.pattern;
					break;
				case 13:
					_default = "\\" + this.pattern;
					break;
				case 16:
					return "^";
					break;
				case 17:
					return "$";
					break;
				case 18:
					return "\\A";
					break;
				case 19:
					return "\\Z";
					break;
			}

			if ( this.n == 1 && this.m == 1 ) {
				return _default;
			}

			if ( this.m == -1 ) {
				
				if ( !Lang13.Bool( this.n ) ) {
					_default += "*";
				} else if ( this.n == 1 ) {
					_default += "+";
				} else {
					_default += "{" + this.n + ",}";
				}
			} else if ( this.n == 0 && this.m == 1 ) {
				_default += "?";
			} else {
				_default += "{" + this.n + "," + this.m + "}";
			}

			if ( !this.greedy ) {
				_default += "?";
			}
			return _default;
		}

		// Function from file: Regex.dm
		public void CompileBlocks( bool? follow = null, Regex first = null, bool? rep = null, Regex parent = null ) {
			Regex o = null;
			Regex p = null;
			int ch = 0;
			int ch2 = 0;
			int optchar = 0;
			int? e = null;
			Regex q = null;

			
			if ( !( first != null ) ) {
				
				if ( this.ptype != 0 ) {
					return;
				}
				first = this;

				if ( this.replace != null ) {
					this.replace.CompileBlocks( null, this, true );
				}
			}
			optchar = ( rep == true ? ( parent != null && parent.ptype == 4 ? 44 : 0 ) : 124 );
			o = this;

			while (o != null) {
				p = o;

				while (p != null) {
					p.ptype = p.BlockType( rep );

					if ( !( p.ptype != 0 ) ) {
						
						if ( String13.GetCharCode( p.pattern, Lang13.IntNullable( p.start ) ) == optchar ) {
							o.option = p.next;
							Lang13.Delete( p );
							p = null;
							break;
						}

						if ( !( p != null ) ) {
							break;
						}
						p.ptype = 1;
					}
					p = p.next;
				}
				p = o;

				while (p != null) {
					p.nextup = follow;

					if ( p.child != null ) {
						
						if ( !( rep == true ) ) {
							
							if ( !( first.groups != null ) ) {
								first.groups = new ByTable();
							}
							first.groups.Add( p );
						}
						p.child.CompileBlocks( p.next != null || follow == true, first, rep, p );
					}
					e = Lang13.Bool( p.premodend ) || Lang13.Bool( p.end ) ?1:0;

					switch ((int)( p.ptype )) {
						case 1:
							
							if ( String13.GetCharCode( p.pattern, Lang13.IntNullable( p.start ) ) == 92 ) {
								ch = String13.GetCharCode( p.pattern, Lang13.IntNullable( ++p.start ) );

								if ( ch == 110 ) {
									ch = 10;
								} else if ( ch == 116 ) {
									ch = 9;
								} else if ( ch == 48 ) {
									ch = 0;
									ch2 = 48;

									do {
										ch = ch * 8 + ( ch2 - 48 );
										ch2 = ( Convert.ToDouble( p.start ) < ( e ??0) ? String13.GetCharCode( p.pattern, Lang13.IntNullable( ++p.start ) ) : 0 );
									} while ( ch2 >= 48 && ch2 <= 57 );
								} else if ( ch == 120 || ch == 88 ) {
									ch = 0;
									ch2 = 0;

									do {
										ch = ch * 16 + ch2;
										ch2 = ( Convert.ToDouble( p.start ) < ( e ??0) ? String13.GetCharCode( p.pattern, Lang13.IntNullable( ++p.start ) ) : 0 );

										if ( ch2 >= 48 && ch2 <= 57 ) {
											ch2 -= 48;
										} else {
											ch2 |= 32;

											if ( ch2 >= 97 && ch2 <= 102 ) {
												ch2 -= 87;
											} else {
												break;
											}
										}
									} while ( Convert.ToDouble( p.start ) <= ( e ??0) );
								}

								if ( ch == 47 ) {
									throw new Exception("Failed to remove goto!"); // FIXME, GOTO;
								}
								p.pattern = String13.GetCharFromCode( ch );
								p = p.next;
								continue;
							}
							p.pattern = String13.SubStr( p.pattern, Convert.ToInt32( p.start ), e ??0 );
							break;
						case 5:
							p.pattern = String13.SubStr( p.pattern, Convert.ToInt32( p.start ), e ??0 );
							break;
						case 2:
						case 3:
							
							if ( String13.GetCharCode( p.pattern, Lang13.IntNullable( p.start ) ) == 92 ) {
								ch = GlobalVars.regex_classes.Find( String13.GetCharCode( p.pattern, Lang13.IntNullable( p.start + 1 ) ) | 32 );

								if ( !( ch != 0 ) ) {
									p.pattern = String13.ToLower( String13.SubStr( p.pattern, Convert.ToInt32( p.start ), e ??0 ) );
								} else {
									p.pattern = GlobalVars.regex_classtrans[ch];
								}
							} else {
								p.pattern = String13.SubStr( p.pattern, Convert.ToInt32( p.start + ( p.ptype - 1 ) ), ( e ??0) - 1 );
							}
							p.CompileClass( first.flags );
							break;
						case 12:
						case 13:
							p.pattern = String13.ParseNumber( String13.SubStr( p.pattern, Convert.ToInt32( p.start + 1 ), e ??0 ) );
							break;
						case 14:
							p.pattern = String13.SubStr( p.pattern, Convert.ToInt32( p.start + 1 ), e ??0 );

							if ( !( first.namedvars != null ) ) {
								first.namedvars = new ByTable();
							}
							first.namedvars[p.pattern] = null;
							break;
						default:
							p.pattern = null;
							break;
					}
					p = p.next;
				}
				p = o;

				while (p != null) {
					
					if ( p.ptype != 1 || p.n != 1 || p.m != 1 ) {
						
					} else {
						
						while (p.next != null && p.next.ptype == 1 && p.next.n == 1 && p.next.m == 1) {
							p.pattern += p.next.pattern;
							q = p.next;
							p.next = p.next.next;
							Lang13.Delete( q );
							q = null;
						}
					}
					p = p.next;
				}
				o = o.option;
			}
			return;
		}

		// Function from file: Regex.dm
		public void CompileClass( int f = 0 ) {
			ByTable L = null;
			int ch = 0;
			int ch2 = 0;
			int lastch = 0;
			int i = 0;

			L = new ByTable(new object [] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
			lastch = 0;
			this.index = 1;
			this.end = Lang13.Length( this.pattern ) + 1;

			while (Convert.ToDouble( this.index ) < Convert.ToDouble( this.end )) {
				ch = String13.GetCharCode( this.pattern, Lang13.IntNullable( this.index++ ) );

				if ( ch == 45 && Convert.ToDouble( this.index ) < Convert.ToDouble( this.end ) ) {
					continue;
				}

				if ( ch == 92 ) {
					ch2 = this.Advance();
					i = GlobalVars.regex_classes.Find( ch2 | 32 );

					if ( i != 0 ) {
						
						if ( ( ch2 & 32 ) != 0 ) {
							this.pattern = String13.SubStr( this.pattern, 1, Convert.ToInt32( this.index - 2 ) ) + GlobalVars.regex_classtrans[i] + String13.SubStr( this.pattern, Convert.ToInt32( this.index ), 0 );
						} else {
							this.pattern = String13.SubStr( this.pattern, 1, Convert.ToInt32( this.index - 2 ) ) + GlobalVars.regex_classinv[i] + String13.SubStr( this.pattern, Convert.ToInt32( this.index ), 0 );
						}
						this.index -= 2;
						this.end = Lang13.Length( this.pattern ) + 1;
						continue;
					}

					if ( ch2 == 110 ) {
						ch = 10;
					} else if ( ch2 == 116 ) {
						ch = 9;
					} else if ( ch2 == 120 || ch2 == 88 ) {
						ch = 0;
						ch2 = 0;

						do {
							ch = ch * 16 + ch2;
							ch2 = this.Advance();

							if ( !( ch2 != 0 ) ) {
								break;
							}

							if ( ch2 >= 48 && ch2 <= 57 ) {
								ch2 -= 48;
							} else {
								ch2 |= 32;

								if ( ch2 >= 97 && ch2 <= 102 ) {
									ch2 -= 87;
								} else {
									this.index--;
									break;
								}
							}
						} while ( Convert.ToDouble( this.index ) <= Convert.ToDouble( this.end ) );
					} else if ( ch2 == 48 ) {
						ch = 0;
						ch2 = 48;

						do {
							ch = ch * 8 + ch2;
							ch2 = this.Advance();

							if ( !( ch2 != 0 ) ) {
								break;
							}

							if ( ch2 >= 48 && ch2 <= 57 ) {
								ch2 -= 48;
							} else {
								this.index--;
								break;
							}
						} while ( Convert.ToDouble( this.index ) <= Convert.ToDouble( this.end ) );
					} else {
						ch = ch2;
					}
				}

				if ( lastch != 0 ) {
					
					if ( lastch > ch ) {
						ch2 = ch;
						ch = lastch;
						lastch = ch2;
					}
					ch += 15;
					lastch += 15;

					if ( lastch >> 4 < ch >> 4 ) {
						L[lastch >> 4] |= -( 1 << ( lastch & 15 ) );
						lastch = lastch + 16 & 240;
					}

					while (lastch + 16 <= ch) {
						L[lastch >> 4] |= 65535;
						lastch += 16;
					}
					L[ch >> 4] |= ( 1 << ( ch & 15 ) ) - ( 1 << ( lastch & 15 ) );
					lastch = 0;
				} else {
					
					if ( this.LookAhead() == 45 ) {
						lastch = ch;
						this.index++;
					}
					ch += 15;
				}
				L[ch >> 4] |= 1 << ( ch & 15 );
			}

			if ( ( f & 1 ) != 0 ) {
				L[5] |= L[7];
				L[7] |= L[5];
				L[6] |= L[8] & 1023;
				L[8] |= L[6] & 1023;
				L[12] |= L[14] & 32768;
				L[14] |= L[12] & 32768;
				L[13] |= L[15];
				L[15] |= L[13];
				L[14] |= L[16] & 65471;
				L[16] |= L[14] & 65471;
			}
			this.pattern = L;
			return;
		}

		// Function from file: Regex.dm
		public int BlockType( bool? rep = null ) {
			int ch = 0;

			
			if ( this.ptype != 0 ) {
				return this.ptype;
			}

			if ( rep == true ) {
				
				switch ((int)( String13.GetCharCode( this.pattern, Lang13.IntNullable( this.start ) ) )) {
					case 36:
						
						if ( Convert.ToDouble( this.end - this.start ) <= 1 ) {
							return 1;
						}
						ch = String13.GetCharCode( this.pattern, Lang13.IntNullable( this.start + 1 ) );
						return ( ch >= 48 && ch <= 57 ? 12 : 14 );
						break;
					case 44:
						return ( this.end - this.start == 1 ? false : true ) ?1:0;
						break;
				}

				if ( this.child != null ) {
					return ( String13.GetCharCode( this.pattern, Lang13.IntNullable( this.start ) ) == 91 ? 5 : 4 );
				}
				return 1;
			}

			switch ((int)( String13.GetCharCode( this.pattern, Lang13.IntNullable( this.start ) ) )) {
				case 92:
					ch = String13.GetCharCode( this.pattern, Lang13.IntNullable( this.start + 1 ) );

					if ( GlobalVars.regex_classes.Contains( ch | 32 ) ) {
						return ( ( ch & 32 ) != 0 ? 2 : 3 );
					}

					if ( ( ch | 32 ) == 98 ) {
						return ( ( ch & 32 ) != 0 ? 10 : 11 );
					}

					if ( ( ch | 32 ) == 97 ) {
						return 18;
					}

					if ( ( ch | 32 ) == 122 ) {
						return 19;
					}

					if ( ch >= 49 && ch <= 57 ) {
						return 13;
					}
					return 1;
					break;
				case 91:
					
					if ( String13.GetCharCode( this.pattern, Lang13.IntNullable( this.start + 1 ) ) == 94 ) {
						return 3;
					}
					return 2;
					break;
				case 40:
					return 4;
					break;
				case 46:
					return 8;
					break;
				case 94:
					return 16;
					break;
				case 36:
					
					if ( Convert.ToDouble( this.end - this.start ) <= 1 ) {
						return 17;
					}
					ch = String13.GetCharCode( this.pattern, Lang13.IntNullable( this.start + 1 ) );
					return ( ch >= 48 && ch <= 57 ? 12 : 14 );
					break;
			}
			return 0;
		}

		// Function from file: Regex.dm
		public Regex MarkError( Regex first = null, dynamic i = null, string msg = null, dynamic ch = null ) {
			first.error = String13.SubStr( this.pattern, 1, Convert.ToInt32( i ) ) + ( "  <-- " + msg );

			if ( !( ch == null ) ) {
				
				if ( !Lang13.Bool( ch ) ) {
					first.error += " " + String13.SubStr( this.pattern, Lang13.Length( this.pattern ), 0 );
				} else {
					first.error += " " + String13.GetCharFromCode( Convert.ToInt32( ch ) );
				}
			}
			return this;
		}

		// Function from file: Regex.dm
		public bool NumAdvance( int? radix = null ) {
			radix = radix ?? 10;

			bool _default = false;

			int chn = 0;

			chn = this.LookAhead();

			if ( !( chn != 0 ) ) {
				return false;
			}

			while (chn >= 48 && chn <= 57 || chn >= 65 && chn <= ( radix ??0) + 54 || chn >= 97 && chn <= ( radix ??0) + 86) {
				_default = true;

				if ( Convert.ToDouble( ++this.index ) >= Convert.ToDouble( this.end ) ) {
					break;
				}
				chn = String13.GetCharCode( this.pattern, Lang13.IntNullable( this.index ) );
			}
			return _default;
		}

		// Function from file: Regex.dm
		public int LookAhead(  ) {
			
			if ( Convert.ToDouble( this.index ) >= Convert.ToDouble( this.end ) ) {
				return 0;
			}
			return String13.GetCharCode( this.pattern, Lang13.IntNullable( this.index ) );
		}

		// Function from file: Regex.dm
		public int Advance(  ) {
			
			if ( Convert.ToDouble( this.index ) >= Convert.ToDouble( this.end ) ) {
				return 0;
			}
			return String13.GetCharCode( this.pattern, Lang13.IntNullable( this.index++ ) );
		}

		// Function from file: Regex.dm
		public Regex BreakOff( dynamic p = null, Regex first = null ) {
			this.next = new Regex( p, --this.index, first, this );

			if ( !Lang13.Bool( first.error ) && first == this ) {
				this.CompileBlocks();
			}
			return this;
		}

		// Function from file: Regex.dm
		public Regex ParseCharClass( Regex first = null ) {
			dynamic i = null;
			int? ch = null;
			int ch2 = 0;
			dynamic lastch = null;
			dynamic rangechar = null;
			dynamic s = null;

			lastch = 0;
			rangechar = 0;
			s = this.index;

			while (Convert.ToDouble( this.index ) < Convert.ToDouble( this.end ) && !Lang13.Bool( first.error )) {
				i = this.index;
				ch = String13.GetCharCode( this.pattern, Lang13.IntNullable( this.index++ ) );

				if ( ch == 93 ) {
					
					if ( Convert.ToDouble( this.index ) <= Convert.ToDouble( s + 1 ) ) {
						return this.MarkError( first, this.index, "Unexpected char:", ch );
					}
					return null;
				}

				switch ((int?)( ch )) {
					case 94:
						
						if ( Convert.ToDouble( this.index ) > Convert.ToDouble( s + 1 ) ) {
							return this.MarkError( first, this.index, "Unexpected char:", ch );
						}
						break;
					case 92:
						ch2 = this.Advance();

						if ( !( ch2 != 0 ) ) {
							return this.MarkError( first, this.index, "Unexpected char:", ch );
						}

						if ( ch2 == 120 || ch2 == 88 ) {
							
							if ( !this.NumAdvance( 16 ) ) {
								return this.MarkError( first, this.index, "Unexpected char:", this.LookAhead() );
							}

							if ( ch2 != 0 ) {
								this.index--;
							}
							ch2 = 48;
						} else if ( this.NumAdvance() ) {
							ch2 = 48;
						} else if ( !GlobalVars.regex_classes.Contains( ch2 | 32 ) ) {
							
							if ( Lang13.Bool( rangechar ) ) {
								rangechar = this.index - 1;
							} else {
								lastch = i;
							}
						} else if ( Lang13.Bool( rangechar ) ) {
							return this.MarkError( first, this.index, "Invalid chracter range: " + String13.SubStr( this.pattern, Convert.ToInt32( rangechar ), Convert.ToInt32( this.index ) ) );
						}
						break;
					case 45:
						
						if ( !Lang13.Bool( lastch ) ) {
							return this.MarkError( first, this.index, "Unexpected char:", ch );
						}
						rangechar = lastch;
						break;
					default:
						
						if ( Lang13.Bool( rangechar ) ) {
							rangechar = 0;
						} else {
							lastch = i;
						}
						break;
				}
			}
			return this.MarkError( first, this.index, "Expected ", 93 );
		}

	}

}