// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class SortInstance : Game_Data {

		public dynamic L = null;
		public System.Reflection.MethodInfo cmp = typeof(GlobalFuncs).GetMethod( "cmp_numeric_asc" );
		public bool associative = false;
		public int minGallop = 7;
		public ByTable runBases = new ByTable();
		public ByTable runLens = new ByTable();

		// Function from file: _Main.dm
		public void mergeAt2( int i = 0 ) {
			double? cursor1 = null;
			double? cursor2 = null;
			double? end1 = null;
			double? end2 = null;
			dynamic val1 = null;
			dynamic val2 = null;

			cursor1 = Lang13.DoubleNullable( this.runBases[i] );
			cursor2 = Lang13.DoubleNullable( this.runBases[i + 1] );
			end1 = ( cursor1 ??0) + Convert.ToDouble( this.runLens[i] );
			end2 = ( cursor2 ??0) + Convert.ToDouble( this.runLens[i + 1] );
			val1 = ( this.associative ? this.L[this.L[cursor1]] : this.L[cursor1] );
			val2 = ( this.associative ? this.L[this.L[cursor2]] : this.L[cursor2] );

			while (true) {
				
				if ( Convert.ToDouble( Lang13.Call( this.cmp, val1, val2 ) ) < 0 ) {
					
					if ( ( ++cursor1 ??0) >= ( end1 ??0) ) {
						break;
					}
					val1 = ( this.associative ? this.L[this.L[cursor1]] : this.L[cursor1] );
				} else {
					GlobalFuncs.moveElement( this.L, cursor2, cursor1 );
					cursor2++;

					if ( ( ++cursor2 ??0) >= ( end2 ??0) ) {
						break;
					}
					end1++;
					cursor1++;
					val2 = ( this.associative ? this.L[this.L[cursor2]] : this.L[cursor2] );
				}
			}
			this.runLens[i] += this.runLens[i + 1];
			this.runLens.Cut( i + 1, i + 2 );
			this.runBases.Cut( i + 1, i + 2 );
			return;
		}

		// Function from file: _Main.dm
		public dynamic mergeSort( double? start = null, double? end = null ) {
			double remaining = 0;
			double minRun = 0;
			double runLen = 0;
			int n = 0;
			int n2 = 0;

			remaining = ( end ??0) - ( start ??0);

			if ( remaining < 32 ) {
				this.binarySort( start, end, start );
				return null;
			}
			minRun = this.minRunLength( remaining );

			do {
				runLen = ( remaining <= minRun ? remaining : minRun );
				this.binarySort( start, ( start ??0) + runLen, start );
				this.runBases.Add( start );
				this.runLens.Add( runLen );
				start += runLen;
				remaining -= runLen;
			} while ( remaining > 0 );

			while (this.runBases.len >= 2) {
				n = this.runBases.len - 1;

				if ( n > 1 && Convert.ToDouble( this.runLens[n - 1] ) <= Convert.ToDouble( this.runLens[n] + this.runLens[n + 1] ) ) {
					
					if ( Convert.ToDouble( this.runLens[n - 1] ) < Convert.ToDouble( this.runLens[n + 1] ) ) {
						n--;
					}
					this.mergeAt2( n );
				} else if ( Convert.ToDouble( this.runLens[n] ) <= Convert.ToDouble( this.runLens[n + 1] ) ) {
					this.mergeAt2( n );
				} else {
					break;
				}
			}

			while (this.runBases.len >= 2) {
				n2 = this.runBases.len - 1;

				if ( n2 > 1 && Convert.ToDouble( this.runLens[n2 - 1] ) < Convert.ToDouble( this.runLens[n2 + 1] ) ) {
					n2--;
				}
				this.mergeAt2( n2 );
			}
			return this.L;
		}

		// Function from file: _Main.dm
		public void mergeHi( double? base1 = null, double? len1 = null, double? base2 = null, double? len2 = null ) {
			double cursor1 = 0;
			double cursor2 = 0;
			double? count1 = null;
			double count2 = 0;

			cursor1 = ( base1 ??0) + ( len1 ??0) - 1;
			cursor2 = ( base2 ??0) + ( len2 ??0) - 1;

			if ( len2 == 1 ) {
				GlobalFuncs.moveElement( this.L, base2, base1 );
				return;
			}

			if ( len1 == 1 ) {
				GlobalFuncs.moveElement( this.L, base1, cursor2 + 1 );
				return;
			}
			GlobalFuncs.moveElement( this.L, cursor1--, cursor2-- + 1 );
			len1--;

			while (true) {
				count1 = 0;
				count2 = 0;
				string _loop_ctrl_1 = null;

				do {
					
					if ( Convert.ToDouble( Lang13.Call( this.cmp, ( this.associative ? this.L[this.L[cursor2]] : this.L[cursor2] ), ( this.associative ? this.L[this.L[cursor1]] : this.L[cursor1] ) ) ) < 0 ) {
						GlobalFuncs.moveElement( this.L, cursor1--, cursor2-- + 1 );
						len1--;
						count1++;
						count2 = 0;

						if ( len1 == 0 ) {
							_loop_ctrl_1 = "break";
							break;
						}
					} else {
						cursor2--;
						len2--;
						count2++;
						count1 = 0;

						if ( len2 == 1 ) {
							_loop_ctrl_1 = "break";
							break;
						}
					}
				} while ( ( ((int)( count1 ??0 )) | ((int)( count2 )) ) < this.minGallop );

				if ( _loop_ctrl_1 == "break" ) {
					break;
				} else if ( _loop_ctrl_1 == "continue" ) {
					continue;
				}
				string _loop_ctrl_2 = null;

				do {
					count1 = ( len1 ??0) - this.gallopRight( ( this.associative ? this.L[this.L[cursor2]] : this.L[cursor2] ), base1, len1, ( len1 ??0) - 1 );

					if ( Lang13.Bool( count1 ) ) {
						cursor1 -= count1 ??0;
						GlobalFuncs.moveRange( this.L, cursor1 + 1, cursor2 + 1, count1 );
						cursor2 -= count1 ??0;
						len1 -= count1 ??0;

						if ( len1 == 0 ) {
							_loop_ctrl_2 = "break";
							break;
						}
					}
					cursor2--;

					if ( --len2 == 1 ) {
						_loop_ctrl_2 = "break";
						break;
					}
					count2 = ( len2 ??0) - this.gallopLeft( ( this.associative ? this.L[this.L[cursor1]] : this.L[cursor1] ), cursor1 + 1, len2, ( len2 ??0) - 1 );

					if ( count2 != 0 ) {
						cursor2 -= count2;
						len2 -= count2;

						if ( ( len2 ??0) <= 1 ) {
							_loop_ctrl_2 = "break";
							break;
						}
					}
					GlobalFuncs.moveElement( this.L, cursor1--, cursor2-- + 1 );
					len1--;

					if ( len1 == 0 ) {
						_loop_ctrl_2 = "break";
						break;
					}
					this.minGallop--;
				} while ( ( ((int)( count1 ??0 )) | ((int)( count2 )) ) > 7 );

				if ( _loop_ctrl_2 == "break" ) {
					break;
				} else if ( _loop_ctrl_2 == "continue" ) {
					continue;
				}

				if ( this.minGallop < 0 ) {
					this.minGallop = 0;
				}
				this.minGallop += 2;
			}

			if ( len2 == 1 ) {
				cursor1 -= len1 ??0;
				GlobalFuncs.moveRange( this.L, cursor1 + 1, cursor2 + 1, len1 );
			}
			return;
		}

		// Function from file: _Main.dm
		public void mergeLo( double? base1 = null, double? len1 = null, double? base2 = null, double? len2 = null ) {
			double? cursor1 = null;
			double? cursor2 = null;
			double count1 = 0;
			double? count2 = null;

			cursor1 = base1;
			cursor2 = base2;

			if ( len2 == 1 ) {
				GlobalFuncs.moveElement( this.L, cursor2, cursor1 );
				return;
			}

			if ( len1 == 1 ) {
				GlobalFuncs.moveElement( this.L, cursor1, ( cursor2 ??0) + ( len2 ??0) );
				return;
			}
			GlobalFuncs.moveElement( this.L, cursor2++, cursor1++ );
			len2--;

			while (true) {
				count1 = 0;
				count2 = 0;
				string _loop_ctrl_1 = null;

				do {
					
					if ( Convert.ToDouble( Lang13.Call( this.cmp, ( this.associative ? this.L[this.L[cursor2]] : this.L[cursor2] ), ( this.associative ? this.L[this.L[cursor1]] : this.L[cursor1] ) ) ) < 0 ) {
						GlobalFuncs.moveElement( this.L, cursor2++, cursor1++ );
						len2--;
						count2++;
						count1 = 0;

						if ( len2 == 0 ) {
							_loop_ctrl_1 = "break";
							break;
						}
					} else {
						cursor1++;
						count1++;
						count2 = 0;

						if ( --len1 == 1 ) {
							_loop_ctrl_1 = "break";
							break;
						}
					}
				} while ( ( ((int)( count1 )) | ((int)( count2 ??0 )) ) < this.minGallop );

				if ( _loop_ctrl_1 == "break" ) {
					break;
				} else if ( _loop_ctrl_1 == "continue" ) {
					continue;
				}
				string _loop_ctrl_2 = null;

				do {
					count1 = this.gallopRight( ( this.associative ? this.L[this.L[cursor2]] : this.L[cursor2] ), cursor1, len1, 0 );

					if ( count1 != 0 ) {
						cursor1 += count1;
						len1 -= count1;

						if ( ( len1 ??0) <= 1 ) {
							_loop_ctrl_2 = "break";
							break;
						}
					}
					GlobalFuncs.moveElement( this.L, cursor2, cursor1 );
					cursor2++;
					cursor1++;

					if ( --len2 == 0 ) {
						_loop_ctrl_2 = "break";
						break;
					}
					count2 = this.gallopLeft( ( this.associative ? this.L[this.L[cursor1]] : this.L[cursor1] ), cursor2, len2, 0 );

					if ( Lang13.Bool( count2 ) ) {
						GlobalFuncs.moveRange( this.L, cursor2, cursor1, count2 );
						cursor2 += count2 ??0;
						cursor1 += count2 ??0;
						len2 -= count2 ??0;

						if ( len2 == 0 ) {
							_loop_ctrl_2 = "break";
							break;
						}
					}
					cursor1++;

					if ( --len1 == 1 ) {
						_loop_ctrl_2 = "break";
						break;
					}
					this.minGallop--;
				} while ( ( ((int)( count1 )) | ((int)( count2 ??0 )) ) > 7 );

				if ( _loop_ctrl_2 == "break" ) {
					break;
				} else if ( _loop_ctrl_2 == "continue" ) {
					continue;
				}

				if ( this.minGallop < 0 ) {
					this.minGallop = 0;
				}
				this.minGallop += 2;
			}

			if ( len1 == 1 ) {
				GlobalFuncs.moveElement( this.L, cursor1, ( cursor2 ??0) + ( len2 ??0) );
			}
			return;
		}

		// Function from file: _Main.dm
		public double gallopRight( dynamic key = null, double? _base = null, double? len = null, double hint = 0 ) {
			double offset = 0;
			double lastOffset = 0;
			double maxOffset = 0;
			double temp = 0;
			double maxOffset2 = 0;
			double m = 0;

			offset = 1;
			lastOffset = 0;

			if ( Convert.ToDouble( Lang13.Call( this.cmp, key, ( this.associative ? this.L[this.L[( _base ??0) + hint]] : this.L[( _base ??0) + hint] ) ) ) < 0 ) {
				maxOffset = hint + 1;

				while (offset < maxOffset && Convert.ToDouble( Lang13.Call( this.cmp, key, ( this.associative ? this.L[this.L[( _base ??0) + hint - offset]] : this.L[( _base ??0) + hint - offset] ) ) ) < 0) {
					lastOffset = offset;
					offset = ( ((int)( offset )) << 1 ) + 1;
				}

				if ( offset > maxOffset ) {
					offset = maxOffset;
				}
				temp = lastOffset;
				lastOffset = hint - offset;
				offset = hint - temp;
			} else {
				maxOffset2 = ( len ??0) - hint;

				while (offset < maxOffset2 && Convert.ToDouble( Lang13.Call( this.cmp, key, ( this.associative ? this.L[this.L[( _base ??0) + hint + offset]] : this.L[( _base ??0) + hint + offset] ) ) ) >= 0) {
					lastOffset = offset;
					offset = ( ((int)( offset )) << 1 ) + 1;
				}

				if ( offset > maxOffset2 ) {
					offset = maxOffset2;
				}
				lastOffset += hint;
				offset += hint;
			}
			lastOffset++;

			while (lastOffset < offset) {
				m = lastOffset + ( ((int)( offset - lastOffset )) >> 1 );

				if ( Convert.ToDouble( Lang13.Call( this.cmp, key, ( this.associative ? this.L[this.L[( _base ??0) + m]] : this.L[( _base ??0) + m] ) ) ) < 0 ) {
					offset = m;
				} else {
					lastOffset = m + 1;
				}
			}
			return offset;
		}

		// Function from file: _Main.dm
		public double gallopLeft( dynamic key = null, double? _base = null, double? len = null, double hint = 0 ) {
			double lastOffset = 0;
			double offset = 0;
			double maxOffset = 0;
			double maxOffset2 = 0;
			double temp = 0;
			double m = 0;

			lastOffset = 0;
			offset = 1;

			if ( Convert.ToDouble( Lang13.Call( this.cmp, key, ( this.associative ? this.L[this.L[( _base ??0) + hint]] : this.L[( _base ??0) + hint] ) ) ) > 0 ) {
				maxOffset = ( len ??0) - hint;

				while (offset < maxOffset && Convert.ToDouble( Lang13.Call( this.cmp, key, ( this.associative ? this.L[this.L[( _base ??0) + hint + offset]] : this.L[( _base ??0) + hint + offset] ) ) ) > 0) {
					lastOffset = offset;
					offset = ( ((int)( offset )) << 1 ) + 1;
				}

				if ( offset > maxOffset ) {
					offset = maxOffset;
				}
				lastOffset += hint;
				offset += hint;
			} else {
				maxOffset2 = hint + 1;

				while (offset < maxOffset2 && Convert.ToDouble( Lang13.Call( this.cmp, key, ( this.associative ? this.L[this.L[( _base ??0) + hint - offset]] : this.L[( _base ??0) + hint - offset] ) ) ) <= 0) {
					lastOffset = offset;
					offset = ( ((int)( offset )) << 1 ) + 1;
				}

				if ( offset > maxOffset2 ) {
					offset = maxOffset2;
				}
				temp = lastOffset;
				lastOffset = hint - offset;
				offset = hint - temp;
			}
			lastOffset++;

			while (lastOffset < offset) {
				m = lastOffset + ( ((int)( offset - lastOffset )) >> 1 );

				if ( Convert.ToDouble( Lang13.Call( this.cmp, key, ( this.associative ? this.L[this.L[( _base ??0) + m]] : this.L[( _base ??0) + m] ) ) ) > 0 ) {
					lastOffset = m + 1;
				} else {
					offset = m;
				}
			}
			return offset;
		}

		// Function from file: _Main.dm
		public void mergeAt( int i = 0 ) {
			double? base1 = null;
			double? base2 = null;
			double? len1 = null;
			double? len2 = null;
			double k = 0;

			base1 = Lang13.DoubleNullable( this.runBases[i] );
			base2 = Lang13.DoubleNullable( this.runBases[i + 1] );
			len1 = Lang13.DoubleNullable( this.runLens[i] );
			len2 = Lang13.DoubleNullable( this.runLens[i + 1] );
			this.runLens[i] += this.runLens[i + 1];
			this.runLens.Cut( i + 1, i + 2 );
			this.runBases.Cut( i + 1, i + 2 );
			k = this.gallopRight( ( this.associative ? this.L[this.L[base2]] : this.L[base2] ), base1, len1, 0 );
			base1 += k;
			len1 -= k;

			if ( len1 == 0 ) {
				return;
			}
			len2 = this.gallopLeft( ( this.associative ? this.L[this.L[( base1 ??0) + ( len1 ??0) - 1]] : this.L[( base1 ??0) + ( len1 ??0) - 1] ), base2, len2, ( len2 ??0) - 1 );

			if ( len2 == 0 ) {
				return;
			}

			if ( ( len1 ??0) <= ( len2 ??0) ) {
				this.mergeLo( base1, len1, base2, len2 );
			} else {
				this.mergeHi( base1, len1, base2, len2 );
			}
			return;
		}

		// Function from file: _Main.dm
		public void mergeForceCollapse(  ) {
			int n = 0;

			
			while (this.runBases.len >= 2) {
				n = this.runBases.len - 1;

				if ( n > 1 && Convert.ToDouble( this.runLens[n - 1] ) < Convert.ToDouble( this.runLens[n + 1] ) ) {
					n--;
				}
				this.mergeAt( n );
			}
			return;
		}

		// Function from file: _Main.dm
		public void mergeCollapse(  ) {
			int n = 0;

			
			while (this.runBases.len >= 2) {
				n = this.runBases.len - 1;

				if ( n > 1 && Convert.ToDouble( this.runLens[n - 1] ) <= Convert.ToDouble( this.runLens[n] + this.runLens[n + 1] ) ) {
					
					if ( Convert.ToDouble( this.runLens[n - 1] ) < Convert.ToDouble( this.runLens[n + 1] ) ) {
						n--;
					}
					this.mergeAt( n );
				} else if ( Convert.ToDouble( this.runLens[n] ) <= Convert.ToDouble( this.runLens[n + 1] ) ) {
					this.mergeAt( n );
				} else {
					break;
				}
			}
			return;
		}

		// Function from file: _Main.dm
		public double minRunLength( double n = 0 ) {
			int r = 0;

			r = 0;

			while (n >= 32) {
				r |= ((int)( n )) & 1;
				n = ((int)( n )) >> ( 1 );
			}
			return n + r;
		}

		// Function from file: _Main.dm
		public double countRunAndMakeAscending( double? lo = null, double? hi = null ) {
			double? runHi = null;
			dynamic last = null;
			dynamic current = null;

			runHi = ( lo ??0) + 1;

			if ( ( runHi ??0) >= ( hi ??0) ) {
				return 1;
			}
			last = ( this.associative ? this.L[this.L[lo]] : this.L[lo] );
			current = ( this.associative ? this.L[this.L[runHi++]] : this.L[runHi++] );

			if ( Convert.ToDouble( Lang13.Call( this.cmp, current, last ) ) < 0 ) {
				
				while (( runHi ??0) < ( hi ??0)) {
					last = current;
					current = ( this.associative ? this.L[this.L[runHi]] : this.L[runHi] );

					if ( Convert.ToDouble( Lang13.Call( this.cmp, current, last ) ) >= 0 ) {
						break;
					}
					runHi++;
				}
				GlobalFuncs.reverseRange( this.L, lo, runHi );
			} else {
				
				while (( runHi ??0) < ( hi ??0)) {
					last = current;
					current = ( this.associative ? this.L[this.L[runHi]] : this.L[runHi] );

					if ( Convert.ToDouble( Lang13.Call( this.cmp, current, last ) ) < 0 ) {
						break;
					}
					runHi++;
				}
			}
			return ( runHi ??0) - ( lo ??0);
		}

		// Function from file: _Main.dm
		public void binarySort( double? lo = null, double? hi = null, double? start = null ) {
			dynamic pivot = null;
			double? left = null;
			double? right = null;
			int mid = 0;

			
			if ( ( start ??0) <= ( lo ??0) ) {
				start = ( lo ??0) + 1;
			}

			while (( start ??0) < ( hi ??0)) {
				pivot = ( this.associative ? this.L[this.L[start]] : this.L[start] );
				left = lo;
				right = start;

				while (( left ??0) < ( right ??0)) {
					mid = ((int)( ( left ??0) + ( right ??0) )) >> 1;

					if ( Convert.ToDouble( Lang13.Call( this.cmp, ( this.associative ? this.L[this.L[mid]] : this.L[mid] ), pivot ) ) > 0 ) {
						right = mid;
					} else {
						left = mid + 1;
					}
				}
				GlobalFuncs.moveElement( this.L, start, left );
				start++;
			}
			return;
		}

		// Function from file: _Main.dm
		public dynamic timSort( double? start = null, double? end = null ) {
			double remaining = 0;
			double initRunLen = 0;
			double minRun = 0;
			double runLen = 0;
			double force = 0;

			this.runBases.Cut();
			this.runLens.Cut();
			remaining = ( end ??0) - ( start ??0);

			if ( remaining < 32 ) {
				initRunLen = this.countRunAndMakeAscending( start, end );
				this.binarySort( start, end, ( start ??0) + initRunLen );
				return null;
			}
			minRun = this.minRunLength( remaining );

			do {
				runLen = this.countRunAndMakeAscending( start, end );

				if ( runLen < minRun ) {
					force = ( remaining <= minRun ? remaining : minRun );
					this.binarySort( start, ( start ??0) + force, ( start ??0) + runLen );
					runLen = force;
				}
				this.runBases.Add( start );
				this.runLens.Add( runLen );
				this.mergeCollapse();
				start += runLen;
				remaining -= runLen;
			} while ( remaining > 0 );
			this.mergeForceCollapse();
			this.minGallop = 7;
			return this.L;
		}

	}

}