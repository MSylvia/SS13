// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Construction_Reversible : Construction {

		public double? index = null;

		// Function from file: construction_datum.dm
		public Construction_Reversible ( Ent_Static atom = null ) : base( atom ) {
			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;
			this.index = this.steps.len;
			return;
		}

		// Function from file: construction_datum.dm
		public override bool try_consume( dynamic user = null, dynamic used_atom = null, dynamic given_step = null, double? index = null, int? diff = null ) {
			dynamic current_step = null;
			dynamic S = null;
			Ent_Dynamic A = null;
			dynamic working_type = null;
			int? i = null;
			bool delay = false;
			double? amount = null;
			dynamic stack = null;
			dynamic welder = null;
			string atom_name = null;
			dynamic spawn_step = null;
			double? new_index = null;
			ByTable to_drop = null;
			dynamic to_create = null;
			dynamic test = null;
			dynamic S2 = null;
			int? i2 = null;
			Ent_Dynamic this_drop = null;

			current_step = ( diff == 1 ? this.get_forward_step( index ) : this.get_backward_step( index ) );

			if ( Lang13.Bool( used_atom.construction_delay_mult ) && !Lang13.Bool( used_atom.construction_delay_mult[( diff == -1 ? "construct" : "deconstruct" )] ) ) {
				GlobalFuncs.to_chat( user, "<span class='warning'>This tool only works for " + ( diff == -1 ? "de" : "" ) + "construction!</span>" );
				return false;
			}

			if ( Lang13.Bool( current_step ) && Lang13.Bool( current_step.Contains( "amount" ) ) && Lang13.Bool( current_step.Contains( "max_amount" ) ) && Convert.ToDouble( current_step["amount"] ) < Convert.ToDouble( current_step["max_amount"] ) ) {
				
				if ( Lang13.Bool( this.used_atoms["" + index + ( diff == -1 ? "+" : "-" )] ) ) {
					
					foreach (dynamic _a in Lang13.Enumerate( this.used_atoms["" + index + ( diff == -1 ? "+" : "-" )], typeof(Ent_Dynamic) )) {
						A = _a;
						
						A.loc = this.holder.loc;
					}
					this.used_atoms.Remove( "" + index + ( diff == -1 ? "+" : "-" ) );
				} else {
					working_type = ( GlobalFuncs.islist( current_step["key"] ) ? Rand13.PickFromTable( current_step["key"] ) : current_step["key"] );
					S = Lang13.Call( working_type, this.holder.loc );

					if ( S is Obj_Item_Stack && !Lang13.Bool( current_step.Contains( "keep" ) ) ) {
						S.amount = current_step["max_amount"] - current_step["amount"];
						S.update_icon();
					} else {
						i = null;
						i = 2;

						while (( i ??0) <= Convert.ToDouble( current_step["max_amount"] - current_step["amount"] )) {
							Lang13.Call( working_type, this.holder.loc );
							i++;
						}
					}
				}
				current_step["amount"] = current_step["max_amount"];
			}
			delay = false;

			if ( Lang13.Bool( given_step.Contains( "delay" ) ) ) {
				
				if ( Lang13.Bool( used_atom.construction_delay_mult ) ) {
					delay = Lang13.Bool( given_step["delay"] * used_atom.construction_delay_mult[( diff == -1 ? "construct" : "deconstruct" )] );
				} else {
					delay = Lang13.Bool( given_step["delay"] );
				}
			}

			if ( ( delay ?1:0) > 0 ) {
				this.start_construct_message( given_step, user, used_atom );

				if ( !GlobalFuncs.do_after( user, this.holder, delay, null, true ) ) {
					return false;
				}
			}
			amount = 0;

			if ( Lang13.Bool( given_step.Contains( "amount" ) ) ) {
				amount = Lang13.DoubleNullable( given_step["amount"] );
			}

			if ( ( amount ??0) > 0 ) {
				
				if ( used_atom is Obj_Item_Stack && !Lang13.Bool( given_step.Contains( "take" ) ) ) {
					stack = used_atom;

					if ( Convert.ToDouble( stack.amount ) < ( amount ??0) ) {
						GlobalFuncs.to_chat( user, new Txt( "<span class='notice'>You start adding " ).item( stack ).str( " to " ).the( this.holder ).item().str( ". It still needs " ).item( ( amount ??0) - Convert.ToDouble( stack.amount ) ).str( " " ).item( stack.singular_name ).str( ".</span>" ).ToString() );
						given_step["amount"] -= stack.amount;
						((Obj_Item_Stack)stack).use( Lang13.DoubleNullable( stack.amount ) );
						return false;
					}
					((Obj_Item_Stack)stack).use( amount );
				} else if ( used_atom is Obj_Item_Weapon_Weldingtool && !Lang13.Bool( given_step.Contains( "take" ) ) ) {
					welder = used_atom;

					if ( !((Obj_Item_Weapon_Weldingtool)welder).isOn() ) {
						GlobalFuncs.to_chat( user, new Txt( "<span class='notice'>You tap " ).the( this.holder ).item().str( " with your unlit welder.  " ).item( Rand13.Pick(new object [] { "Ding", "Dong" }) ).str( ".</span>" ).ToString() );
						return false;
					}

					if ( !((Obj_Item_Weapon_Weldingtool)welder).remove_fuel( amount, user ) ) {
						GlobalFuncs.to_chat( user, "<span class='rose'>You don't have enough fuel!</span>" );
						return false;
					}
				} else {
					atom_name = used_atom.name;

					if ( this.permanence || Lang13.Bool( given_step.Contains( "keep" ) ) ) {
						
						if ( ((Mob)user).drop_item( used_atom, this.holder ) ) {
							
							if ( !this.used_atoms.Contains( "" + index + ( diff == -1 ? "+" : "-" ) ) ) {
								this.used_atoms.Add( new ByTable().Set( "" + index + ( diff == -1 ? "+" : "-" ), new ByTable() ) );
							}
							this.used_atoms["" + index + ( diff == -1 ? "+" : "-" )] += used_atom;
						}
					} else {
						GlobalFuncs.qdel( used_atom );
					}
					given_step["amount"]--;

					if ( Convert.ToDouble( given_step["amount"] ) > 0 ) {
						GlobalFuncs.to_chat( user, new Txt( "<span class='notice'>You add " ).a( atom_name ).item().str( " to " ).the( this.holder ).item().str( ". It still needs " ).item( ( amount ??0) - 1 ).str( " " ).item( atom_name ).s().str( ".</span>" ).ToString() );
						return false;
					}
				}
				given_step["amount"] = given_step["max_amount"];
			} else {
				spawn_step = null;
				new_index = ( diff == -1 ? ( index ??0) - 1 : ( index ??0) + 1 );

				if ( new_index == 0 ) {
					GlobalFuncs.message_admins( "Holy shit " + this + "/(" + this.type + ") is trying to set its new index to 0! how the fuck did this happen? I don't know, our direction is " + ( diff == -1 ? "forward" : "backward" ) + " old index was " + index + ". User is " + GlobalFuncs.formatPlayerPanel( user, user.ckey ) + ", itemused " + used_atom + ", step " + given_step );
					this.spawn_result( user );
					return true;
				}

				if ( diff == -1 ) {
					spawn_step = this.get_backward_step( new_index );
				} else if ( diff == 1 ) {
					spawn_step = this.get_forward_step( new_index );
				}
				to_drop = new ByTable();

				if ( this.used_atoms.Contains( "" + new_index + ( diff == -1 ? "-" : "+" ) ) && Lang13.Bool( this.used_atoms["" + new_index + ( diff == -1 ? "-" : "+" )] ) ) {
					to_drop = this.used_atoms["" + new_index + ( diff == -1 ? "-" : "+" )];
					this.used_atoms.Remove( "" + new_index + ( diff == -1 ? "-" : "+" ) );
				} else if ( Lang13.Bool( spawn_step.Contains( "amount" ) ) ) {
					to_create = ( GlobalFuncs.islist( spawn_step["key"] ) ? Rand13.PickFromTable( spawn_step["key"] ) : spawn_step["key"] );
					test = Lang13.Call( to_create );

					if ( test is Obj_Item_Weapon_Weldingtool && !Lang13.Bool( spawn_step.Contains( "take" ) ) ) {
						GlobalFuncs.qdel( test );
					} else if ( test is Obj_Item_Stack && !Lang13.Bool( spawn_step.Contains( "take" ) ) ) {
						S2 = test;
						S2.amount = spawn_step["amount"];
						to_drop.Add( S2 );
					} else {
						to_drop.Add( test );
						i2 = null;
						i2 = 1;

						while (( i2 ??0) <= Convert.ToDouble( spawn_step["amount"] - 1 )) {
							to_drop.Add( Lang13.Call( to_create ) );
							i2++;
						}
					}
				}

				foreach (dynamic _b in Lang13.Enumerate( to_drop, typeof(Ent_Dynamic) )) {
					this_drop = _b;
					
					this_drop.loc = this.holder.loc;
				}
			}
			return true;
		}

		// Function from file: construction_datum.dm
		public override string fixText( string text = null, dynamic user = null, bool? self = null ) {
			self = self ?? false;

			return base.fixText( text, (object)(user), self );
		}

		// Function from file: construction_datum.dm
		public override void add_max_amounts(  ) {
			double? i = null;
			dynamic dir_step = null;

			i = null;
			i = 1;

			while (( i ??0) <= this.steps.len) {
				dir_step = this.get_forward_step( i );

				if ( Lang13.Bool( dir_step.Contains( "amount" ) ) ) {
					dir_step.Add( new ByTable().Set( "max_amount", dir_step["amount"] ) );
				}
				dir_step = this.get_backward_step( i );

				if ( Lang13.Bool( dir_step.Contains( "amount" ) ) ) {
					dir_step.Add( new ByTable().Set( "max_amount", dir_step["amount"] ) );
				}
				i++;
			}
			return;
		}

		// Function from file: construction_datum.dm
		public override void start_construct_message( dynamic step = null, dynamic user = null, dynamic used_atom = null ) {
			((Ent_Static)user).visible_message( this.fixText( step["start_msg"], user ), this.fixText( step["start_msg"], user, true ) );
			return;
		}

		// Function from file: construction_datum.dm
		public override void construct_message( dynamic step = null, dynamic user = null, dynamic diff = null, bool? _override = null ) {
			dynamic message_step = null;

			
			if ( !( _override == true ) ) {
				return;
			}

			if ( diff == -1 && Lang13.Bool( step.Contains( "nextstep" ) ) ) {
				message_step = step["nextstep"];
			} else if ( Lang13.Bool( step.Contains( "backstep" ) ) ) {
				message_step = step["backstep"];
			}

			if ( Lang13.Bool( message_step ) ) {
				((Ent_Static)user).visible_message( this.fixText( message_step["vis_msg"], user ), this.fixText( message_step["vis_msg"], user, true ) );
			}
			return;
		}

		// Function from file: construction_datum.dm
		public override bool custom_action( dynamic index = null, dynamic diff = null, dynamic used_atom = null, dynamic user = null ) {
			bool _default = false;

			_default = base.custom_action( (object)(index), (object)(used_atom), (object)(user), (object)(user) );

			if ( _default ) {
				this.construct_message( this.steps[index], user, diff, true );
			}
			return _default;
		}

		// Function from file: construction_datum.dm
		public override bool check_step( dynamic used_atom = null, dynamic user = null ) {
			dynamic diff = null;

			diff = this.is_right_key( user, used_atom );

			if ( Lang13.Bool( diff ) ) {
				this.assembling = true;

				if ( this.custom_action( this.index, diff, used_atom, user ) ) {
					this.update_index( diff, user );
					this.assembling = false;
					return true;
				}
				this.assembling = false;
			}
			return false;
		}

		// Function from file: construction_datum.dm
		public override int is_right_key( dynamic user = null, dynamic used_atom = null ) {
			dynamic step_next = null;
			dynamic step_back = null;

			
			if ( this.assembling ) {
				return 0;
			}
			this.assembling = true;
			step_next = this.get_forward_step( this.index );
			step_back = this.get_backward_step( this.index );

			if ( Lang13.Bool( step_next ) && ( GlobalFuncs.islist( step_next["key"] ) && GlobalFuncs.is_type_in_list( used_atom, step_next["key"] ) || Lang13.Bool( step_next["key"].IsInstanceOfType( used_atom ) ) ) ) {
				
				if ( !this.try_consume( user, used_atom, step_next, this.index, -1 ) ) {
					this.assembling = false;
					return 0;
				}
				return -1;
			}

			if ( Lang13.Bool( step_back ) && ( GlobalFuncs.islist( step_back["key"] ) && GlobalFuncs.is_type_in_list( used_atom, step_back["key"] ) || Lang13.Bool( step_back["key"].IsInstanceOfType( used_atom ) ) ) ) {
				
				if ( !this.try_consume( user, used_atom, step_back, this.index, 1 ) ) {
					this.assembling = false;
					return 0;
				}
				return 1;
			}
			this.assembling = false;
			return 0;
		}

		// Function from file: construction_datum.dm
		public dynamic get_backward_step( double? index = null ) {
			dynamic S = null;

			
			if ( ( index ??0) < 0 || ( index ??0) > this.steps.len ) {
				return null;
			}
			S = this.steps[index];

			if ( Lang13.Bool( S.Contains( "backstep" ) ) ) {
				return S["backstep"];
			}
			return null;
		}

		// Function from file: construction_datum.dm
		public dynamic get_forward_step( double? index = null ) {
			dynamic S = null;

			
			if ( ( index ??0) < 0 || ( index ??0) > this.steps.len ) {
				return null;
			}
			S = this.steps[index];

			if ( Lang13.Bool( S.Contains( "nextstep" ) ) ) {
				return S["nextstep"];
			}
			return null;
		}

		// Function from file: construction_datum.dm
		public void update_index( dynamic diff = null, dynamic user = null ) {
			this.index += Convert.ToDouble( diff );

			if ( this.index == 0 ) {
				this.spawn_result( user );
			} else {
				this.set_desc( this.index );
			}
			return;
		}

	}

}