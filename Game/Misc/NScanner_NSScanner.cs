// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class NScanner_NSScanner : NScanner {

		public dynamic codepos = 1;
		public dynamic line = 1;
		public dynamic linepos = 0;
		public NScriptOptions_NSOptions options = null;
		public bool commenting = false;
		public ByTable ignore = new ByTable(new object [] { " ", "	", "\n" });
		public ByTable end_stmt = new ByTable(new object [] { ";" });
		public ByTable string_delim = new ByTable(new object [] { "\"", "'" });
		public ByTable delim = new ByTable();

		// Function from file: Scanner.dm
		public NScanner_NSScanner ( string code = null, NScriptOptions_NSOptions options = null ) {
			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;
			this.ignore.Add( String13.GetCharFromCode( 13 ) );
			this.delim.Add( this.ignore + options.symbols + this.end_stmt + this.string_delim );
			this.options = options;
			this.LoadCode( code );
			return;
		}

		// Function from file: Scanner.dm
		public void ReadComment(  ) {
			string _char = null;
			string nextchar = null;
			string charstring = null;
			int comm = 0;
			bool expectedend = false;

			_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );
			nextchar = String13.SubStr( this.code, Convert.ToInt32( this.codepos + 1 ), Convert.ToInt32( this.codepos + 2 ) );
			charstring = _char + nextchar;
			comm = 1;
			expectedend = false;

			if ( charstring == "//" || charstring == "/*" ) {
				
				if ( charstring == "/*" ) {
					comm = 2;
				}

				while (comm != 0) {
					
					if ( Convert.ToDouble( ++this.codepos ) > Lang13.Length( this.code ) ) {
						break;
					}

					if ( expectedend ) {
						_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );

						if ( _char == "/" ) {
							comm = 0;
							break;
						}
					}

					if ( comm == 2 ) {
						_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );

						if ( _char == "*" ) {
							expectedend = true;
							continue;
						}
					} else {
						_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );

						if ( _char == "\n" ) {
							comm = 0;
							break;
						}
					}

					if ( expectedend ) {
						expectedend = false;
					}
				}

				if ( comm == 2 ) {
					this.errors.Add( new ScriptError_UnterminatedComment() );
				}
			}
			return;
		}

		// Function from file: Scanner.dm
		public Token_Number ReadNumber(  ) {
			string _char = null;
			string buf = null;
			bool dec = false;
			Token_Number T = null;

			_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );
			dec = false;

			while (this.options.IsDigit( _char ) || _char == "." && !dec) {
				
				if ( _char == "." ) {
					dec = true;
				}
				buf += _char;
				this.codepos++;
				_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );
			}
			T = new Token_Number( buf, this.line, this.codepos - this.linepos );

			if ( String13.ParseNumber( buf ) == null ) {
				this.errors.Add( new ScriptError( "Bad number: " ) );
				T.value = 0;
			}
			this.codepos--;
			return T;
		}

		// Function from file: Scanner.dm
		public Token_Symbol ReadSymbol(  ) {
			string _char = null;
			string buf = null;

			_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );

			while (this.options.symbols.Find( buf + _char ) != 0) {
				buf += _char;

				if ( Convert.ToDouble( ++this.codepos ) > Lang13.Length( this.code ) ) {
					break;
				}
				_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );
			}
			this.codepos--;
			return new Token_Symbol( buf, this.line, this.codepos - this.linepos );
		}

		// Function from file: Scanner.dm
		public Token ReadWord(  ) {
			string _char = null;
			string buf = null;

			_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );

			while (!( this.delim.Find( _char ) != 0 ) && Convert.ToDouble( this.codepos ) <= Lang13.Length( this.code )) {
				buf += _char;
				_char = String13.SubStr( this.code, Convert.ToInt32( ++this.codepos ), Convert.ToInt32( this.codepos + 1 ) );
			}
			this.codepos--;

			if ( this.options.keywords.Find( buf ) != 0 ) {
				return new Token_Keyword( buf, this.line, this.codepos - this.linepos );
			} else {
				return new Token_Word( buf, this.line, this.codepos - this.linepos );
			}
		}

		// Function from file: Scanner.dm
		public Token_String ReadString( string start = null ) {
			Token_String _default = null;

			string buf = null;
			string _char = null;

			
			while (Convert.ToDouble( this.codepos ) <= Lang13.Length( this.code )) {
				_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );

				switch ((string)( _char )) {
					case "\\":
						this.codepos++;
						_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );

						switch ((string)( _char )) {
							case "\\":
								buf += "\\";
								break;
							case "n":
								buf += "\n";
								break;
							default:
								
								if ( _char == start ) {
									buf += start;
								} else {
									buf += _char;
								}
								break;
						}
						break;
					case "\n":
						_default = new Token_String( buf, this.line, this.codepos - this.linepos );
						this.errors.Add( new ScriptError( "Unterminated string. Newline reached." ) );
						this.line++;
						this.linepos = this.codepos;
						break;
						break;
					default:
						
						if ( _char == start ) {
							break;
						} else {
							buf += _char;
						}
						break;
				}
				this.codepos++;
			}

			if ( !( _default != null ) ) {
				return new Token_String( buf, this.line, this.codepos - this.linepos );
			}
			return _default;
		}

		// Function from file: Scanner.dm
		public override ByTable Scan(  ) {
			ByTable tokens = null;
			string _char = null;
			string nextchar = null;

			tokens = new ByTable();

			while (Convert.ToDouble( this.codepos ) <= Lang13.Length( this.code )) {
				_char = String13.SubStr( this.code, Convert.ToInt32( this.codepos ), Convert.ToInt32( this.codepos + 1 ) );
				nextchar = String13.SubStr( this.code, Convert.ToInt32( this.codepos + 1 ), Convert.ToInt32( this.codepos + 2 ) );

				if ( _char == "\n" ) {
					this.line++;
					this.linepos = this.codepos;
				}

				if ( this.ignore.Find( _char ) != 0 ) {
					this.codepos++;
					continue;
				} else if ( _char == "/" && ( nextchar == "*" || nextchar == "/" ) ) {
					this.ReadComment();
				} else if ( this.end_stmt.Find( _char ) != 0 ) {
					tokens.Add( new Token_End( _char, this.line, this.codepos - this.linepos ) );
				} else if ( this.string_delim.Find( _char ) != 0 ) {
					this.codepos++;
					tokens.Add( this.ReadString( _char ) );
				} else if ( this.options.CanStartID( _char ) ) {
					tokens.Add( this.ReadWord() );
				} else if ( this.options.IsDigit( _char ) ) {
					tokens.Add( this.ReadNumber() );
				} else if ( this.options.symbols.Find( _char ) != 0 ) {
					tokens.Add( this.ReadSymbol() );
				}
				this.codepos++;
			}
			this.codepos = Lang13.Initial( this, "codepos" );
			this.line = Lang13.Initial( this, "line" );
			this.linepos = Lang13.Initial( this, "linepos" );
			return tokens;
		}

	}

}