// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class GarbageCollector : Game_Data {

		public ByTable queue = new ByTable();
		public bool del_everything = false;
		public int dels_count = 0;
		public int hard_dels = 0;

		// Function from file: garbage.dm
		public void dequeue( string id = null ) {
			
			if ( this.queue != null ) {
				this.queue.Remove( id );
			}
			this.dels_count++;
			return;
		}

		// Function from file: garbage.dm
		public void process(  ) {
			int remainingCollectionPerTick = 0;
			int remainingForceDelPerTick = 0;
			int collectionTimeScope = 0;
			dynamic refID = null;
			int destroyedAtTime = 0;
			dynamic D = null;
			dynamic AM = null;

			remainingCollectionPerTick = 300;
			remainingForceDelPerTick = 60;
			collectionTimeScope = Game13.timeofday - 300;

			if ( GlobalVars.narsie_cometh ) {
				return;
			}

			while (this.queue.len != 0 && --remainingCollectionPerTick >= 0) {
				refID = this.queue[1];
				destroyedAtTime = Convert.ToInt32( this.queue[refID] );

				if ( destroyedAtTime > collectionTimeScope ) {
					break;
				}
				D = Lang13.FindObj( refID );

				if ( Lang13.Bool( D ) ) {
					
					if ( D.gcDestroyed == null ) {
						this.queue.Remove( refID );
						continue;
					}

					if ( remainingForceDelPerTick <= 0 ) {
						break;
					}

					if ( D is Ent_Dynamic ) {
						AM = D;
						AM.hard_deleted = true;
					}
					Lang13.Delete( D );
					D = null;
					this.hard_dels++;
					remainingForceDelPerTick--;

					if ( Game13.cpu > 80 ) {
						Task13.Sleep( ((int)( Game13.tick_lag * 2 )) );
					}
				}
			}
			return;
		}

		// Function from file: garbage.dm
		public void addTrash( dynamic D = null ) {
			
			if ( D is Ent_Static && !( D is Ent_Dynamic ) ) {
				return;
			}

			if ( this.del_everything ) {
				Lang13.Delete( D );
				
				this.hard_dels++;
				this.dels_count++;
				return;
			}
			this.queue[new Txt().Ref( D ).ToString()] = Game13.timeofday;
			return;
		}

	}

}