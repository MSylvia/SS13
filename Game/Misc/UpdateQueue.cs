// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class UpdateQueue : Game_Data {

		public ByTable objects = null;
		public dynamic previousStart = null;
		public string procName = null;
		public ByTable arguments = null;
		public UpdateQueueWorker currentWorker = null;
		public int? workerTimeout = null;
		public int? adjustedWorkerTimeout = null;
		public int currentKillCount = 0;
		public int totalKillCount = 0;

		// Function from file: updateQueue.dm
		public UpdateQueue ( ByTable objects = null, string procName = null, ByTable arguments = null, int? workerTimeout = null, bool? inplace = null ) {
			objects = objects ?? new ByTable();
			procName = procName ?? "update";
			arguments = arguments ?? new ByTable();
			workerTimeout = workerTimeout ?? 2;
			inplace = inplace ?? false;

			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;
			this.init( objects, procName, arguments, workerTimeout, inplace );
			return;
		}

		// Function from file: updateQueue.dm
		public void killWorker(  ) {
			this.currentWorker.kill();
			this.currentWorker = null;
			Task13.Sleep( -1 );
			this.currentKillCount++;
			this.totalKillCount++;

			if ( this.currentKillCount >= 3 ) {
				this.adjustedWorkerTimeout++;
				this.currentKillCount = 0;
			}
			return;
		}

		// Function from file: updateQueue.dm
		public void startWorker(  ) {
			
			if ( this.objects.len != 0 ) {
				
				if ( this.currentWorker is UpdateQueueWorker ) {
					this.currentWorker.init( this.objects, this.procName, this.arguments );
				} else {
					this.currentWorker = new UpdateQueueWorker( this.objects, this.procName, this.arguments );
				}
				this.currentWorker.start();
			} else {
				this.currentWorker = null;
			}
			return;
		}

		// Function from file: updateQueue.dm
		public void checkWorker(  ) {
			
			if ( this.currentWorker is UpdateQueueWorker ) {
				
				if ( Game13.timeofday < this.currentWorker.lastStart ) {
					this.currentWorker.lastStart -= 864000;
				}

				if ( Game13.timeofday - this.currentWorker.lastStart > ( this.adjustedWorkerTimeout ??0) ) {
					this.killWorker();
					this.startWorker();
				}
			} else {
				this.startWorker();
			}
			return;
		}

		// Function from file: updateQueue.dm
		public void Run(  ) {
			this.startWorker();

			while (this.currentWorker is UpdateQueueWorker && !this.currentWorker.finished) {
				Task13.Sleep( 2 );
				this.checkWorker();
			}
			return;
		}

		// Function from file: updateQueue.dm
		public void initList( ByTable toCopy = null ) {
			int? i = null;

			this.objects = new ByTable();
			i = null;
			i = toCopy.len;

			while (( i ??0) > 0) {
				this.objects.len++;
				this.objects[this.objects.len] = toCopy[i--];
			}
			return;
		}

		// Function from file: updateQueue.dm
		public void init( ByTable objects = null, string procName = null, ByTable arguments = null, int? workerTimeout = null, bool? inplace = null ) {
			objects = objects ?? new ByTable();
			procName = procName ?? "update";
			arguments = arguments ?? new ByTable();
			workerTimeout = workerTimeout ?? 2;
			inplace = inplace ?? false;

			
			if ( !( inplace == true ) ) {
				this.initList( objects );
			} else {
				this.objects = objects;
			}
			this.procName = procName;
			this.arguments = arguments;
			this.workerTimeout = workerTimeout;
			this.adjustedWorkerTimeout = workerTimeout;
			this.currentKillCount = 0;
			this.totalKillCount = 0;
			return;
		}

	}

}