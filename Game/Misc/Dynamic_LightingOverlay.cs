// FILE AUTOGENERATED BY SOMNIUM13.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Dynamic_LightingOverlay : Ent_Dynamic {

		public double lum_r = 0;
		public double lum_g = 0;
		public double lum_b = 0;
		public bool needs_update = false;

		protected override void __FieldInit() {
			base.__FieldInit();

			this.invisibility = 20;
			this.blend_mode = 4;
			this.color = "#000000";
			this.anchored = 1;
			this.ignoreinvert = 1;
			this.icon = "icons/effects/lighting_overlay.dmi";
			this.icon_state = "light1";
			this.layer = 10;
		}

		// Function from file: lighting_overlay.dm
		public Dynamic_LightingOverlay ( dynamic loc = null ) : base( (object)(loc) ) {
			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;
			this.verbs.Cut();
			this.alpha = 255 - Num13.Floor( 12.75 );
			return;
		}

		// Function from file: lighting_overlay.dm
		public override bool forceMove( dynamic destination = null, int? no_tp = null ) {
			no_tp = no_tp ?? 0;

			bool _default = false;

			
			if ( Lang13.Bool( no_tp ) ) {
				_default = base.forceMove( (object)(destination), no_tp );
			}
			return _default;
		}

		// Function from file: lighting_overlay.dm
		public override bool can_shuttle_move( Shuttle S = null ) {
			return false;
		}

		// Function from file: lighting_overlay.dm
		public override bool shuttle_act( Shuttle S = null ) {
			return false;
		}

		// Function from file: lighting_overlay.dm
		public override bool ex_act( double? severity = null, dynamic child = null ) {
			return false;
		}

		// Function from file: lighting_overlay.dm
		public override bool singuloCanEat(  ) {
			return false;
		}

		// Function from file: lighting_overlay.dm
		public override dynamic Destroy( dynamic brokenup = null ) {
			Ent_Static T = null;

			GlobalVars.all_lighting_overlays.Remove( this );
			GlobalVars.lighting_update_overlays.Remove( this );
			T = this.loc;

			if ( T is Tile ) {
				((dynamic)T).lighting_overlay = null;
			}
			base.Destroy( (object)(brokenup) );
			return null;
		}

		// Function from file: lighting_overlay.dm
		public override dynamic resetVariables( string args = null, params object[] _ ) {
			ByTable _args = new ByTable( new object[] { args } ).Extend(_);

			this.loc = null;
			this.lum_r = 0;
			this.lum_g = 0;
			this.lum_b = 0;
			this.color = "#000000";
			this.invisibility = 20;
			this.needs_update = false;
			return null;
		}

		// Function from file: lighting_overlay.dm
		public double update_overlay(  ) {
			double _default = 0;

			double mx = 0;
			Ent_Static T = null;

			mx = Num13.MaxInt( ((int)( this.lum_r )), ((int)( this.lum_g )), ((int)( this.lum_b )) );
			_default = 1;

			if ( mx > 1 ) {
				_default = 1 / mx;
			} else if ( mx < 0.05 && mx > 0.0078125 ) {
				_default = 0.05 / mx;
			}
			this.color = String13.ColorCode( ((int)( this.lum_r * _default * 255 )), ((int)( this.lum_g * _default * 255 )), ((int)( this.lum_b * _default * 255 )) );

			if ( mx <= 0.05 ) {
				this.alpha = 255 - Num13.Floor( 12.75 );
			} else {
				this.alpha = 255;
			}
			T = this.loc;

			if ( T is Tile ) {
				
				if ( Num13.MaxInt( ((int)( this.lum_r )), ((int)( this.lum_g )), ((int)( this.lum_b )) ) > 0.05 ) {
					this.luminosity = 1;
				} else {
					this.luminosity = 0;
				}
				((UniversalState)GlobalVars.universe).OnTurfTick( T );
			} else {
				
				if ( this.loc != null ) {
					Game13.log.WriteMsg( "## WARNING: " + ( "A lighting overlay realised its loc was NOT a turf (actual loc: " + this.loc + ", " + this.loc.type + ") in update_overlay() and got pooled!" ) );
				} else {
					Game13.log.WriteMsg( "## WARNING: " + "A lighting overlay realised it was in nullspace in update_overlay() and got pooled!" );
				}
				GlobalFuncs.returnToPool( this );
			}
			return _default;
		}

		// Function from file: lighting_overlay.dm
		public void update_lumcount( double delta_r = 0, double delta_g = 0, double delta_b = 0 ) {
			bool should_update = false;
			int mx1 = 0;
			int mx2 = 0;

			
			if ( !( delta_r != 0 ) && !( delta_g != 0 ) && !( delta_b != 0 ) ) {
				return;
			}
			should_update = false;

			if ( !this.needs_update ) {
				
				if ( Num13.MaxInt( ((int)( this.lum_r )), ((int)( this.lum_g )), ((int)( this.lum_b )) ) < 1 ) {
					should_update = true;
				} else if ( Num13.MaxInt( ((int)( this.lum_r + delta_r )), ((int)( this.lum_g + delta_g )), ((int)( this.lum_b + delta_b )) ) < 1 ) {
					should_update = true;
				} else {
					mx1 = Num13.MaxInt( ((int)( this.lum_r )), ((int)( this.lum_g )), ((int)( this.lum_b )) );
					mx2 = Num13.MaxInt( ((int)( this.lum_r + delta_r )), ((int)( this.lum_g + delta_g )), ((int)( this.lum_b + delta_b )) );

					if ( this.lum_r / mx1 != ( this.lum_r + delta_r ) / mx2 || this.lum_g / mx1 != ( this.lum_g + delta_g ) / mx2 || this.lum_b / mx1 != ( this.lum_b + delta_b ) / mx2 ) {
						should_update = true;
					}
				}
			}
			this.lum_r += delta_r;
			this.lum_g += delta_g;
			this.lum_b += delta_b;

			if ( !this.needs_update && should_update ) {
				this.needs_update = true;
				GlobalVars.lighting_update_overlays.Or( this );
			}
			return;
		}

	}

}