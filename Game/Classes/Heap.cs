// FILE AUTOGENERATED BY SOM13. DO NOT EDIT YET.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Heap : Game_Data {

		public ByTable L = null;
		public System.Reflection.MethodInfo cmp = null;

		// Function from file: heap.dm
		public Heap ( System.Reflection.MethodInfo compare = null ) {
			this.L = new ByTable();
			this.cmp = compare;
			return;
		}

		// Function from file: heap.dm
		public ByTable List(  ) {
			ByTable _default = null;

			_default = this.L.Copy();
			return _default;
		}

		// Function from file: heap.dm
		public void ReSort( PathNode A = null ) {
			int index = 0;

			index = this.L.Find( A );
			this.Swim( index );
			this.Sink( index );
			return;
		}

		// Function from file: heap.dm
		public int GetGreaterChild( int index = 0 ) {
			
			if ( index * 2 > this.L.len ) {
				return 0;
			}

			if ( index * 2 + 1 > this.L.len ) {
				return index * 2;
			}

			if ( Convert.ToDouble( Lang13.Call( this.cmp, this.L[index * 2], this.L[index * 2 + 1] ) ) < 0 ) {
				return index * 2 + 1;
			} else {
				return index * 2;
			}
		}

		// Function from file: heap.dm
		public void Sink( int index = 0 ) {
			int g_child = 0;

			g_child = this.GetGreaterChild( index );

			while (g_child > 0 && Convert.ToDouble( Lang13.Call( this.cmp, this.L[index], this.L[g_child] ) ) < 0) {
				this.L.Swap( index, g_child );
				index = g_child;
				g_child = this.GetGreaterChild( index );
			}
			return;
		}

		// Function from file: heap.dm
		public void Swim( int index = 0 ) {
			int parent = 0;

			parent = Num13.Floor( index * 0.5 );

			while (parent > 0 && Convert.ToDouble( Lang13.Call( this.cmp, this.L[index], this.L[parent] ) ) > 0) {
				this.L.Swap( index, parent );
				index = parent;
				parent = Num13.Floor( index * 0.5 );
			}
			return;
		}

		// Function from file: heap.dm
		public bool Pop(  ) {
			bool _default = false;

			
			if ( !( this.L.len != 0 ) ) {
				return false;
			}
			_default = Lang13.Bool( this.L[1] );
			this.L[1] = this.L[this.L.len];
			this.L.Cut( this.L.len );
			this.Sink( 1 );
			return _default;
		}

		// Function from file: heap.dm
		public void Insert( PathNode A = null ) {
			this.L.Add( A );
			this.Swim( this.L.len );
			return;
		}

		// Function from file: heap.dm
		public bool IsEmpty(  ) {
			return !( this.L.len != 0 );
		}

	}

}