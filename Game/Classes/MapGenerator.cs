// FILE AUTOGENERATED BY SOM13. DO NOT EDIT YET.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class MapGenerator : Game_Data {

		public ByTable map = new ByTable();
		public ByTable modules = new ByTable();

		// Function from file: mapGenerator.dm
		public MapGenerator (  ) {
			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;
			this.initialiseModules();
			return;
		}

		// Function from file: mapGenerator.dm
		public void syncModules(  ) {
			MapGeneratorModule mod = null;

			
			foreach (dynamic _a in Lang13.Enumerate( this.modules, typeof(MapGeneratorModule) )) {
				mod = _a;
				
				mod.sync( this );
			}
			return;
		}

		// Function from file: mapGenerator.dm
		public void initialiseModules(  ) {
			dynamic path = null;

			
			foreach (dynamic _a in Lang13.Enumerate( this.modules )) {
				path = _a;
				

				if ( path is Type ) {
					this.modules.Remove( path );
					this.modules.Or( Lang13.Call( path ) );
				}
			}
			this.syncModules();
			return;
		}

		// Function from file: mapGenerator.dm
		public void generateOneTurf( dynamic T = null ) {
			MapGeneratorModule mod = null;

			
			if ( !Lang13.Bool( T ) ) {
				return;
			}
			this.syncModules();

			if ( !( this.modules != null ) || !( this.modules.len != 0 ) ) {
				return;
			}

			foreach (dynamic _a in Lang13.Enumerate( this.modules, typeof(MapGeneratorModule) )) {
				mod = _a;
				
				Task13.Schedule( 0, (Task13.Closure)(() => {
					mod.place( T );
					return;
				}));
			}
			return;
		}

		// Function from file: mapGenerator.dm
		public virtual void generate(  ) {
			MapGeneratorModule mod = null;

			this.syncModules();

			if ( !( this.modules != null ) || !( this.modules.len != 0 ) ) {
				return;
			}

			foreach (dynamic _a in Lang13.Enumerate( this.modules, typeof(MapGeneratorModule) )) {
				mod = _a;
				
				Task13.Schedule( 0, (Task13.Closure)(() => {
					mod.generate();
					return;
				}));
			}
			return;
		}

		// Function from file: mapGenerator.dm
		public bool checkRegion( dynamic Start = null, dynamic End = null ) {
			bool _default = false;

			_default = true;

			if ( !Lang13.Bool( Start ) || !Lang13.Bool( End ) ) {
				return false;
			}

			if ( Convert.ToDouble( Start.x ) > Game13.map_size_x || Convert.ToDouble( End.x ) > Game13.map_size_x ) {
				_default = false;
			}

			if ( Convert.ToDouble( Start.y ) > Game13.map_size_y || Convert.ToDouble( End.y ) > Game13.map_size_y ) {
				_default = false;
			}

			if ( Convert.ToDouble( Start.z ) > Game13.map_size_z || Convert.ToDouble( End.z ) > Game13.map_size_z ) {
				_default = false;
			}
			return _default;
		}

		// Function from file: mapGenerator.dm
		public void undefineRegion(  ) {
			this.map = new ByTable();
			return;
		}

		// Function from file: mapGenerator.dm
		public dynamic defineCircularRegion( Ent_Static Start = null, Ent_Static End = null, bool? replace = null ) {
			replace = replace ?? false;

			int centerX = 0;
			int centerY = 0;
			int lilZ = 0;
			int bigZ = 0;
			int? sphereMagic = null;
			double radius = 0;
			bool offByOneOffset = false;
			int? i = null;
			double? theRadius = null;

			
			if ( !this.checkRegion( Start, End ) ) {
				return 0;
			}
			centerX = Num13.MaxInt( ((int)( Math.Abs( ( End.x + Start.x ) / 2 ) )), 1 );
			centerY = Num13.MaxInt( ((int)( Math.Abs( ( End.y + Start.y ) / 2 ) )), 1 );
			lilZ = Num13.MinInt( Start.z, End.z );
			bigZ = Num13.MaxInt( Start.z, End.z );
			sphereMagic = Num13.MaxInt( ((int)( Math.Abs( bigZ - lilZ / 2 ) )), 1 );
			radius = Math.Abs( Num13.MaxInt( centerX, centerY ) );

			if ( replace == true ) {
				this.undefineRegion();
			}
			offByOneOffset = true;

			if ( bigZ % 2 == 0 ) {
				offByOneOffset = false;
			}
			i = null;
			i = lilZ;

			while (( i ??0) <= bigZ + ( offByOneOffset ?1:0)) {
				theRadius = radius;

				if ( i != sphereMagic ) {
					theRadius = Num13.MaxInt( ((int)( radius / Num13.MaxInt( ((int)( Math.Abs( ( sphereMagic ??0) - ( i ??0) ) * 2 )), 1 ) )), 1 );
				}
				this.map.Or( GlobalFuncs.circlerange( Map13.GetTile( centerX, centerY, i ??0 ), theRadius ) );
				i++;
			}
			return this.map;
		}

		// Function from file: mapGenerator.dm
		public virtual dynamic defineRegion( dynamic Start = null, dynamic End = null, bool? replace = null ) {
			replace = replace ?? false;

			
			if ( !this.checkRegion( Start, End ) ) {
				return 0;
			}

			if ( replace == true ) {
				this.undefineRegion();
			}
			this.map.Or( Map13.FetchInBlock( Start, End ) );
			return this.map;
		}

	}

}