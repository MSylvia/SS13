// FILE AUTOGENERATED BY SOM13. DO NOT EDIT YET.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class LinkedList : Game_Data {

		public LinkedNode head = null;
		public LinkedNode tail = null;
		public int node_amt = 0;

		// Function from file: linked_lists.dm
		public ByTable ToList(  ) {
			ByTable _default = null;

			LinkedNode n = null;

			_default = new ByTable();
			n = this.head;

			while (n != null) {
				_default.Add( n );
				n = n.next_node;
			}
			return _default;
		}

		// Function from file: linked_lists.dm
		public string DrawNodeLinks(  ) {
			string _default = null;

			LinkedNode n = null;

			_default = "|<-";
			n = this.head;

			while (n != null) {
				
				if ( n.previous_node != null ) {
					_default += "<-";
				}
				_default += "" + n.value;

				if ( n.next_node != null ) {
					_default += "->";
				}
				n = n.next_node;
			}
			_default += "->|";
			return _default;
		}

		// Function from file: linked_lists.dm
		public string CheckNodeLinks(  ) {
			string _default = null;

			LinkedNode n = null;

			n = this.head;

			while (n != null) {
				_default = "|" + n.value + "|";

				if ( n.previous_node != null ) {
					_default = "" + n.previous_node.value + "<-" + _default;
				}

				if ( n.next_node != null ) {
					_default += "->" + n.next_node.value;
				}
				n = n.next_node;
				_default += "<BR>";
			}
			return _default;
		}

		// Function from file: linked_lists.dm
		public void Empty(  ) {
			LinkedNode n = null;
			LinkedNode next = null;

			n = this.head;

			while (n != null) {
				next = n.next_node;
				this.Remove( n );
				GlobalFuncs.qdel( n );
				n = next;
			}
			this.node_amt = 0;
			return;
		}

		// Function from file: linked_lists.dm
		public bool RemoveDelete( LinkedNode node = null ) {
			dynamic dead = null;

			dead = this.Remove( node );

			if ( Lang13.Bool( dead ) ) {
				GlobalFuncs.qdel( dead );
				return true;
			}
			return false;
		}

		// Function from file: linked_lists.dm
		public dynamic Remove( LinkedNode node = null ) {
			LinkedNode removing = null;
			int location = 0;
			LinkedNode current_value = null;
			LinkedNode at = null;

			
			if ( node is LinkedNode ) {
				removing = node;
			} else if ( removing == this.head ) {
				removing = this.head;
			} else if ( removing == this.tail ) {
				removing = this.tail;
			} else {
				location = 1;
				current_value = null;
				at = null;

				while (current_value != node && location <= this.node_amt) {
					
					if ( at != null ) {
						
						if ( at.next_node != null ) {
							at = at.next_node;
						}
					} else {
						at = this.head;
					}
					location++;

					if ( at != null ) {
						current_value = at.value;

						if ( current_value == node ) {
							removing = at;
							break;
						}
					}
				}
			}

			if ( removing != null ) {
				
				if ( removing.previous_node != null ) {
					
					if ( removing == this.tail ) {
						this.tail = removing.previous_node;
					}

					if ( removing.next_node != null ) {
						
						if ( removing == this.head ) {
							this.head = removing.next_node;
						}
						removing.next_node.previous_node = removing.previous_node;
						removing.previous_node.next_node = removing.next_node;
					} else {
						removing.previous_node.next_node = null;
					}
				} else if ( removing.next_node != null ) {
					
					if ( removing == this.head ) {
						this.head = removing.next_node;
					}
					removing.next_node.previous_node = null;
				}

				if ( removing == this.head ) {
					this.head = null;
				}

				if ( removing == this.tail ) {
					this.tail = null;
				}
				removing.next_node = null;
				removing.previous_node = null;

				if ( removing.linked_list == this ) {
					this.node_amt--;
				}
				removing.linked_list = null;
				return removing;
			}
			return 0;
		}

		// Function from file: linked_lists.dm
		public void Add( dynamic node = null, int position = 0 ) {
			LinkedNode adding = null;
			int location = 0;
			LinkedNode at = null;

			
			if ( node is LinkedNode ) {
				adding = node;
			} else {
				adding = new LinkedNode();
				adding.value = node;
			}

			if ( !( adding.linked_list != null ) || adding.linked_list != null && adding.linked_list != this ) {
				this.node_amt++;
			}
			adding.linked_list = this;

			if ( position != 0 && position < this.node_amt ) {
				
				if ( position == 1 ) {
					
					if ( this.head != null ) {
						this.head.previous_node = adding;
						adding.next_node = this.head;
					}
					this.head = adding;
				} else {
					location = 0;

					while (location != position && location <= this.node_amt) {
						
						if ( at != null ) {
							
							if ( at.next_node != null ) {
								at = at.next_node;
							} else {
								break;
							}
						} else {
							at = this.head;
						}
						location++;
					}

					if ( at != null && at.previous_node != null ) {
						at.previous_node.next_node = adding;
						adding.previous_node = at.previous_node;
						at.previous_node = adding;
						adding.next_node = at;
					}
				}
				return;
			}

			if ( this.tail != null ) {
				this.tail.next_node = adding;
				adding.previous_node = this.tail;

				if ( !( this.tail.previous_node != null ) ) {
					this.head = this.tail;
				}
			}
			this.tail = adding;
			return;
		}

		// Function from file: linked_lists.dm
		public bool IsEmpty(  ) {
			bool _default = false;

			_default = this.node_amt <= 0;
			return _default;
		}

	}

}