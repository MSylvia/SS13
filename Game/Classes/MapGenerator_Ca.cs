// FILE AUTOGENERATED BY SOM13. DO NOT EDIT YET.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class MapGenerator_Ca : MapGenerator {

		public ByTable b_rule = new ByTable();
		public ByTable s_rule = new ByTable();
		public int? iterations = 1;
		public bool loop_edges = false;
		public bool edge_value = true;
		public dynamic old_state = null;
		public dynamic current_state = null;
		public int? width = 10;
		public int? height = 10;
		public ByTable type_map = new ByTable(new object [] { typeof(Tile_Simulated_Floor_Plating), typeof(Tile_Simulated_Wall) });
		public Tile start = null;

		// Function from file: cellular.dm
		public override void generate(  ) {
			int? generation = null;
			int? i = null;
			int? j = null;
			int? i2 = null;
			int? j2 = null;
			Tile T = null;

			this.initialize();
			generation = null;
			generation = 0;

			while (( generation ??0) < ( this.iterations ??0)) {
				i = null;
				i = 1;

				while (( i ??0) <= ( this.width ??0)) {
					j = null;
					j = 1;

					while (( j ??0) <= ( this.height ??0)) {
						this.current_state[i][j] = this.apply_rule( i, j );
						j++;
					}
					i++;
				}
				this.old_state = this.current_state.Copy();
				generation++;
			}
			i2 = null;
			i2 = 1;

			while (( i2 ??0) <= ( this.width ??0)) {
				j2 = null;
				j2 = 1;

				while (( j2 ??0) <= ( this.height ??0)) {
					T = Map13.GetTile( this.start.x + ( i2 ??0) - 1, this.start.y + ( j2 ??0) - 1, this.start.z );

					if ( T != null ) {
						T.ChangeTurf( this.type_map[this.current_state[i2][j2] + 1] );
					}
					j2++;
				}
				i2++;
			}
			return;
		}

		// Function from file: cellular.dm
		public bool apply_rule( int? i = null, int? j = null ) {
			double value = 0;
			int? dx = null;
			int? dy = null;
			int? n_x = null;
			int? n_y = null;

			value = 0;
			dx = null;
			dx = -1;

			while (( dx ??0) <= 1) {
				dy = null;
				dy = -1;

				while (( dy ??0) <= 1) {
					n_x = ( i ??0) + ( dx ??0);
					n_y = ( j ??0) + ( dy ??0);

					if ( ( n_x ??0) < 1 || ( n_x ??0) > ( this.width ??0) || ( n_y ??0) < 1 || ( n_y ??0) > ( this.height ??0) ) {
						
						if ( this.loop_edges ) {
							
							if ( ( n_x ??0) < 1 ) {
								n_x = this.width;
							} else if ( ( n_x ??0) > ( this.width ??0) ) {
								n_x = 1;
							}

							if ( ( n_y ??0) < 1 ) {
								n_y = this.height;
							} else if ( ( n_y ??0) > ( this.height ??0) ) {
								n_y = 1;
							}
						} else {
							value += this.edge_value ?1:0;
							dy++;
							continue;
						}
					}
					value += Convert.ToDouble( this.old_state[n_x][n_y] );
					dy++;
				}
				dx++;
			}
			value -= Convert.ToDouble( this.old_state[i][j] );

			if ( this.b_rule.Contains( value ) ) {
				return true;
			}

			if ( this.s_rule.Contains( value ) ) {
				return Lang13.Bool( this.old_state[i][j] );
			}
			return false;
		}

		// Function from file: cellular.dm
		public void initialize(  ) {
			int? i = null;
			int? j = null;

			this.old_state = new ByTable( this.width );
			i = null;
			i = 1;

			while (( i ??0) <= ( this.width ??0)) {
				this.old_state[i] = new ByTable( this.height );
				j = null;
				j = 1;

				while (( j ??0) <= ( this.height ??0)) {
					this.old_state[i][j] = Rand13.Int( 0, 1 );
					j++;
				}
				i++;
			}
			this.current_state = this.old_state.Copy();
			return;
		}

		// Function from file: cellular.dm
		public override dynamic defineRegion( dynamic Start = null, dynamic End = null, bool? replace = null ) {
			replace = replace ?? false;

			dynamic _default = null;

			int min_x = 0;
			int max_x = 0;
			int min_y = 0;
			int max_y = 0;

			_default = base.defineRegion( (object)(Start), (object)(End), replace );
			min_x = Num13.MinInt( Convert.ToInt32( Start.x ), Convert.ToInt32( End.x ) );
			max_x = Num13.MaxInt( Convert.ToInt32( Start.x ), Convert.ToInt32( End.x ) );
			min_y = Num13.MinInt( Convert.ToInt32( Start.y ), Convert.ToInt32( End.y ) );
			max_y = Num13.MaxInt( Convert.ToInt32( Start.y ), Convert.ToInt32( End.y ) );
			this.width = max_x - min_x;
			this.height = max_y - min_y;
			this.start = Map13.GetTile( min_x, min_y, Convert.ToInt32( Start.z ) );
			return _default;
		}

	}

}