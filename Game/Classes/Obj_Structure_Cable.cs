// FILE AUTOGENERATED BY SOM13. DO NOT EDIT YET.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Obj_Structure_Cable : Obj_Structure {

		public Powernet powernet = null;
		public double? d1 = 0;
		public double? d2 = 1;
		public dynamic cable_color = "red";
		public Obj_Item_Stack_CableCoil stored = null;

		protected override void __FieldInit() {
			base.__FieldInit();

			this.level = 1;
			this.anchored = 1;
			this.icon = "icons/obj/power_cond/power_cond_red.dmi";
			this.icon_state = "0-1";
			this.layer = 2.44;
		}

		// Function from file: cable.dm
		public Obj_Structure_Cable ( dynamic loc = null ) : base( (object)(loc) ) {
			int dash = 0;
			Ent_Static T = null;

			// Warning: Super call was HERE! If anything above HERE is needed by the super call, it might break!;
			dash = String13.FindIgnoreCase( this.icon_state, "-", 1, 0 );
			this.d1 = String13.ParseNumber( String13.SubStr( this.icon_state, 1, dash ) );
			this.d2 = String13.ParseNumber( String13.SubStr( this.icon_state, dash + 1, 0 ) );
			T = this.loc;

			if ( this.level == 1 ) {
				this.hide( Lang13.Bool( ((dynamic)T).intact ) );
			}
			GlobalVars.cable_list.Add( this );

			if ( Lang13.Bool( this.d1 ) ) {
				this.stored = new Obj_Item_Stack_CableCoil( null, 2, this.cable_color );
			} else {
				this.stored = new Obj_Item_Stack_CableCoil( null, 1, this.cable_color );
			}
			return;
		}

		// Function from file: cable.dm
		public override void singularity_pull( Obj_Singularity S = null, int? current_size = null ) {
			
			if ( ( current_size ??0) >= 9 ) {
				this.Deconstruct();
			}
			return;
		}

		// Function from file: cable.dm
		public override bool ex_act( double? severity = null, dynamic target = null ) {
			base.ex_act( severity, (object)(target) );

			if ( !Lang13.Bool( this.gc_destroyed ) ) {
				
				switch ((double?)( severity )) {
					case 2:
						
						if ( Rand13.PercentChance( 50 ) ) {
							this.Deconstruct();
						}
						break;
					case 3:
						
						if ( Rand13.PercentChance( 25 ) ) {
							this.Deconstruct();
						}
						break;
				}
			}
			return false;
		}

		// Function from file: cable.dm
		public override dynamic attackby( dynamic A = null, dynamic user = null, string _params = null, bool? silent = null, bool? replace_spent = null ) {
			Ent_Static T = null;
			dynamic coil = null;

			T = this.loc;

			if ( Lang13.Bool( ((dynamic)T).intact ) ) {
				return null;
			}

			if ( A is Obj_Item_Weapon_Wirecutters ) {
				
				if ( this.shock( user, 50 ) ) {
					return null;
				}
				((Ent_Static)user).visible_message( "" + user + " cuts the cable.", "<span class='notice'>You cut the cable.</span>" );
				this.stored.add_fingerprint( user );
				this.investigate_log( "was cut by " + GlobalFuncs.key_name( Task13.User, Task13.User.client ) + " in " + user.loc.loc, "wires" );
				this.Deconstruct();
				return null;
			} else if ( A is Obj_Item_Stack_CableCoil ) {
				coil = A;

				if ( ( ((Obj_Item_Stack)coil).get_amount() ??0) < 1 ) {
					user.WriteMsg( "<span class='warning'>Not enough cable!</span>" );
					return null;
				}
				((Obj_Item_Stack_CableCoil)coil).cable_join( this, user );
			} else if ( A is Obj_Item_Device_Multitool ) {
				
				if ( this.powernet != null && this.powernet.avail > 0 ) {
					user.WriteMsg( "<span class='danger'>" + this.powernet.avail + "W in power network.</span>" );
				} else {
					user.WriteMsg( "<span class='danger'>The cable is not powered.</span>" );
				}
				this.shock( user, 5, 0.2 );
			} else if ( Lang13.Bool( A.flags & 64 ) ) {
				this.shock( user, 50, 061 );
			}
			this.add_fingerprint( user );
			return null;
		}

		// Function from file: cable.dm
		public override void attack_tk( Mob_Living_Carbon_Human user = null ) {
			return;
		}

		// Function from file: cable.dm
		public void cut_cable_from_powernet(  ) {
			Ent_Static T1 = null;
			ByTable P_list = null;
			Obj_Machinery_Power P = null;
			Obj_Structure_Cable O = null;
			Powernet newPN = null;
			Obj_Machinery_Power P2 = null;

			T1 = this.loc;

			if ( !( T1 != null ) ) {
				return;
			}

			if ( Lang13.Bool( this.d1 ) ) {
				T1 = Map13.GetStep( T1, ((int)( this.d1 ??0 )) );
				P_list = GlobalFuncs.power_list( T1, this, Num13.Rotate( this.d1, 180 ), false, true );
			}
			P_list.Add( GlobalFuncs.power_list( this.loc, this, this.d1, false, true ) );

			if ( P_list.len == 0 ) {
				this.powernet.remove_cable( this );

				foreach (dynamic _a in Lang13.Enumerate( T1, typeof(Obj_Machinery_Power) )) {
					P = _a;
					

					if ( !P.connect_to_network() ) {
						P.disconnect_from_network();
					}
				}
				return;
			}
			O = P_list[1];
			this.loc = null;
			this.powernet.remove_cable( this );
			Task13.Schedule( 0, (Task13.Closure)(() => {
				
				if ( O != null && !GlobalFuncs.qdeleted( O ) ) {
					newPN = new Powernet();
					GlobalFuncs.propagate_network( O, newPN );
				}
				return;
			}));

			if ( this.d1 == 0 ) {
				
				foreach (dynamic _b in Lang13.Enumerate( T1, typeof(Obj_Machinery_Power) )) {
					P2 = _b;
					

					if ( !P2.connect_to_network() ) {
						P2.disconnect_from_network();
					}
				}
			}
			return;
		}

		// Function from file: cable.dm
		public void denode(  ) {
			Ent_Static T1 = null;
			ByTable powerlist = null;
			Powernet PN = null;

			T1 = this.loc;

			if ( !( T1 != null ) ) {
				return;
			}
			powerlist = GlobalFuncs.power_list( T1, this, 0, false );

			if ( powerlist.len > 0 ) {
				PN = new Powernet();
				GlobalFuncs.propagate_network( powerlist[1], PN );

				if ( PN.is_empty() ) {
					GlobalFuncs.qdel( PN );
				}
			}
			return;
		}

		// Function from file: cable.dm
		public ByTable get_connections( bool? powernetless_only = null ) {
			powernetless_only = powernetless_only ?? false;

			ByTable _default = null;

			Tile T = null;

			_default = new ByTable();

			if ( Lang13.Bool( this.d1 ) ) {
				T = Map13.GetStep( this, ((int)( this.d1 ??0 )) );

				if ( T != null ) {
					_default.Add( GlobalFuncs.power_list( T, this, Num13.Rotate( this.d1, 180 ), powernetless_only ) );
				}
			}

			if ( ( ((int)( this.d1 ??0 )) & ((int)( ( this.d1 ??0) - 1 )) ) != 0 ) {
				T = Map13.GetStep( this, ((int)( this.d1 ??0 )) & 3 );

				if ( T != null ) {
					_default.Add( GlobalFuncs.power_list( T, this, ((int)( this.d1 ??0 )) ^ 3, powernetless_only ) );
				}
				T = Map13.GetStep( this, ((int)( this.d1 ??0 )) & 12 );

				if ( T != null ) {
					_default.Add( GlobalFuncs.power_list( T, this, ((int)( this.d1 ??0 )) ^ 12, powernetless_only ) );
				}
			}
			_default.Add( GlobalFuncs.power_list( this.loc, this, this.d1, powernetless_only ) );
			T = Map13.GetStep( this, ((int)( this.d2 ??0 )) );

			if ( T != null ) {
				_default.Add( GlobalFuncs.power_list( T, this, Num13.Rotate( this.d2, 180 ), powernetless_only ) );
			}

			if ( ( ((int)( this.d2 ??0 )) & ((int)( ( this.d2 ??0) - 1 )) ) != 0 ) {
				T = Map13.GetStep( this, ((int)( this.d2 ??0 )) & 3 );

				if ( T != null ) {
					_default.Add( GlobalFuncs.power_list( T, this, ((int)( this.d2 ??0 )) ^ 3, powernetless_only ) );
				}
				T = Map13.GetStep( this, ((int)( this.d2 ??0 )) & 12 );

				if ( T != null ) {
					_default.Add( GlobalFuncs.power_list( T, this, ((int)( this.d2 ??0 )) ^ 12, powernetless_only ) );
				}
			}
			_default.Add( GlobalFuncs.power_list( this.loc, this, this.d2, powernetless_only ) );
			return _default;
		}

		// Function from file: cable.dm
		public void mergeConnectedNetworksOnTurf(  ) {
			ByTable to_connect = null;
			Powernet newPN = null;
			dynamic AM = null;
			dynamic C = null;
			dynamic N = null;
			dynamic M = null;
			Obj_Machinery_Power PM = null;

			to_connect = new ByTable();

			if ( !( this.powernet != null ) ) {
				newPN = new Powernet();
				newPN.add_cable( this );
			}

			foreach (dynamic _a in Lang13.Enumerate( this.loc )) {
				AM = _a;
				

				if ( AM is Obj_Structure_Cable ) {
					C = AM;

					if ( C.d1 == this.d1 || C.d2 == this.d1 || C.d1 == this.d2 || C.d2 == this.d2 ) {
						
						if ( C.powernet == this.powernet ) {
							continue;
						}

						if ( Lang13.Bool( C.powernet ) ) {
							GlobalFuncs.merge_powernets( this.powernet, C.powernet );
						} else {
							this.powernet.add_cable( C );
						}
					}
				} else if ( AM is Obj_Machinery_Power_Apc ) {
					N = AM;

					if ( !Lang13.Bool( N.terminal ) ) {
						continue;
					}

					if ( N.terminal.powernet == this.powernet ) {
						continue;
					}
					to_connect.Add( N.terminal );
				} else if ( AM is Obj_Machinery_Power ) {
					M = AM;

					if ( M.powernet == this.powernet ) {
						continue;
					}
					to_connect.Add( M );
				}
			}

			foreach (dynamic _b in Lang13.Enumerate( to_connect, typeof(Obj_Machinery_Power) )) {
				PM = _b;
				

				if ( !PM.connect_to_network() ) {
					PM.disconnect_from_network();
				}
			}
			return;
		}

		// Function from file: cable.dm
		public void mergeConnectedNetworks( double? direction = null ) {
			double? fdir = null;
			Tile TB = null;
			Obj_Structure_Cable C = null;
			Powernet newPN = null;

			fdir = ( !Lang13.Bool( direction ) ? 0 : Num13.Rotate( direction, 180 ) );

			if ( !( this.d1 == direction || this.d2 == direction ) ) {
				return;
			}
			TB = Map13.GetStep( this, ((int)( direction ??0 )) );

			foreach (dynamic _a in Lang13.Enumerate( TB, typeof(Obj_Structure_Cable) )) {
				C = _a;
				

				if ( !( C != null ) ) {
					continue;
				}

				if ( this == C ) {
					continue;
				}

				if ( C.d1 == fdir || C.d2 == fdir ) {
					
					if ( !( C.powernet != null ) ) {
						newPN = new Powernet();
						newPN.add_cable( C );
					}

					if ( this.powernet != null ) {
						GlobalFuncs.merge_powernets( this.powernet, C.powernet );
					} else {
						C.powernet.add_cable( this );
					}
				}
			}
			return;
		}

		// Function from file: cable.dm
		public void mergeDiagonalsNetworks( double? direction = null ) {
			Tile T = null;
			Obj_Structure_Cable C = null;
			Powernet newPN = null;
			Obj_Structure_Cable C2 = null;
			Powernet newPN2 = null;

			T = Map13.GetStep( this, ((int)( direction ??0 )) & 3 );

			foreach (dynamic _a in Lang13.Enumerate( T, typeof(Obj_Structure_Cable) )) {
				C = _a;
				

				if ( !( C != null ) ) {
					continue;
				}

				if ( this == C ) {
					continue;
				}

				if ( C.d1 == ( ((int)( direction ??0 )) ^ 3 ) || C.d2 == ( ((int)( direction ??0 )) ^ 3 ) ) {
					
					if ( !( C.powernet != null ) ) {
						newPN = new Powernet();
						newPN.add_cable( C );
					}

					if ( this.powernet != null ) {
						GlobalFuncs.merge_powernets( this.powernet, C.powernet );
					} else {
						C.powernet.add_cable( this );
					}
				}
			}
			T = Map13.GetStep( this, ((int)( direction ??0 )) & 12 );

			foreach (dynamic _b in Lang13.Enumerate( T, typeof(Obj_Structure_Cable) )) {
				C2 = _b;
				

				if ( !( C2 != null ) ) {
					continue;
				}

				if ( this == C2 ) {
					continue;
				}

				if ( C2.d1 == ( ((int)( direction ??0 )) ^ 12 ) || C2.d2 == ( ((int)( direction ??0 )) ^ 12 ) ) {
					
					if ( !( C2.powernet != null ) ) {
						newPN2 = new Powernet();
						newPN2.add_cable( C2 );
					}

					if ( this.powernet != null ) {
						GlobalFuncs.merge_powernets( this.powernet, C2.powernet );
					} else {
						C2.powernet.add_cable( this );
					}
				}
			}
			return;
		}

		// Function from file: cable.dm
		public double avail(  ) {
			
			if ( this.powernet != null ) {
				return this.powernet.avail;
			} else {
				return 0;
			}
		}

		// Function from file: cable.dm
		public double surplus(  ) {
			
			if ( this.powernet != null ) {
				return this.powernet.avail - this.powernet.load;
			} else {
				return 0;
			}
		}

		// Function from file: cable.dm
		public void add_load( dynamic amount = null ) {
			
			if ( this.powernet != null ) {
				this.powernet.load += Convert.ToDouble( amount );
			}
			return;
		}

		// Function from file: cable.dm
		public void add_avail( dynamic amount = null ) {
			
			if ( this.powernet != null ) {
				this.powernet.newavail += Convert.ToDouble( amount );
			}
			return;
		}

		// Function from file: cable.dm
		public void update_stored( int? length = null, dynamic color = null ) {
			length = length ?? 1;
			color = color ?? "red";

			this.stored.amount = length;
			this.stored.item_color = color;
			this.stored.update_icon();
			return;
		}

		// Function from file: cable.dm
		public void cableColor( dynamic colorC = null ) {
			colorC = colorC ?? "red";

			this.cable_color = colorC;

			dynamic _a = colorC; // Was a switch-case, sorry for the mess.
			if ( _a=="red" ) {
				this.icon = "icons/obj/power_cond/power_cond_red.dmi";
			} else if ( _a=="yellow" ) {
				this.icon = "icons/obj/power_cond/power_cond_yellow.dmi";
			} else if ( _a=="green" ) {
				this.icon = "icons/obj/power_cond/power_cond_green.dmi";
			} else if ( _a=="blue" ) {
				this.icon = "icons/obj/power_cond/power_cond_blue.dmi";
			} else if ( _a=="pink" ) {
				this.icon = "icons/obj/power_cond/power_cond_pink.dmi";
			} else if ( _a=="orange" ) {
				this.icon = "icons/obj/power_cond/power_cond_orange.dmi";
			} else if ( _a=="cyan" ) {
				this.icon = "icons/obj/power_cond/power_cond_cyan.dmi";
			} else if ( _a=="white" ) {
				this.icon = "icons/obj/power_cond/power_cond_white.dmi";
			}
			return;
		}

		// Function from file: cable.dm
		public bool shock( dynamic user = null, int prb = 0, double? siemens_coeff = null ) {
			siemens_coeff = siemens_coeff ?? 1;

			EffectSystem_SparkSpread s = null;

			
			if ( !Rand13.PercentChance( prb ) ) {
				return false;
			}

			if ( Lang13.Bool( GlobalFuncs.electrocute_mob( user, this.powernet, this, siemens_coeff ) ) ) {
				s = new EffectSystem_SparkSpread();
				s.set_up( 5, 1, this );
				s.start();
				return true;
			} else {
				return false;
			}
		}

		// Function from file: cable.dm
		public Powernet get_powernet(  ) {
			return this.powernet;
		}

		// Function from file: cable.dm
		public void updateicon(  ) {
			
			if ( this.invisibility != 0 ) {
				this.icon_state = "" + this.d1 + "-" + this.d2 + "-f";
			} else {
				this.icon_state = "" + this.d1 + "-" + this.d2;
			}
			return;
		}

		// Function from file: cable.dm
		public override void hide( bool h = false ) {
			
			if ( this.level == 1 && this.loc is Tile ) {
				this.invisibility = ( h ? 101 : 0 );
			}
			this.updateicon();
			return;
		}

		// Function from file: cable.dm
		public override void Deconstruct(  ) {
			Ent_Static T = null;

			T = this.loc;
			this.stored.loc = T;
			base.Deconstruct();
			return;
		}

		// Function from file: cable.dm
		public override dynamic Destroy(  ) {
			
			if ( this.powernet != null ) {
				this.cut_cable_from_powernet();
			}
			GlobalVars.cable_list.Remove( this );
			return base.Destroy();
		}

		// Function from file: ninjaDrainAct.dm
		public override dynamic ninjadrain_act( Obj_Item_Clothing_Suit_Space_SpaceNinja S = null, Ent_Static H = null, Obj_Item_Clothing_Gloves_SpaceNinja G = null ) {
			dynamic _default = null;

			bool maxcapacity = false;
			int drain = 0;
			Powernet PN = null;
			int drained = 0;
			Obj_Machinery_Power_Terminal T = null;
			Obj_Machinery_Power AP = null;

			
			if ( !( S != null ) || !( H != null ) || !( G != null ) ) {
				return "INVALID";
			}
			maxcapacity = false;
			drain = 0;
			_default = 0;
			PN = this.powernet;

			while (G.candrain && !maxcapacity && this != null) {
				drain = Num13.Floor( Rand13.Int( G.mindrain, G.maxdrain ) / 2 );
				drained = 0;

				if ( PN != null && GlobalFuncs.do_after( H, 10, null, this ) ) {
					drained = Num13.MinInt( drain, ((int)( PN.avail )) );
					PN.load += drained;

					if ( drained < drain ) {
						
						foreach (dynamic _a in Lang13.Enumerate( PN.nodes, typeof(Obj_Machinery_Power_Terminal) )) {
							T = _a;
							

							if ( T.master is Obj_Machinery_Power_Apc ) {
								AP = T.master;

								if ( Lang13.Bool( ((dynamic)AP).operating ) && Lang13.Bool( ((dynamic)AP).cell ) && Convert.ToDouble( ((dynamic)AP).cell.charge ) > 0 ) {
									((dynamic)AP).cell.charge = Num13.MaxInt( 0, Convert.ToInt32( ((dynamic)AP).cell.charge - 5 ) );
									drained += 5;
								}
							}
						}
					}
				} else {
					break;
				}
				S.cell.charge += drained;

				if ( Convert.ToDouble( S.cell.charge ) > ( S.cell.maxcharge ??0) ) {
					_default += drained - Convert.ToDouble( S.cell.charge - S.cell.maxcharge );
					S.cell.charge = S.cell.maxcharge;
					maxcapacity = true;
				} else {
					_default += drained;
				}
				S.spark_system.start();
			}
			return _default;
		}

		// Function from file: swarmer.dm
		public override void swarmer_act( Mob_Living_SimpleAnimal_Hostile_Swarmer S = null ) {
			S.WriteMsg( "<span class='warning'>Disrupting the power grid would bring no benefit to us. Aborting.</span>" );
			return;
		}

	}

}