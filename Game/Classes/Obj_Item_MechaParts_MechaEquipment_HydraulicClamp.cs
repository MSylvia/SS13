// FILE AUTOGENERATED BY SOM13. DO NOT EDIT YET.

using System;
using Somnium.Engine.ByImpl;

namespace Somnium.Game {
	class Obj_Item_MechaParts_MechaEquipment_HydraulicClamp : Obj_Item_MechaParts_MechaEquipment {

		public int dam_force = 20;
		public Obj_Mecha cargo_holder = null;

		protected override void __FieldInit() {
			base.__FieldInit();

			this.equip_cooldown = 15;
			this.energy_drain = 10;
			this.icon_state = "mecha_clamp";
		}

		public Obj_Item_MechaParts_MechaEquipment_HydraulicClamp ( dynamic loc = null ) : base( (object)(loc) ) {
			
		}

		// Function from file: work_tools.dm
		[VerbInfo( name: "action" )]
		[VerbArg( 1, InputType.Mob | InputType.Obj | InputType.Tile | InputType.Zone )]
		public override bool f_action( dynamic target = null ) {
			dynamic O = null;
			dynamic M = null;

			
			if ( !this.action_checks( target ) ) {
				return false;
			}

			if ( !( this.cargo_holder != null ) ) {
				return false;
			}

			if ( target is Obj ) {
				O = target;

				if ( !Lang13.Bool( O.anchored ) ) {
					
					if ( Convert.ToDouble( ((dynamic)this.cargo_holder).cargo.len ) < Convert.ToDouble( ((dynamic)this.cargo_holder).cargo_capacity ) ) {
						this.chassis.visible_message( "" + this.chassis + " lifts " + target + " and starts to load it into cargo compartment." );
						O.anchored = 1;

						if ( this.do_after_cooldown( target ) ) {
							((dynamic)this.cargo_holder).cargo += O;
							O.loc = this.chassis;
							O.anchored = 0;
							this.occupant_message( "<span class='notice'>" + target + " successfully loaded.</span>" );
							this.log_message( "Loaded " + O + ". Cargo compartment capacity: " + ( ((dynamic)this.cargo_holder).cargo_capacity - ((dynamic)this.cargo_holder).cargo.len ) );
						} else {
							O.anchored = Lang13.Initial( O, "anchored" );
						}
					} else {
						this.occupant_message( "<span class='warning'>Not enough room in cargo compartment!</span>" );
					}
				} else {
					this.occupant_message( "<span class='warning'>" + target + " is firmly secured!</span>" );
				}
			} else if ( target is Mob_Living ) {
				M = target;

				if ( Convert.ToInt32( M.stat ) == 2 ) {
					return false;
				}

				if ( this.chassis.occupant.a_intent == "harm" ) {
					((Mob_Living)M).take_overall_damage( this.dam_force );

					if ( !Lang13.Bool( M ) ) {
						return false;
					}
					((Mob_Living)M).adjustOxyLoss( Num13.Floor( this.dam_force / 2 ) );
					((Mob_Living)M).updatehealth();
					((Ent_Static)target).visible_message( "<span class='danger'>" + this.chassis + " squeezes " + target + ".</span>", "<span class='userdanger'>" + this.chassis + " squeezes " + target + ".</span>", "<span class='italics'>You hear something crack.</span>" );
					GlobalFuncs.add_logs( this.chassis.occupant, M, "attacked", "" + this.name, "(INTENT: " + String13.ToUpper( this.chassis.occupant.a_intent ) + ") (DAMTYE: " + String13.ToUpper( this.damtype ) + ")" );
				} else {
					Map13.StepAway( M, this.chassis, null );
					this.occupant_message( "You push " + target + " out of the way." );
					this.chassis.visible_message( "" + this.chassis + " pushes " + target + " out of the way." );
				}
				return true;
			}
			return false;
		}

		// Function from file: work_tools.dm
		public override void detach( dynamic moveto = null ) {
			base.detach( (object)(moveto) );
			this.cargo_holder = null;
			return;
		}

		// Function from file: work_tools.dm
		public override void attach( Obj_Mecha M = null ) {
			base.attach( M );
			this.cargo_holder = M;
			return;
		}

		// Function from file: work_tools.dm
		public override bool can_attach( Obj_Mecha M = null ) {
			
			if ( base.can_attach( M ) ) {
				
				if ( M is Obj_Mecha_Working_Ripley ) {
					return true;
				}
			}
			return false;
		}

	}

}